<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>03-容器</title>
      <link href="/2020/08/05/03-rong-qi/"/>
      <url>/2020/08/05/03-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="1-容器总结"><a href="#1-容器总结" class="headerlink" title="1. 容器总结"></a>1. 容器总结</h2><h3 id="1-继承关系"><a href="#1-继承关系" class="headerlink" title="1. 继承关系"></a>1. 继承关系</h3><ul><li><p><strong>Collection</strong> 接口</p><ul><li><p><strong>List</strong> 接口</p><ol><li><strong>ArrayList</strong>：Object数组。线程不安全。</li><li><strong>Vector</strong>：Object数组。线程安全。<ol start="3"><li><strong>LinkedList</strong>：双向链表（JDK 1.6 前为循环链表，JDK 1.7取消了循环）。线程不安全。</li></ol></li></ol></li><li><p><strong>Set</strong> 接口</p><ol><li>*<em>HashSet *</em>：无序，唯一。基于 HashMap 实现，底层采用 HashMap 来保存元素。</li><li><strong>LinkedHashSet</strong>：LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。 <ol start="3"><li><strong>TreeSet</strong>：有序，唯一。红黑树实现。</li></ol></li></ol></li><li><p><strong>Queue</strong> / Dqueue 接口</p><ol><li><strong>LinkedList</strong>：双向链表（JDK 1.6 前为循环链表，JDK 1.7取消了循环）。线程不安全。<ol start="2"><li><strong>PriorityQueue</strong>：优先队列，元素必须是可比较的，是<strong>小根堆的实现</strong>。</li></ol></li></ol></li></ul></li><li><p><strong>Map</strong> 接口</p><ul><li><p><strong>HashMap</strong>：  JDK1.8之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）而小于 64时，那么会选择先进行数组扩容，当链表长度大于64时，将链表转化为红黑树，以减少搜索时间 。</p></li><li><p><strong>LinkedHashMap</strong>：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 </p></li><li><p><strong>Hashtable</strong>：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p></li><li><p><strong>TreeMap</strong>：有序哈希表，对加入的元素进行排序，红黑树实现。 </p></li></ul></li></ul><p><img src="03-%E5%AE%B9%E5%99%A8.assets/Java-Collections.jpeg" alt=""></p><hr><h3 id="2-如何选用集合"><a href="#2-如何选用集合" class="headerlink" title="2. 如何选用集合"></a>2. 如何选用集合</h3><ol><li>需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap。</li><li>只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。 </li></ol><hr><h3 id="3-List-Set-Map三者的区别"><a href="#3-List-Set-Map三者的区别" class="headerlink" title="3. List, Set, Map三者的区别"></a>3. List, Set, Map三者的区别</h3><ul><li>List：对付顺序的好帮手。List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象。</li><li>Set：注重独一无二的性质。不允许重复，不可以有多个元素引用相同的对象。</li><li>Map：用Key搜索。使用键值对存储。两个Key可以引用相同的对象，但Key不能重复。</li></ul><hr><h3 id="4-hashcode-和-equals-的区别和联系"><a href="#4-hashcode-和-equals-的区别和联系" class="headerlink" title="4. hashcode 和 equals 的区别和联系"></a>4. hashcode 和 equals 的区别和联系</h3><ul><li>两个<strong>不同对象</strong>的 hashcode 值可能相等，但 <code>equals()</code> 值不可能相等。</li><li>HashSet 在检查重复时，会先检查 hashcode，如果hashcode 值已存在，则调用 <code>equals()</code> 方法检查hashcode相等的对象是否真的相等。</li></ul><ol><li>两个对象 hashcode 相等，它们不一定相等，两个 <code>equals()</code>不一定返回true；</li><li>两个 <code>equals()</code> 返回true，hashcode 一定相等；</li><li>若重写了 <code>equals()</code> 方法，则有必要重写 <code>hashCode()</code> 方法，否则可能导致相同的对象有不同的hashcode；</li></ol><ul><li>举例：若String类重写了 <code>equals()</code> 方法，用来比较字符串的内容是否相等，但没有重写 <code>hashCode()</code> 方法。那么 s1 = juruikang，s2 = juruikang 在调用 <code>equals()</code> 方法时是true，但 <code>hashCode()</code> 方法返回的值不相等（默认返回地址值）。</li></ul><hr><h3 id="5-和-equals-的区别"><a href="#5-和-equals-的区别" class="headerlink" title="5. == 和 equals 的区别"></a>5. == 和 equals 的区别</h3><ol><li>== 如果作用于基本数据类型的变量，则直接比较其值是否相等；如果作用于引用类型的变量，则比较其指向对象的地址值是否相等。</li><li><code>equals()</code> 方法不能作用于基本数据类型的变量，因为其是Object类中的方法。<strong>如果没有重写 <code>equals()</code> 方法，则比较其指向对象的地址值是否相等</strong>；如果重写了 <code>equals()</code> 方法，如String等类，则比较其所指向对象的内容是否相等。</li></ol><hr><h2 id="2-其他常用类"><a href="#2-其他常用类" class="headerlink" title="2. 其他常用类"></a>2. 其他常用类</h2><h3 id="1-String-的不变性"><a href="#1-String-的不变性" class="headerlink" title="1. String 的不变性"></a>1. String 的不变性</h3><ol><li><strong>String 类被 final 修饰</strong>，说明其不可能被继承了，也就是说任何对 String 的操作方法，都不会被覆盖重写； </li><li><strong>String 中实际保存数据的是一个 char 数组 value</strong>，而这个数组也是被 final 修饰的，且 value 的权限是 private，外部无法访问， String 类中也没有开放对 value 进行赋值的方法，因此 value 一旦被赋值，就无法被修改。</li></ol><ul><li>因为 String 具有不变性，所以 <strong>String 的大多数操作方法，都会返回新的 String</strong>。如<code>replace()</code> <code>substring()</code>等。</li></ul><hr><h3 id="2-String-判断相等"><a href="#2-String-判断相等" class="headerlink" title="2. String 判断相等"></a>2. String 判断相等</h3><ol><li>String 判断相等有两种方法，<code>equals()</code>和<code>equalsIgnoreCase()</code>，后者判断相等时，会忽略大小写。<strong>String 判断相等不可以用 <code>==</code></strong>，这只是比较地址是否相等。</li><li><code>equals()</code> 的判断逻辑：当判断两个 String 时，首先判断<strong>地址值</strong>是否相等，若相等再判断<strong>长度</strong>是否相等，若相等则逐一比较 <strong>value</strong> 数组中的字符是否相等，全部相等则返回<code>true</code>。</li></ol><ul><li><strong>== 会漏判虽然地址值不等，但内容相等的字符串</strong>。</li></ul><hr><h3 id="3-String-常量池"><a href="#3-String-常量池" class="headerlink" title="3. String 常量池"></a>3. String 常量池</h3><ul><li>创建字符串的两种方式</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//直接用双引号创建</span>String s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//用new关键字新建一个字符串对象</span>String s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token operator">==</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><ul><li>两种方式的区别<ol><li>第一种方式创建字符串时， <strong>引用指向字符串常量区</strong>。<strong>JVM首先会去字符串池中查找是否存在”abc”这个对象，如果不存在，则在字符串常量池中创建”abc”这个对象，然后将池中”abc”这个对象的引用地址返回给”abc”对象的引用s1，这样s1会指向字符串常量池中”abc”这个字符串对象；如果存在，则不创建任何对象，直接将池中”abc”这个对象的地址返回，赋给引用s2。</strong> </li><li>第二种方式创建字符串时，<strong>引用指向堆</strong>。 <strong>JVM首先在字符串池中查找有没有”xyz”这个字符串对象，如果没有，则首先在字符串池中创建一个”xyz”字符串对象，然后再在堆中创建一个”xyz”字符串对象，然后将堆中这个”xyz”字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个”xyz”字符串对象。如果有，则不在池中再去创建”xyz”这个对象了，直接在堆中创建一个”xyz”字符串对象，然后将堆中的这个”xyz”对象的地址返回赋给引用s4，这样，s4就指向了堆中创建的这个新的”xyz”字符串对象</strong>。</li></ol></li><li>不管用哪种方式，都会先检查字符串常量池。如果字符串常量池中不存在待创建的字符串，<strong>两种方式都会在字符串常量池中创建这个对象</strong>。</li></ul><hr><h3 id="4-String-的拆分和合并"><a href="#4-String-的拆分和合并" class="headerlink" title="4. String 的拆分和合并"></a>4. String 的拆分和合并</h3><ol><li>拆分：<code>split()</code> 方法返回的是一个 String 数组，要注意的是，<strong>空值是拆分不掉的</strong>，得到的数组中会仍然保存空值。另一点是，<strong>两个相邻的分隔符间，会分离出一个空值</strong>，例如：</li></ol><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span><span class="token string">",a,,b,"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span></code></pre><ol start="2"><li>合并：<code>join()</code> 方法返回一个 String，参数分别是连接符和数据源（数组，可以是 String ，也可以是 list）。但注意的是 <code>join()</code> <strong>不可以链式使用</strong>，如<code>join().join()</code> ，因为第一次的值会被第二次覆盖掉。</li></ol><hr><h3 id="5-StringBuilder-和-StringBuffer"><a href="#5-StringBuilder-和-StringBuffer" class="headerlink" title="5. StringBuilder 和 StringBuffer"></a>5. StringBuilder 和 StringBuffer</h3><ol><li>二者和 String 的区别：<strong>String 中用 char 类型的数组来存储，并且这个数组被 final 修饰，不可修改。因此，想要增加 String 的长度，如 <code>str1 = str1 + "jrk";</code>，会产生多个冗余对象，造成浪费和消耗。</strong>上例中，”jrk” 会先检查常量池，若池中不存在，则现在池中创建一个 “jrk” 对象，再在堆中创建一个对象，与 str1 相加得到一个新的 String 对象，再将原 str1 的引用指向新对象。原地址内的内容和 “jrk” 对象不再被使用，成了冗余对象，等待垃圾回收。<strong>StringBuilder 和 StringBuffer 内部也是用 char 数组存储，但没有被 final 修饰，增加长度时，会复制一个新的 char 数组，加入元素，再把引用指向新的数组。</strong></li><li>StringBuilder 和 StringBuffer 的区别：<strong>StringBuffer 中使用了同步机制，内部方法用 synchronized 修饰，保证了线程安全，而 StringBuilder 不保证线程安全。</strong></li><li>使用建议：StringBuilder 效率最高，不需要保证线程安全时使用 StringBuilder；需要保证线程安全时使用 StringBuffer。</li></ol><hr><h3 id="6-Stack-栈"><a href="#6-Stack-栈" class="headerlink" title="6. Stack 栈"></a>6. Stack 栈</h3><ul><li>是 Vector 的一个子类，同属接口 Collection，List 之下，本质是 List。</li><li>由于继承了 Vector，<strong>线程安全</strong>。</li><li><strong>先进后出</strong>。</li></ul><hr><h2 id="3-各容器常用方法总结"><a href="#3-各容器常用方法总结" class="headerlink" title="3. 各容器常用方法总结"></a>3. 各容器常用方法总结</h2><h3 id="1-Collection-接口共性方法"><a href="#1-Collection-接口共性方法" class="headerlink" title="1. Collection 接口共性方法"></a>1. Collection 接口共性方法</h3><ol><li><code>add(E e)</code>：添加元素</li><li><code>remove(int index)</code>：删除元素</li><li><code>clear()</code>：清空元素</li><li><code>isEmpty()</code>：判断容器是否为空</li><li><code>contains()</code>：判断元素是否存在</li><li><code>size()</code>：返回元素个数</li><li><code>toArray()</code>：转为 Obejct 数组</li></ol><hr><h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2. ArrayList"></a>2. ArrayList</h3><ul><li>所属包：java.util.ArrayList</li><li>线程安全：<strong>CopyOnWriteArrayList</strong>、Vector 和 collections 工具类下的 <code>synchronizedList(List&lt;T&gt; list)</code>。</li><li><strong>常用方法</strong>：<code>add(E e)</code> <code>get()</code> <code>remove(int index)</code> <code>size()</code> 和 <code>toArray()</code> 等，多为 Collection 接口共性方法。</li></ul><hr><h3 id="3-LinkedList"><a href="#3-LinkedList" class="headerlink" title="3. LinkedList"></a>3. LinkedList</h3><ul><li>所属包：java.util.LinkedList</li><li>线程安全：队列接口的线程安全类有阻塞（ConcurrentLinkedQueue）和非阻塞队列（LinkedBlockingQueue），collections 工具类下的 <code>synchronizedList(List&lt;T&gt; list)</code> 也可以接收LinkedList（多态写法）。</li><li><strong>常用方法</strong>：<code>add(E e)</code> <code>addFirst()</code> <code>get(int index)</code> <code>getFirst()</code> <code>getLast()</code> <code>removeFirst()</code> <code>removeLast()</code> <code>size()</code> <code>contains()</code>等。</li></ul><hr><h3 id="4-HashMap"><a href="#4-HashMap" class="headerlink" title="4. HashMap"></a>4. HashMap</h3><ul><li>所属包：java.util.HashMap</li><li>线程安全：<strong>ConcurrentHashMap</strong> 和 ConcurrentSkipListMap，也可以通过  <code>Collections.synchronizedMap()</code> 方法来包装 HashMap。</li><li><strong>常用方法</strong>：<code>put(key value)</code> <code>get(key/value)</code>  <code>containsKey(key)</code> <code>containsValue()</code> <code>remove(key)</code> <code>size()</code> <code>entrySet()</code> <code>keySet()</code> 等。</li></ul><hr><h3 id="5-HashSet"><a href="#5-HashSet" class="headerlink" title="5. HashSet"></a>5. HashSet</h3><ul><li>所属包：java.util.HashSet</li><li>线程安全：<strong>CopyOnWriteArraySet</strong> 和 ConcurrentSkipListSet，<code>Collections.synchronizedSet()</code> 方法来包装 HashSet。</li><li><strong>常用方法</strong>：<code>add(E e)</code> <code>remove(Obj)</code> <code>contains(Obj)</code> <code>size()</code> 等。</li></ul><hr><h3 id="6-StringBuilder-和-StringBuffer"><a href="#6-StringBuilder-和-StringBuffer" class="headerlink" title="6. StringBuilder 和 StringBuffer"></a>6. StringBuilder 和 StringBuffer</h3><ul><li>所属包：java.lang，无需导包。</li><li>线程安全：StringBuilder 线程不安全，StringBuffer 线程安全。</li><li><strong>常用方法</strong>：<code>append(str)</code> <code>charAt()</code> <code>insert(index, str)</code> <code>delete(start, end)</code>（左闭右开） <code>length()</code> <code>reverse()</code> <code>replace(index, str)</code> <code>toString()</code> 等。</li></ul><hr><h3 id="7-Stack"><a href="#7-Stack" class="headerlink" title="7. Stack"></a>7. Stack</h3><ul><li>所属包：java.util.Stack</li><li>线程安全：安全</li><li><strong>常用方法</strong>：<code>push()</code> <code>pop()</code> <code>peek()</code> <code>isEmpty()/empty()</code> 等。</li></ul><hr><h3 id="8-方法对比表"><a href="#8-方法对比表" class="headerlink" title="8. 方法对比表"></a>8. 方法对比表</h3><table><thead><tr><th align="center"></th><th align="center">ArrayList</th><th align="center">LinkedList</th><th align="center">HashSet</th><th align="center">Stack</th><th align="center">HashMap</th><th align="center">StringBuilder / StringBuffer</th></tr></thead><tbody><tr><td align="center">加入元素</td><td align="center"><code>add()</code></td><td align="center"><code>add()</code> / <strong><code>addFirst()</code></strong></td><td align="center"><code>add()</code></td><td align="center"><strong><code>push()</code></strong></td><td align="center"><strong><code>put()</code></strong></td><td align="center"><strong><code>append()</code></strong></td></tr><tr><td align="center">获取元素</td><td align="center"><code>get()</code></td><td align="center"><code>get(index)</code> / <strong><code>getFirst()</code> / <code>getLast()</code></strong></td><td align="center">——</td><td align="center"><code>peek()</code></td><td align="center"><code>get(key)</code> / <code>get(value)</code></td><td align="center"><strong><code>charAt()</code></strong></td></tr><tr><td align="center">删除元素</td><td align="center"><code>remove()</code></td><td align="center"><strong><code>removeFirst()</code> / <code>removeLast()</code></strong></td><td align="center"><code>remove()</code></td><td align="center"><code>pop()</code></td><td align="center"><code>remove(key)</code></td><td align="center"><strong><code>delete(start, end)</code></strong></td></tr><tr><td align="center">容量 / 长度</td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><strong><code>length()</code></strong></td></tr><tr><td align="center">通用方法</td><td align="center"><code>clear()</code> / <code>isEmpty()</code>/ <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code> / <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code>/ <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code>/ <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code> / <code>containsKey()</code></td><td align="center">——</td></tr><tr><td align="center">其他</td><td align="center">——</td><td align="center">——</td><td align="center">——</td><td align="center">——</td><td align="center"><code>entrySet()</code> / <code>keySet()</code></td><td align="center"><code>toString()</code></td></tr></tbody></table><hr><h2 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h2><h2 id="5-比较器"><a href="#5-比较器" class="headerlink" title="5. 比较器"></a>5. 比较器</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-网络</title>
      <link href="/2020/08/05/04-wang-luo/"/>
      <url>/2020/08/05/04-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-OSI-和-TCP-IP-的分层结构"><a href="#1-OSI-和-TCP-IP-的分层结构" class="headerlink" title="1. OSI 和 TCP/IP 的分层结构"></a>1. OSI 和 TCP/IP 的分层结构</h2><h3 id="1-分层介绍"><a href="#1-分层介绍" class="headerlink" title="1. 分层介绍"></a>1. 分层介绍</h3><ul><li>OSI的体系结构分为七层，TCP/IP 的体系结构分为四层；</li><li>学习计算机网络使用的是一种折中的办法，分为五层的体系结构，<strong>从下到上分别为：物理层、数据链路层、网络层、运输层和应用层</strong>。</li></ul><hr><h3 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h3><p><strong>应用层（application layer）</strong>的任务是<strong>通过应用进程间的交互</strong>来完成特定的网络应用。应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。</p><ul><li>对于不同的网络应用需要不同的应用层协议，如<strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等。我们把<strong>应用层交互的数据单元称为报文</strong>。<ul><li><strong>域名系统（DNS，Domain Name System）</strong>是因特网的一项核心服务，它作为可以将<strong>域名和 IP 地址相互映射</strong>的分布式数据库，能够使人们方便的访问互联网，而不用记住 IP 数串。如 <a href="http://www.baidu.com等。" target="_blank" rel="noopener">www.baidu.com等。</a></li><li><strong>超文本传输协议（HTTP，HyperText Transfer Protocol）</strong>是互联网上最为广泛应用的网络协议之一，所有的 WWW 文件都必须遵守这个协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</li><li><strong>文件传输协议（FTP，File Transfer Protocol）</strong>：用于 Internet 上的控制文件的<strong>双向传输</strong>。在 FTP 的使用当中，用户经常遇到两个概念：<strong>下载（Download） 和上传（Upload）</strong>。在进进行文件传输时，FTP 的客户和服务器之间要先建立<strong>两个并行的 TCP 连接：控制连接和数据连接</strong>。实际用于传输文件的是数据连接。 </li><li><strong>简单文件传输协议（TFTP，Trivial File Transfer Protocol）</strong>：是 <strong>TCP/IP 协议族</strong>中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。</li><li><strong>简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）</strong>：它是一组用于<strong>将邮件由源地址传送到目的地址</strong>的规则，由它来控制信件的中转方式。SMTP 协议属于 <strong>TCP/IP 协议族</strong>，它帮助每台计算机在发送或中转信件时找到下一个目的地。</li><li><strong>邮局协议 3（Post Office Protocol 3）</strong>：是 <strong>TCP/IP 协议族</strong>中的一员，协议主要用于支持使用客户端远程管理在服务器上的电子邮件。</li><li><strong>网络邮件访问协议（Internet Mail Access Protocol）</strong>：主要作用是邮件客户端从服务端获取邮件信息，下载邮件等。对于阅读、标记、移动和删除等操作，<strong>IMAP 协议使客户端与邮箱更新同步，POP3 协议仅在客户端内</strong>。</li><li><strong>电子邮件系统</strong>：一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li></ul></li></ul><hr><h3 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h3><p><strong>运输层（transport layer）</strong>的任务是向<strong>两台主机进程之间的通信</strong>提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p><p><strong>运输层主要使用两种协议</strong>：</p><ul><li><strong>传输控制协议 TCP</strong>：提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>：提供<strong>无连接</strong>的，<strong>不保证可靠</strong>的数据传输服务。</li></ul><hr><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h3><p>计算机网络中进行通信的两个计算机之间可能会经过很多个<strong>数据链路</strong>，也可能还要经过很多<strong>通信子网</strong>。<strong>网络层</strong>的任务是，当<strong>两个计算机间进行通信</strong>时，<strong>选择合适的网间路由和交换结点</strong>，确保数据及时传送。</p><ul><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</li><li>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。 </li><li><strong>子网掩码</strong>：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。</li></ul><hr><h3 id="5-数据链路层"><a href="#5-数据链路层" class="headerlink" title="5. 数据链路层"></a>5. 数据链路层</h3><p><strong>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong></p><ul><li><p>在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p></li><li><p>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）。</p></li><li><p>数据链路层传输协议的数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong>。</p></li><li><p><strong>MAC 地址</strong>：意译为媒体访问控制，或称为<strong>物理地址、硬件地址，用来定义网络设备的位置</strong>。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此<strong>一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址</strong>。</p></li></ul><hr><h3 id="6-物理层"><a href="#6-物理层" class="headerlink" title="6. 物理层"></a>6. 物理层</h3><ul><li><strong>在物理层上所传送的数据单位是比特</strong>。</li><li><strong>物理层（physical layer）</strong>的作用是实现<strong>相邻计算机节点之间比特流的透明传送</strong>，尽可能屏蔽掉具体传输介质和物理设备的差异。</li><li>“透明传送比特流” 表示<strong>经实际电路传送后的比特流没有发生变化</strong>，对传送的比特流来说，这个电路好像是看不见的。</li></ul><hr><h2 id="2-TCP-和-UDP"><a href="#2-TCP-和-UDP" class="headerlink" title="2. TCP 和 UDP"></a>2. TCP 和 UDP</h2><h3 id="1-TCP-三次握手"><a href="#1-TCP-三次握手" class="headerlink" title="1. TCP 三次握手"></a>1. TCP 三次握手</h3><ol><li><strong>客户端</strong>发送带有 <strong>SYN 标志</strong>的数据包给服务端——一次握手；</li><li><strong>服务端</strong>发送带有 <strong>SYN/ACK 标志</strong>的数据包给客户端——二次握手；</li><li><strong>客户端</strong>发送带有 <strong>ACK 标志</strong>的数据包给服务端——三次握手；</li></ol><ul><li><strong>客户端先发送</strong>。</li></ul><hr><h3 id="2-为什么要三次握手"><a href="#2-为什么要三次握手" class="headerlink" title="2. 为什么要三次握手"></a>2. 为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道</strong>。说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的。</strong> </p><ol><li>第一次握手：服务端确认<strong>客户端发送正常，自己接收正常</strong>；</li><li>第二次握手：<strong>客户端</strong>确认<strong>自己发送、接收正常，服务端发送、接收正常</strong>（客户端确认完成）；</li><li>第三次握手：<strong>服务端</strong>确认<strong>自己发送、接收正常，客户端发送、接收正常</strong>（服务端确认完成）。</li></ol><ul><li>因此三次握手就能使双方确认，自己和对方都收发正常。</li></ul><hr><h3 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4. 四次挥手"></a>4. 四次挥手</h3><ol><li><strong>客户端</strong>发送一个带有 <strong>FIN 标志</strong>的报文给服务端，进入 WAIT-1 状态，表示释放连接——一次挥手；</li><li><strong>服务端</strong>发送一个带有 <strong>ACK 标志</strong>的报文给客户端，表示确认收到；客户端收到确认报文，进入 WAIT-2状态——二次挥手；</li><li><strong>服务端</strong>发送完所有数据后，发送一个带有 <strong>FIN 标志</strong>的报文给客户端，进入 LAST-ACK 状态，表示释放连接——三次挥手；</li><li><strong>客户端</strong>发送一个带有 <strong>ACK 标志</strong>的报文给服务端，表示确认——四次挥手。</li></ol><ul><li>注意：<strong>当客户端发送最后的确认后，并不会立刻释放连接，必须经过 2*MSL（最长报文段寿命）的时间后，客户端才会关闭 TCB（传输控制块）。而服务端接收到确认后，立即进入 CLOSED 状态。因此，服务端结束的时间要比客户端早一些</strong>。</li></ul><hr><h3 id="5-为什么客户端断开前需要等待-2MSL"><a href="#5-为什么客户端断开前需要等待-2MSL" class="headerlink" title="5. 为什么客户端断开前需要等待 2MSL"></a>5. 为什么客户端断开前需要等待 2MSL</h3><ol><li>客户端发送确认报文后，这个报文可能丢失；</li><li>服务端迟迟接收不到确认报文，会重新发送请求断开连接报文；</li><li>客户端在这 2MSL 时间内就会收到新的报文，再次发送确认报文，并重启 2MSL 计时器。</li></ol><hr><h3 id="6-为什么挥手比握手多了一次"><a href="#6-为什么挥手比握手多了一次" class="headerlink" title="6. 为什么挥手比握手多了一次"></a>6. 为什么挥手比握手多了一次</h3><ol><li>建立连接时，服务器接收到 SYN 报文后，<strong>将 SYN 和 ACK 放在一个报文中</strong>发送给客户端。</li><li>关闭连接时，服务器接收到 FIN 报文后，<strong>可能还有未发送完的数据，于是先发送 ACK 表示确认，待数据都发送完后，再发送 FIN 报文请求关闭连接</strong>。由于 <strong>ACK 和 FIN 报文分开发送</strong>，从而导致挥手比握手多了一次。</li></ol><hr><h3 id="7-TCP-和-UDP-的区别"><a href="#7-TCP-和-UDP-的区别" class="headerlink" title="7. TCP 和 UDP 的区别"></a>7. TCP 和 UDP 的区别</h3><ul><li><strong>UDP 在传输数据前不需要先建立连接</strong>，接收端主机收到 UDP 报文后，<strong>不需要给出任何确认</strong>。一般用于语音、视频和直播等即时通信。</li><li><strong>TCP 是面向连接的服务</strong>。TCP 在传输数据前必须先有<strong>三次握手</strong>建立连接，数据传送后要有<strong>四次挥手</strong>关闭连接，并且在数据传递时，有确认、窗口。重传和拥塞控制机制。也由于这些保证， TCP 的开销比 UDP 大，一般用于文件传输、发送和接收邮件、远程登录等场景。</li></ul><hr><h3 id="8-TCP-如何保证可靠传输"><a href="#8-TCP-如何保证可靠传输" class="headerlink" title="8. TCP 如何保证可靠传输"></a>8. TCP 如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为合适的<strong>数据块（分组）进行发送</strong>；</li><li>TCP 给发送的<strong>每一个包编号</strong>，接收方对数据包进行排序，把有序数据传到应用层；</li><li><strong>校验和</strong>：TCP 保持它首部和数据的检验和。这是一个端到端的检验和，目的是<strong>检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段；</li><li>TCP 的接收端会<strong>丢弃重复的数据</strong>；</li><li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议，<strong>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小</strong>，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据；</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送；</li><li><strong>ARQ 协议</strong>：每发完一个分组就<strong>停止发送</strong>，等待对方确认，收到确认后再发送下一个分组。也有<strong>连续 ARQ 协议，特点是 Go-Back-N</strong>。</li><li><strong>超时重传</strong>：当 TCP 发出一个分组后，它启动一个定时器，等待接收端确认收到。<strong>如果不能及时收到一个确认，将重发这个分组</strong>。</li></ol><hr><h2 id="3-HTTP-协议"><a href="#3-HTTP-协议" class="headerlink" title="3. HTTP 协议"></a>3. HTTP 协议</h2><h3 id="1-HTTP-简介"><a href="#1-HTTP-简介" class="headerlink" title="1. HTTP 简介"></a>1. HTTP 简介</h3><ul><li>工作原理：HTTP 协议工作在客户端 / 服务器架构上（C / S）。<strong>浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即WEB服务器发送所有请求</strong>。</li><li><strong>HTTP 默认端口号为 80</strong>，可以修改。</li><li><strong>注意事项</strong>：<ol><li>HTTP 是<strong>无连接</strong>的（短连接）：<strong>每次连接只处理一个请求</strong>。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 </li><li>HTTP 是<strong>无状态</strong>的：无状态指协议<strong>对事物处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>HTTP 是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。 </li></ol></li></ul><hr><h3 id="2-HTTP-消息结构"><a href="#2-HTTP-消息结构" class="headerlink" title="2. HTTP 消息结构"></a>2. HTTP 消息结构</h3><ul><li><p>客户端：客户端发送一个 HTTP 请求到服务器，请求消息包括以下格式：<strong>请求行（request line）、请求头部（header）</strong>、空行和请求数据。</p><ul><li><strong>请求行</strong>中包括：<strong>请求方法</strong>（最常用的方法为 GET 和 POST）、<strong>URL</strong> 和<strong>协议版本</strong>，用空格隔开。</li><li><strong>请求头部</strong>内格式为：<strong>头部字段名 ：值</strong>（可以有多个）。</li></ul></li><li><p>服务器端：服务器端响应消息包括以下格式：<strong>状态行</strong>、消息报头、空行和响应正文。</p><ul><li><strong>状态行</strong>中包括：协议版本和<strong>状态码</strong>。常用状态码有：<strong>200（OK）</strong>、301（资源被永久转移到其他 URL）、<strong>404（请求的资源不存在）</strong>和 500（内部服务器错误）等。</li></ul></li></ul><hr><h3 id="3-HTTP-方法"><a href="#3-HTTP-方法" class="headerlink" title="3. HTTP 方法"></a>3. HTTP 方法</h3><ol><li><strong>GET：请求指定的页面信息，并返回实体主体。</strong></li><li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</li><li><strong>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新资源的建立和/或已有资源的修改。</strong></li><li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE：请求服务器删除指定的页面。</li><li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS：允许客户端查看服务器的性能。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新。</li></ol><ul><li><strong>其中最常用的方法为 GET 和 POST。</strong></li></ul><hr><h3 id="4-HTTP-长连接和短连接"><a href="#4-HTTP-长连接和短连接" class="headerlink" title="4. HTTP 长连接和短连接"></a>4. HTTP 长连接和短连接</h3><ul><li><strong>HTTP/1.0 中默认使用短连接</strong>。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。 </li><li><strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。在使用长连接的情况下，<strong>当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接</strong>。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li><li><strong>优缺点</strong>：请求频繁时，长连接省去较多 TCP 建立和关闭连接的操作，减少浪费，节约时间。请求不频繁时，短连接便于管理，不像长连接需要保活等，存在的连接都是有用的连接。</li><li><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</strong>。</li></ul><hr><h3 id="5-URI-和-URL-的区别"><a href="#5-URI-和-URL-的区别" class="headerlink" title="5. URI 和 URL 的区别"></a>5. URI 和 URL 的区别</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，<strong>可以唯一标识一个资源</strong>。</li><li>URL(Uniform Resource Location) 是统一资源定位符，<strong>可以提供该资源的路径</strong>。它是一种具体的 URI，即 <strong>URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源</strong>。 </li></ul><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><hr><h3 id="6-HTTP-和-HTTPS-的区别"><a href="#6-HTTP-和-HTTPS-的区别" class="headerlink" title="6. HTTP 和 HTTPS 的区别"></a>6. HTTP 和 HTTPS 的区别</h3><ol><li><strong>端口</strong>：HTTP 的 URL 由 “http://” 起始且默认使用端口 80，而 HTTPS 的 URL 由 “https://” 起始且默认使用端口 443。 </li><li><strong>安全性和资源消耗：</strong> <strong>HTTP 协议</strong>运行在 TCP 之上，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份。<strong>HTTPS 协议</strong>是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP之上。所有传输的内容都经过<strong>加密</strong>。所以，<strong>HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源</strong>。</li></ol><hr><h3 id="7-从输入-URL-到显示页面的过程"><a href="#7-从输入-URL-到显示页面的过程" class="headerlink" title="7. 从输入 URL 到显示页面的过程"></a>7. 从输入 URL 到显示页面的过程</h3><ol><li>DNS解析：通过 URL 找到服务器 IP 地址；</li><li>建立 TCP 连接；</li><li>发送 HTTP 请求；</li><li>服务器处理请求并返回 HTTP 报文；</li><li>浏览器解析并渲染页面；</li><li>关闭连接。</li></ol><hr><h2 id="4-Session-和-Cookie"><a href="#4-Session-和-Cookie" class="headerlink" title="4. Session 和 Cookie"></a>4. Session 和 Cookie</h2><h3 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h3><ul><li>Cookie 实际是一段文本数据，用于记录用户状态，保存在客户端：<ul><li>客户端请求服务器，如果服务器需要记录该用户的状态，就会使用 response 客户端发送一个 Cookie（相当于身份证号码），客户端会把 Cookie 保存起来；</li><li>当客户端再次请求服务器时，会把请求和 Cookie 一同提交给服务器，服务器检查 Cookie 以确认用户状态。服务器还可以根据需要修改 Cookie 的内容。</li></ul></li><li><strong>Cookie 的有效期</strong>：Cookie 的 maxAge 决定 Cookie 的有效期。<strong>maxAge 为正数时</strong>，浏览器会将maxAge为正数的 Cookie 持久化，即<strong>写到对应的 Cookie 文件中</strong>。无论客户关闭了浏览器还是电脑，只要还在 maxAge 秒之前，登录网站时该 Cookie 仍然有效。<strong>maxAge 为负数时</strong>，表示该 Cookie 仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。这种 Cookie <strong>不会被写入文件中， Cookie 信息保存在浏览器内存中</strong>，因此关闭浏览器该 Cookie 就消失了。<strong>Cookie 默认的 maxAge 值为 –1</strong>，也就是说 Cookie 默认是会话 Cookie。<strong>maxAge 为0时</strong>，表示<strong>删除</strong>该 Cookie。</li><li><strong>Cookie 的修改和删除</strong>：response 对象提供的 Cookie 操作方法只有一个添加操作 <code>add(Cookie cookie)</code>。要想修改 Cookie 只能使<strong>用一个同名的 Cookie 来覆盖原来的 Cookie</strong>，达到修改的目的。删除时用一个 maxAge 为 0 的同名 Cookie 覆盖原来的 Cookie。</li></ul><hr><h3 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h3><ul><li>Session 另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而 <strong>Session 保存在服务器上</strong>。<ul><li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。</li><li>客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态。 </li></ul></li><li>每个来访者对应一个 Session 对象，<strong>所有该客户的状态信息都保存在这个 Session 对象里。Session 对象是在客户端第一次请求服务器的时候自动创建的</strong>。Session也是一种 key-value 的属性对。</li><li><strong>Session 有效期</strong>：Session 保存在服务器端。<strong>为了获得更高的存取速度，服务器一般把Session放在内存里</strong>。每个用户都会有一个独立的 Session。<strong>为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间</strong>。如果超过了超时时间没访问过服务器，Session就自动失效了。</li><li>Session 中提供了很多方法，使用起来比 Cookie 方便。</li></ul><hr><h3 id="3-Session-和-Cookie-的联系"><a href="#3-Session-和-Cookie-的联系" class="headerlink" title="3. Session 和 Cookie 的联系"></a>3. Session 和 Cookie 的联系</h3><ul><li><strong>Session需要使用Cookie作为识别标志</strong>：HTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个<strong>名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id</strong>（也就是 <code>HttpSession.getId()</code> 的返回值）。Session依据该Cookie来识别是否为同一用户。</li><li><strong>URL 地址重写</strong>：当某些客户端不支持 Cookie，而想要使用 Session 来记录用户状态时，就需要使用 URL 地址重写。URL 地址重写的原理是，<strong>将该用户 Session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 Session 的 id</strong>。这样即使客户端不支持 Cookie，也可以使用 Session 来记录用户状态。 </li></ul><hr><h3 id="4-Session-和-Cookie-的区别"><a href="#4-Session-和-Cookie-的区别" class="headerlink" title="4. Session 和 Cookie 的区别"></a>4. Session 和 Cookie 的区别</h3><ol><li>Cookie 数据保存在客户端（浏览器端），Session 数据保存在服务器端。</li><li>Cookie 不是很安全，<strong>考虑到安全性应当使用 Session</strong>。但 Cookie 可以加密，使用时再到服务器端解密。</li><li>Session 会在一定时间内保存在服务器上。当访问增多时，会比较占用服务器的性能，<strong>考虑到减轻服务器性能方面，应当使用 Cookie</strong>。</li><li>单个 Cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 Cookie。<strong>Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型</strong>。</li></ol><hr><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul><li><strong>登录网站</strong>，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是 Cookie。</li><li>Session 一个应用场景是<strong>购物车</strong>，添加了商品之后，服务器端储存这些添加的商品就用到了 Session。下一次同一个用户登录时，就可以从 Session 读取到之前添加的商品。<strong>Cookie只是一个身份信息</strong>，且容量有限，无法储存购物车这种较多的数据。</li></ul><hr><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p>socket servlet 等</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2020/08/05/arraylist-yuan-ma-jie-xi/"/>
      <url>/2020/08/05/arraylist-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-源码解析"><a href="#ArrayList-源码解析" class="headerlink" title="ArrayList 源码解析"></a>ArrayList 源码解析</h1><h2 id="1-ArrayList-源码"><a href="#1-ArrayList-源码" class="headerlink" title="1. ArrayList 源码"></a>1. ArrayList 源码</h2><h3 id="1-ArrayList-简介"><a href="#1-ArrayList-简介" class="headerlink" title="1. ArrayList 简介"></a>1. ArrayList 简介</h3><p>ArrayList 继承了 AbstractList ，实现了 <strong>List、RandomAccess、Cloneable 和 java.io.serializable</strong> 接口。</p><ul><li>继承了 AbstractList ，实现了 List。表明它是一个数组，提供了相关的添加、删除、修改和遍历等功能。</li><li>实现了 <strong>RandomAccess 接口</strong>，实现这个接口表明集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，可以<strong>通过元素的序号快速获取元素</strong>，这就是快速随机访问。</li><li>实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</li><li>实现了 <strong>java.io.serializable</strong> 接口，这表示 ArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</li><li><strong>ArrayList 是线程不安全的</strong>。线程安全的数组容器有 <strong>Vector 和 CopyOnWriteArrayList</strong>。</li></ul><hr><h3 id="2-ArrayList-中构造部分源码"><a href="#2-ArrayList-中构造部分源码" class="headerlink" title="2. ArrayList 中构造部分源码"></a>2. ArrayList 中构造部分源码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 8683452581122892189L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 保存ArrayList数据的数组     */</span>    <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span>    <span class="token comment" spellcheck="true">/**     * ArrayList 所包含的元素个数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果传入的参数大于0，创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果传入的参数等于0，创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//其他情况，抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *默认无参构造函数     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>ArrayList 的<strong>内部数组是 Object 数组</strong>，基本类型也要用包装类型。</li><li>ArrayList 的<strong>初始容量设定为10</strong>；</li><li>ArrayList 的<strong>无参构造方法</strong>，会先创建一个空的数组，<strong>长度为 0</strong>，直到<strong>添加第一个元素时，数组长度扩充为 10</strong>。</li><li>ArrayList 的<strong>有参构造方法</strong>，指定数组长度。<strong>如果指定长度大于 0 ，创建长度为 10 的数组</strong>，如果指定长度等于 0 ，创建空数组，其他情况抛出异常。</li><li><strong>指定长度大于 10 时，数组初始长度仍然是 10</strong>，直到达到扩充条件，根据扩充机制进行扩充。</li></ul><hr><h3 id="3-ArrayList-中扩充部分源码"><a href="#3-ArrayList-中扩充部分源码" class="headerlink" title="3. ArrayList 中扩充部分源码"></a>3. ArrayList 中扩充部分源码</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>            <span class="token comment" spellcheck="true">// supposed to be at default size.</span>            <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果最小容量大于已有的最大容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 要分配的最大数组大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>        <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>        <span class="token comment" spellcheck="true">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>        <span class="token comment" spellcheck="true">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//比较minCapacity和 MAX_ARRAY_SIZE</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>            MAX_ARRAY_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>当数组需要扩容时，<strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></strong>，其中 oldCapacity 是原数组长度。因此，<strong>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右</strong>。奇偶不同，如果奇数得到小数，则舍弃小数得到整数。</li><li>新数组的最大容量是 <code>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</code> 。</li><li><strong>判断是否需要扩容还要再看文章理解</strong>。</li></ul><hr><h3 id="3-ArrayList-中方法部分源码"><a href="#3-ArrayList-中方法部分源码" class="headerlink" title="3. ArrayList 中方法部分源码"></a>3. ArrayList 中方法部分源码</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *返回此列表中的元素数。      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表不包含元素，则返回 true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//注意=和==的区别</span>        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表包含指定的元素，则返回true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//equals()方法比较</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）      */</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>            v<span class="token punctuation">.</span>elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            v<span class="token punctuation">.</span>modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这不应该发生，因为我们是可以克隆的</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。      *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 用指定的元素替换此列表中指定位置的元素。      */</span>    <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对index进行界限检查</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回原来在这个位置的元素</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将指定的元素追加到此列表的末尾。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。      */</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>      <span class="token comment" spellcheck="true">//从列表中删除的元素 </span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中删除所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把数组中所有的元素的值设为null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>ArrayList 中最常用的方法有 <code>add()</code>，<code>size()</code>，<code>remove()</code>，<code>get()</code>，<code>set()</code>，<code>isEmpty()</code>，<code>contains</code>。</li><li>其中 <code>add()</code> 方法可以有<strong>两个入参</strong>，第一个参数为插入数组的位置，第二个为插入的元素。这种插入方式，插入后后方元素要全部后移，操作方式是用 <code>System.arraycopy()</code> ，会产生新的数组，消耗较大。相比之下，<strong>LinkedList 中有相同的方法，效率更高</strong>。</li><li><strong><code>toArray()</code> 方法还要再看文章理解</strong>。</li></ul><hr><h2 id="2-ArrayList-面试问题总结"><a href="#2-ArrayList-面试问题总结" class="headerlink" title="2. ArrayList 面试问题总结"></a>2. ArrayList 面试问题总结</h2><h3 id="1-ArrayList的扩容机制"><a href="#1-ArrayList的扩容机制" class="headerlink" title="1. ArrayList的扩容机制"></a>1. ArrayList的扩容机制</h3><ol><li>ArrayList源码中有三个构造函数。其中<strong>无参构造，ArrayList的长度为0，直到添加第一个元素时进行扩容，大小为10</strong>。</li><li>当数组需要扩容时，<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</strong>，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</li><li>新数组的最大容量是Integer的最大值，<code>Integer.MAX_VALUE</code>。</li><li>扩容后 ArrayList 调用的是<code>Arrays.copyOf()</code>方法，默认返回一个新数组。</li><li>ArrayList 是允许空值（null）的。</li></ol><hr><h3 id="2-ArrayList-和-LinkedList-的对比"><a href="#2-ArrayList-和-LinkedList-的对比" class="headerlink" title="2. ArrayList 和 LinkedList 的对比"></a>2. ArrayList 和 LinkedList 的对比</h3><ol><li>线程安全：ArrayList 和 LinkedList 都是线程不同步的，不保证线程安全。</li><li>底层数据结构：ArrayList 的底层数据结构是 Object 数组；LinkedList 底层结构是双向链表。</li><li>插入和删除：ArrayList 插入和删除元素受元素位置的影响，时间复杂度较大；LinkedList 插入删除元素不受元素位置的影响，时间复杂度较小，但首先要移动到指定位置，这个过程时间复杂度较大。</li><li>快速随机访问（查找元素）：ArrayList 可以通过序号快速获取元素对象；LinkedList 不能，但也做了优化，先用二分法判断靠近哪一端，再从较近的一端开始查找。</li><li>内存空间占用：ArrayList 空间浪费体现在预留一定的容量空间；LinkedList 空间花费体现在，它的每一个元素都要多储存前驱和后继。</li></ol><hr><h3 id="3-ArrayList-和-Vector-的对比"><a href="#3-ArrayList-和-Vector-的对比" class="headerlink" title="3. ArrayList 和 Vector 的对比"></a>3. ArrayList 和 Vector 的对比</h3><ol><li>线程安全：Vector 是线程同步的，保证线程安全；ArrayList 是线程不同步的，不保证线程安全。</li><li>效率：Vector 在线程同步操作上会花费时间，因此访问比 ArrayList 慢。</li><li>扩容：Vector 扩容时增长率为100%；ArrayList 扩容时增长率为50%。</li></ol><ul><li><strong>总结</strong>：需要线程安全用 Vector，不需要线程安全用 ArrayList。</li></ul><hr><h3 id="4-ArrayList-和-CopyOnWriteArrayList-的对比"><a href="#4-ArrayList-和-CopyOnWriteArrayList-的对比" class="headerlink" title="4. ArrayList 和 CopyOnWriteArrayList 的对比"></a>4. ArrayList 和 CopyOnWriteArrayList 的对比</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2020/08/05/linkedlist-yuan-ma-jie-xi/"/>
      <url>/2020/08/05/linkedlist-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList-源码解析"><a href="#LinkedList-源码解析" class="headerlink" title="LinkedList 源码解析"></a>LinkedList 源码解析</h1><h2 id="1-定义及构造方法源码"><a href="#1-定义及构造方法源码" class="headerlink" title="1. 定义及构造方法源码"></a>1. 定义及构造方法源码</h2><h3 id="1-LinkedList-简介"><a href="#1-LinkedList-简介" class="headerlink" title="1. LinkedList 简介"></a>1. LinkedList 简介</h3><ul><li><p>LinkedList 实现了 <strong>List 接口</strong> 和 <strong>Deque 接口</strong>，是一个<strong>双端链表</strong>，同时也具有<strong>队列</strong>的性质。</p></li><li><p>LinkedList 实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</p></li><li><p>LinkedList 实现了 <strong>java.io.serializable</strong> 接口，这表示 ArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</p></li><li><p>LinkedList 的链表结构使其支持<strong>高效的插入和删除操作</strong>。需要注意的是：<strong>LinkedList 虽然是链表结构，但也有索引</strong>。</p></li><li><p>如果想要使 LinkedList 变成线程安全的，可以<strong>调用静态类 Collections 类中的 synchronizedList 方法</strong>：</p></li></ul><pre class=" language-java"><code class="language-java">List list <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h3><p>LinkedList 内部定义了三个变量：<strong>size、first 和 last</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Deque<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Pointer to first node.     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Pointer to last node.     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre><p>LinkedList 内部的链表节点有三个属性，分别是<strong>当前节点的值，前驱节点和后继节点</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后继节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前驱节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h3><p>LinkedList 的构造方法可以有参，也可以无参。</p><ol><li>无参构造方法</li></ol><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>有参构造方法（用已有的集合创建链表）</li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以看出，有参构造方法是调用了 <code>addAll()</code> 方法，后面会有介绍。</p><hr><h2 id="2-添加方法源码"><a href="#2-添加方法源码" class="headerlink" title="2. 添加方法源码"></a>2. 添加方法源码</h2><h3 id="1-linkLast-linkFirst-方法"><a href="#1-linkLast-linkFirst-方法" class="headerlink" title="1. linkLast / linkFirst 方法"></a>1. linkLast / linkFirst 方法</h3><ul><li>最核心的添加方法 <code>linkLast(E e)</code> ：</li></ul><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     * 链接使e作为最后一个元素。     * 其中last是链表中指向最后一个节点的指针     * 其中first是链表中指向第一个节点的指针     * l的作用是记录上一个节点     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向后继元素也就是指向下一个元素</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ol><li>先新建引用（l）<strong>记录上一个节点</strong>，也就是之前的最后一个节点（last）；</li><li><strong>新建节点</strong> newNode，前驱指向 l，后继为 null；</li><li><strong>令 last 指向新建节点</strong>，此时新建节点是链表的最后一个节点；</li><li>判断上一节点 l 是否为 null，是则说明新节点是第一个节点，first 也要指向新节点；不是则<strong>将上一节点的后继指向新节点</strong>。</li></ol><ul><li>从头部添加的方法<code>linkFirst(E e)</code> ：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**      * 操作方法步骤与上述linkLast方法相同      */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建节点，以头节点为后继节点</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果链表为空，last节点也指向该节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="2-add-方法"><a href="#2-add-方法" class="headerlink" title="2. add 方法"></a>2. add 方法</h3><ul><li><code>add(E e)</code> 方法：将元素添加到链表尾部。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里就只调用了这一个方法</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可见，<strong><code>add()</code> 就是调用了 <code>linkLast()</code> 方法</strong>，返回 true 则说明添加成功。</p><ul><li><code>add(int index, E e)</code> ：将元素添加到指定位置。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查索引是否处于[0-size]之间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加在链表尾部</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//添加在链表中间</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>linkBefore()</code> 方法又需其他条件。只需记住，<strong>LinkedList 的插入添加操作比 ArrayList 效率更高</strong>。</p><ul><li><code>addFirst(E e)</code> ：将元素添加到链表头部。</li></ul><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><code>addLast(E e)</code> ：将元素添加到链表尾部。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>向尾部添加元素一般使用 <code>add()</code> 方法</strong>。</p><hr><h3 id="3-addAll-方法"><a href="#3-addAll-方法" class="headerlink" title="3. addAll 方法"></a>3. addAll 方法</h3><ul><li><code>addAll(Collection c)</code> ：将<strong>集合</strong>添加到链表尾部。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">addAll</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>调用的是重载方法，也就是从链表的最后开始插入。</p><ul><li><code>addAll(int index, Collection c)</code> ：将<strong>集合</strong>添加到链表指定位置。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1:检查index范围是否在size之内</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2:toArray()方法把集合的数据存到对象数组中</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numNew <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3：得到插入位置的前驱节点和后继节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred<span class="token punctuation">,</span> succ<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果插入位置为尾部，前驱节点为last，后继节点为null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> null<span class="token punctuation">;</span>            pred <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，调用node()方法得到后继节点，再得到前驱节点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 4：遍历数据将数据插入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> E e <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> o<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//创建新节点</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果插入位置在链表头部</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>                first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            pred <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果插入位置在尾部，重置last节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，将插入的链表与先前链表连接起来</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span>            succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    </code></pre><ol><li>检查index范围是否在 size 之内；</li><li>调用 <code>toArray()</code> 方法把集合的数据存到对象数组中（Object 数组）；</li><li>调用 <code>node()</code> 方法得到插入位置的前驱和后继节点；</li><li>遍历数据，将数据插入到指定位置。</li></ol><hr><h2 id="3-根据索引获取对象的方法源码"><a href="#3-根据索引获取对象的方法源码" class="headerlink" title="3. 根据索引获取对象的方法源码"></a>3. 根据索引获取对象的方法源码</h2><h3 id="1-node-方法"><a href="#1-node-方法" class="headerlink" title="1. node 方法"></a>1. node 方法</h3><ul><li>最核心的根据索引获取数据的方法 <code>node(int index)</code> ：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 返回一个指定索引的非空节点.     */</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert isElementIndex(index);</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><code>node()</code> 方法的机制是：<strong>先判断指定位置是在链表的前半段还是后半段，然后从较近的一端开始遍历</strong>，直到找到指定元素。</p><hr><h3 id="2-get-方法"><a href="#2-get-方法" class="headerlink" title="2. get 方法"></a>2. get 方法</h3><ul><li><code>get(int index)</code> ：根据指定索引获取数据。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查index范围是否在size之内</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用Node(index)去找到index对应的node然后返回它的值</span>        <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可见，<code>get()</code> 方法是调用了 <code>node()</code> 方法实现的。</p><hr><h3 id="3-获取头节点的方法"><a href="#3-获取头节点的方法" class="headerlink" title="3. 获取头节点的方法"></a>3. 获取头节点的方法</h3><ul><li>获取<strong>头节点</strong>的方法：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//element()就是getFirst()实现的，二者没有区别</span>    <span class="token keyword">public</span> E <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//与peek()没有区别</span>    <span class="token keyword">public</span> E <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p><strong>使用和区别</strong>：常用方法为 <code>getFirst()</code> 和 <code>peek()/peekFirst()</code> 。二者的区别在于，<strong>当链表为空时</strong>（头节点为空则链表为空），<code>getFirst()</code> 方法会<strong>抛出异常</strong>，<code>peek()</code> 方法会<strong>返回 null</strong>。</p><hr><h3 id="4-获取尾节点的方法"><a href="#4-获取尾节点的方法" class="headerlink" title="4. 获取尾节点的方法"></a>4. 获取尾节点的方法</h3><ul><li>获取<strong>尾节点</strong>的方法：</li></ul><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> E <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> E <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>区别</strong>：<strong>当链表为空时</strong>（尾节点为空则链表为空），<code>getLast()</code> 方法会<strong>抛出异常</strong>，<code>peekLast()</code> 方法会<strong>返回 null</strong>。</p><hr><h2 id="4-根据对象获得索引的方法源码"><a href="#4-根据对象获得索引的方法源码" class="headerlink" title="4. 根据对象获得索引的方法源码"></a>4. 根据对象获得索引的方法源码</h2><h3 id="1-indexOf-方法"><a href="#1-indexOf-方法" class="headerlink" title="1. indexOf 方法"></a>1. indexOf 方法</h3><ul><li><code>int indexOf(Object o)</code> ：从头遍历寻找。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="2-lastIndexOf-方法"><a href="#2-lastIndexOf-方法" class="headerlink" title="2. lastIndexOf 方法"></a>2. lastIndexOf 方法</h3><ul><li><code>int lastIndexOf(Object o)</code> ：从尾遍历寻找。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从尾遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从尾遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="3-contains-方法"><a href="#3-contains-方法" class="headerlink" title="3. contains 方法"></a>3. contains 方法</h3><ul><li><code>contains(Object o)</code> ：检查对象 o 是否存在于链表中。</li></ul><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可见，<code>contains()</code> 方法就是调用了 <code>indexOf()</code> 方法，判断返回值是否合理。</p><hr><h2 id="5-删除方法源码"><a href="#5-删除方法源码" class="headerlink" title="5. 删除方法源码"></a>5. 删除方法源码</h2><h3 id="1-unlink-方法"><a href="#1-unlink-方法" class="headerlink" title="1. unlink 方法"></a>1. unlink 方法</h3><ul><li>最核心的删除方法 <code>unlink(Node x)</code> ：</li></ul><pre class=" language-java"><code class="language-java">    E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert x != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到后继节点</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到前驱节点</span>        <span class="token comment" spellcheck="true">//删除前驱指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将前驱节点的后继节点指向后继节点</span>            x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//删除后继指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>unlink()</code> 方法的作用就是断开指定节点的前驱和后继，是删除方法中的核心。</p><hr><h3 id="2-remove-方法"><a href="#2-remove-方法" class="headerlink" title="2. remove 方法"></a>2. remove 方法</h3><p><strong>remove方法共有三种重载形式</strong>，每种形式的作用都不相同。</p><ol><li><code>remove()</code> ：空参形式，删除头节点，后面介绍。</li><li><code>remove(Object o)</code> ：删除<strong>指定元素</strong>。</li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果删除对象为null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头开始遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//找到元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//从链表中移除找到的元素</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头开始遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//找到元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//从链表中移除找到的元素</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>需要<strong>先遍历链表找到此元素</strong>，再调用 <code>unlink()</code> 方法删除。遍历方式为<strong>从头遍历</strong>。</li><li>此方法一次只会删除一个匹配的对象，成功返回 true。</li></ul><ol start="3"><li><code>remove(int index)</code> ：删除<strong>指定位置的元素</strong>。</li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查index范围</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将节点删除</span>        <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>先调用 <code>node()</code> 方法找到该元素，再调用 <code>unlink()</code> 方法删除。</li></ul><hr><h3 id="3-删除头节点的方法"><a href="#3-删除头节点的方法" class="headerlink" title="3. 删除头节点的方法"></a>3. 删除头节点的方法</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>三者实为同一种方法，其他方法都是调用 <strong><code>removeFirst()</code></strong> ，当链表为空时，会抛出异常。使用时也尽量使用此方法。</li></ul><hr><h3 id="4-删除尾节点的方法"><a href="#4-删除尾节点的方法" class="headerlink" title="4. 删除尾节点的方法"></a>4. 删除尾节点的方法</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>区别：当链表为空时，<code>removeLast()</code> 方法会抛出异常，而 <code>pollLast()</code> 方法会返回 null。</li></ul><hr><h2 id="6-LinkedList-面试问题总结"><a href="#6-LinkedList-面试问题总结" class="headerlink" title="6. LinkedList 面试问题总结"></a>6. LinkedList 面试问题总结</h2><h3 id="1-ArrayList-和-LinkedList-的对比"><a href="#1-ArrayList-和-LinkedList-的对比" class="headerlink" title="1. ArrayList 和 LinkedList 的对比"></a>1. ArrayList 和 LinkedList 的对比</h3><ol><li>线程安全：ArrayList 和 LinkedList 都是线程不同步的，不保证线程安全。</li><li>底层数据结构：ArrayList 的底层数据结构是 Object 数组；LinkedList 底层结构是双向链表。</li><li>插入和删除：ArrayList 插入和删除元素受元素位置的影响，时间复杂度较大；LinkedList 插入删除元素不受元素位置的影响，时间复杂度较小，但首先要移动到指定位置，这个过程时间复杂度较大。</li><li>快速随机访问（查找元素）：ArrayList 可以通过序号快速获取元素对象；LinkedList 不能，但也做了优化，先用二分法判断靠近哪一端，再从较近的一端开始查找。</li><li>内存空间占用：ArrayList 空间浪费体现在预留一定的容量空间；LinkedList 空间花费体现在，它的每一个元素都要多储存前驱和后继。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2020/08/05/hashmap-yuan-ma-jie-xi/"/>
      <url>/2020/08/05/hashmap-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h1><h2 id="1-JDK-1-8-前后的区别"><a href="#1-JDK-1-8-前后的区别" class="headerlink" title="1. JDK 1.8 前后的区别"></a>1. JDK 1.8 前后的区别</h2><h3 id="1-HashMap-简介"><a href="#1-HashMap-简介" class="headerlink" title="1. HashMap 简介"></a>1. HashMap 简介</h3><p>HashMap 继承了 AbstractMap ，实现了 Map、cloneable 和java.io.serializable 接口。</p><ul><li>继承了 AbstractMap ，实现了 Map，表明它是一个 Map ，作用是用来存放<strong>键值对</strong>。</li><li>实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</li><li>实现了 <strong>java.io.serializable</strong> 接口，这表示 ArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</li><li><strong>HashMap 是线程不安全的</strong>。线程安全的 Map 容器为 <strong>ConcurrentHashMap</strong>，也可以通过  <code>Collections.synchronizedMap()</code> 方法来包装 HashMap。</li></ul><hr><h3 id="2-JDK-1-8-前后-hash-方法的区别（哈希冲突）"><a href="#2-JDK-1-8-前后-hash-方法的区别（哈希冲突）" class="headerlink" title="2. JDK 1.8 前后 hash 方法的区别（哈希冲突）"></a>2. JDK 1.8 前后 hash 方法的区别（哈希冲突）</h3><ul><li>JDK 1.8 之前，HashMap 底层是<strong>数组和链表</strong>结合的结构。HashMap 通过 <code>hash()</code> 方法处理后得到 <strong>hash 值</strong>，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里 n 是数组的长度）。</li><li>如果当前位置存在元素，则<strong>判断两个元素的 hash 值和 key 是否相同</strong>。如果相同，直接覆盖已有元素；如果不相同，则加入链表（拉链法）。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>这里 <code>hash()</code> 方法接收的参数 h，是 key 通过 <code>hashCode()</code> 方法得到的 hashcode</strong>。</p><ul><li>JDK 1.8 之后，HashMap 底层是<strong>数组和链表/红黑树</strong>结合的结构，当链表的长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>    <span class="token comment" spellcheck="true">// ^ ：按位异或</span>    <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里 <code>hash()</code> 方法接收的参数就是 key，计算 hashcode 在方法内部，计算方法也更加简化，但原理不变。</p><ul><li>其实 JDK 1.8 前后解决<strong>哈希冲突</strong>的方法类似，都是<strong>数组 + 链表</strong>的形式，只是 JDK 1.8 后增加了链表变红黑树的操作。</li></ul><hr><h3 id="3-JDK-1-8-之后-HashMap-类的属性"><a href="#3-JDK-1-8-之后-HashMap-类的属性" class="headerlink" title="3. JDK 1.8 之后 HashMap 类的属性"></a>3. JDK 1.8 之后 HashMap 类的属性</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量2^30</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>loadFactor</strong>（负载因子）：loadFactor加载因子是控制数组存放数据的疏密程度。<strong>影响着数组的利用率和查找元素的效率</strong>。</li><li><strong>threshold</strong>（扩充阈值）：<code>threshold = capacity * loadFactor</code> 。<strong>当 size 达到 threshold 时，哈希表就会进行扩容</strong>。</li><li>HashMap 的默认容量是 16，默认负载因子是 0.75，因此 threshold 默认是 12。也就是说，当 size 达到 12 时，HashMap 就会扩容。可以看出，<strong>HashMap 中的实际元素数量总会小于数组的长度，这是为了使元素分布稀疏，减少哈希冲突，使查找效率高</strong>。0.75f 是官方给出的比较折中的临界值。</li></ul><hr><h3 id="4-Node-节点类"><a href="#4-Node-节点类" class="headerlink" title="4. Node 节点类"></a>4. Node 节点类</h3><ul><li>Node 节点类继承自 Map.Entry&lt;K, V&gt;，key 和 value 共同存储在一个 Node 节点类中。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li>key 由 final 修饰，不可改变，value 没有 final 修饰，可以修改。</li><li>Node 中是有 next 节点的，因为有链表结构。</li><li><strong>重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</strong>。解决哈希冲突时必要的方法。定义为 key 的 hashcode 与 value 的 hashcode 的异或，<code>Objects.hashCode(key) ^ Objects.hashCode(value);</code>。</li></ul><hr><h2 id="2-HashMap-源码"><a href="#2-HashMap-源码" class="headerlink" title="2. HashMap 源码"></a>2. HashMap 源码</h2><h3 id="1-构造方法源码"><a href="#1-构造方法源码" class="headerlink" title="1. 构造方法源码"></a>1. 构造方法源码</h3><ul><li>HashMap 共有四个构造方法：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 默认构造方法，所有参数使用默认值</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 只指定“容量大小”的构造函数，其中又调用了两个参数的构造函数。</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 指定“容量大小”和“负载因子”的构造函数，容量若不是2的倍数，会在之后优化成2的倍数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//如果指定容量小于0，抛出异常</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果指定容量大于最大容量，则使用最大容量</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果指定负载因子不满足条件，抛出异常。注意：这里等于0也不可以。</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//这里的tableSizeFor()方法，是把不为2的整数幂的初始长度，优化为2的整数幂</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span></code></pre><hr><h3 id="2-put-方法源码"><a href="#2-put-方法源码" class="headerlink" title="2. put 方法源码"></a>2. put 方法源码</h3><p>HashMap 中添加元素的核心方法是 <code>putVal()</code> 方法，但不提供给用户使用，由 <code>put()</code> 方法调用，再开放 <code>put()</code> 方法给用户使用。</p><ul><li><strong><code>putVal()</code> 方法的添加流程</strong>：<ol><li>使用 <code>(n - 1) &amp; hash</code> 定位，其中 n 为数组长度。如果定位到的数组位置没有元素，直接加入；</li><li>如果定位到的数组位置已有元素，则<strong>比较 hash 值和 key</strong>，如果相同就覆盖，如果不同则要继续判断；</li><li>hash 值或 key 不同时，判断当前位置是否是一个树节点，如果是则调用添加树节点的方法，把元素加入红黑树。如果不是则遍历链表，加入链表尾部。<strong>在遍历链表的同时，也会比较每一个点的 hash 值和 key，如果有相等，就用新值覆盖</strong>。</li></ol></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；判断是否为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 以上都不是，则为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点，用新值覆盖</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><hr><h3 id="3-get-方法源码"><a href="#3-get-方法源码" class="headerlink" title="3. get 方法源码"></a>3. get 方法源码</h3><p>HashMap 中获取元素的核心方法是 <code>getNode()</code> 方法，但不提供给用户使用，由 <code>get()</code> 方法调用，再开放<code>get()</code> 方法给用户使用。</p><ul><li><strong><code>getNode()</code> 方法的获取流程</strong>：<ol><li>使用 <code>(n - 1) &amp; hash</code> 定位，其中 n 为数组长度。如果定位到的数组位置没有元素，直接返回 null；</li><li>如果当前位置有元素，判断当前位置元素和要找的元素是否相同，比较 hash 值和 key。如果相等则直接放回当前元素。</li><li>如果不相等则判断后续是否有节点，没有节点返回 null，有节点则判断是否是树。</li><li>如果是树，在树中 get 元素，如果不是树，那一定是链表，遍历链表比较 hash 值和 key，有则返回元素，无则返回 null。</li></ol></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="4-resize-方法源码"><a href="#4-resize-方法源码" class="headerlink" title="4. resize 方法源码"></a>4. resize 方法源码</h3><ul><li><strong>HashMap 每次扩容后，都会伴随着一次重新 hash 分配</strong>，这会遍历 HashMap 中的所有元素，是非常耗时的。因此，在使用 HashMap 时，要尽量避免 resize，也就是<strong>初始长度尽量设置为合适的长度</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>简单来说就是，<strong>HashMap 每次扩容，都是把数组长度扩大为原数组长度的两倍</strong>，<code>newCap = oldCap &lt;&lt; 1</code> 。</li><li><strong>其中 oldCap 取的是存放键值对的数组的长度，与数组实际长度 size 无关</strong>。由前文可知，<strong>size 总是小于数组长度</strong>的。</li></ul><hr><h2 id="3-HashMap-面试问题总结"><a href="#3-HashMap-面试问题总结" class="headerlink" title="3. HashMap 面试问题总结"></a>3. HashMap 面试问题总结</h2><h3 id="1-HashMap-的容量为什么一定是-2-的整数幂"><a href="#1-HashMap-的容量为什么一定是-2-的整数幂" class="headerlink" title="1. HashMap 的容量为什么一定是 2 的整数幂"></a>1. HashMap 的容量为什么一定是 2 的整数幂</h3><ol><li>当元素要添加进 HashMap 时，会先通过 <code>hash()</code> 方法计算出元素的 hash 值，再通过 hash 值计算元素应该放在数组中的位置。</li><li>但 hash 值的范围很大，很多情况下 hash 值是大于数组的长度的，因此使用 % 取余操作得到余数，作为元素存放在数组中的位置。</li><li>而<strong>取余（%）操作中，如果除数是 2 的整数幂，等价于与其除数减一的与（&amp;）操作</strong>，即 <code>hash % length == hash &amp; (length-1)</code> 。采用二进制操作相比取余操作效率更高。</li><li>因此 <code>put()</code> 方法中的计算方法是 <code>(n - 1) &amp; hash</code> ，是取余操作的二进制写法。</li></ol><hr><h3 id="2-HashMap-的容量为什么一定是-2-的整数幂（本末倒置版）"><a href="#2-HashMap-的容量为什么一定是-2-的整数幂（本末倒置版）" class="headerlink" title="2. HashMap 的容量为什么一定是 2 的整数幂（本末倒置版）"></a>2. HashMap 的容量为什么一定是 2 的整数幂（本末倒置版）</h3><ol><li>取 HashMap 的容量为 15 和 16，元素 hash 值为 8 和 9。</li><li>15 的二进制为 1111，16 的二进制为 10000。因此 <code>(n - 1)</code> 的二进制分别为 14—1110 和 15—1111。而 hash 值的二进制为 8—1000 和 9—1001。</li><li>当容量为 15 时，hash 值为 8 和 9，根据 <code>(n - 1) &amp; hash</code> 计算出的值相等；而容量为 16 时，计算出的值不等。</li><li>原因是 15 - 1 = 14 的<strong>二进制 1110 最后一位是 0</strong>，而 8 和 9 的二进制表示只差在最后一位，不管此位是 0 还是 1，和 1110 与（&amp;）之后都是 0。这就<strong>导致了最后位是 1 的位置不可能被放置元素</strong>，如第一位 0001、第三位 0011 和第七位 0111 等等，增加了哈希碰撞的概率，降低了查找效率。</li><li>而当容量为 2 的整数幂时，<strong><code>n-1</code> 的低位一定都是 1</strong>。如 16 - 1 = 15（1111）、8 - 1 = 7（0111）和 4 - 1 = 3（0011）等等。哈希碰撞的概率更低。</li></ol><ul><li><strong>这样分析看起来挺有道理，但是 HashMap 中使用 <code>(n - 1) &amp; hash</code> 计算位置是有前提的，就是容量为 2 的整数幂，否则应该使用取余运算 <code>hash % n</code>。而这种推论把前提和结果反过来分析，对于不是 2 的整数幂的数，<code>(n - 1) &amp; hash</code> 不等价于取余运算，也就没有意义了。</strong></li></ul><hr><h3 id="3-HashMap和HashTable的区别"><a href="#3-HashMap和HashTable的区别" class="headerlink" title="3. HashMap和HashTable的区别"></a>3. HashMap和HashTable的区别</h3><ol><li>线程安全：HashMap是非线程安全的；HashTable是线程安全的。如果需要线程安全建议使用ConcurrentHashMap。</li><li>效率：HashTable在线程安全上会花费时间，因此HashMap效率更高。</li><li>对Null key 和Null value的支持：HashMap中，null可以作为键，键是唯一的，但可以有多个键对应的值是null；HashTable中，null既不可以作为键，也不可以作为值，否则抛出NullPointerException。</li><li>容量：<ol><li>创建时不指定容量值：HashMap默认初始化大小为16，每次扩充变为原来的2倍；HashTable默认初始化大小为11，每次扩充变为原来的2n + 1；</li><li>创建时指定容量值：HashMap会将其扩充为2的幂次方大小；HashTable直接使用给定的大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</li></ol></li><li>底层数据结构：HashMap在JDK1.8以后，当<strong>链表</strong>长度大于阈值（默认为8）而<strong>数组</strong>长度小于 64时，那么会选择先进行数组扩容，当<strong>数组</strong>长度大于64时，将链表转化为红黑树，以减少搜索时间；HashTable没有这样的机制。</li></ol><hr><h3 id="4-HashMap和HashSet的区别"><a href="#4-HashMap和HashSet的区别" class="headerlink" title="4. HashMap和HashSet的区别"></a>4. HashMap和HashSet的区别</h3><ul><li>HashSet底层是基于HashMap实现的，只有<code>clone()</code>，<code>writeObject()</code>，<code>readObject()</code>是HashSet自己实现的，其他方法都是调用HashMap中的方法。</li></ul><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现了Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向map中添加元素</td><td align="center">调用 <code>set()</code>方法向set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以要用<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-并发</title>
      <link href="/2020/08/05/02-bing-fa/"/>
      <url>/2020/08/05/02-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><p>进程：进程是资源分配的基本单位，是系统运行程序的基本单位。开启一个程序如QQ，就是开启了一个进程。</p><p>线程：线程是比进程更小的执行单位，是CPU调度的最小单位。一个进程中可以有多个线程，它们可以共享进程资源。同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><ul><li>通俗的理解为：进程是一个工厂，线程是其中的流水线。</li></ul><p><strong>区别</strong>：</p><ol><li>进程是资源分配的基本单位，一个进程在运行过程中可能产生多个线程；</li><li>进程是资源分配的基本单位，但线程不拥有资源，线程可以访问隶属的进程的资源；</li><li>进程之间是相互独立的，但同一个进程中的线程之间可能相互影响；</li><li>执行进程的开销大于执行线程的开销，但利于资源的管理和保护，因为在执行进程时，系统需要分配或回收资源。</li></ol><hr><h3 id="2-进程的状态"><a href="#2-进程的状态" class="headerlink" title="2. 进程的状态"></a>2. 进程的状态</h3><ol><li>创建状态(new)：进程正在被创建，还没有达到就绪的状态；</li><li>就绪状态(ready)：进程已处理准备运行状态，即进程已获得除处理器之外的一切所需资源，一旦获得处理器资源，即可运行；</li><li>运行状态(running)：进程正在处理器上运行（单核CPU任意时刻只有一个进程处于运行状态）；</li><li>阻塞状态(waiting)：进程等待某一事件而暂停运行的状态，即使处理器空闲，该进程也不能运行；</li><li>结束状态(terminated)：进程正在结束，从系统中消失。可能是进程正常结束，也可能是其他原因中断退出运行。</li></ol><hr><h3 id="3-线程的生命周期和状态"><a href="#3-线程的生命周期和状态" class="headerlink" title="3. 线程的生命周期和状态"></a>3. 线程的生命周期和状态</h3><ol><li>初始状态(new)：线程被创建，但还没有调用 <code>start()</code> 方法。</li><li>运行状态(runnable)：Java 线程将操作系统中的就绪和运行两种状态统称 “运行中” 状态。当线程调用 <code>start()</code> 方法后开始运行，这时处于 ready 状态。可运行状态的线程得到了 CPU 的时间片 (timeslice) 后就处于 running 状态。注：时间片就分配给线程的时间。</li><li>阻塞状态(blocked)：<strong>没有得到 CPU 的执行资格，但当 CPU 空闲时可以抢夺 CPU 资源</strong>。表示线程阻塞于<strong>锁</strong>。当线程调用同步方法时，在没有获取到锁的情况下，线程会进入 blocked 状态。</li><li>等待状态(waiting)：进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断），<strong>当 CPU 空闲时也不可以抢夺 CPU 资源</strong>。当线程执行 <code>wait()</code> 方法后，线程进入 waiting 状态。</li><li>超时等待状态(time_waiting)：不同于 waiting 状态，<strong>可以在指定时间自行返回，可以抢夺 CPU 资源</strong>。<code>wait(long millis)</code> 方法和 <code>sleep()</code> 方法可以将线程置于 time_waiting 状态。</li><li>终止状态(terminated)：表示当前线程已经执行完毕。线程在执行 runnable 的 <code>run()</code> 方法之后，将会进入 terminated 状态。</li></ol><hr><h3 id="4-进程间通信的方式"><a href="#4-进程间通信的方式" class="headerlink" title="4. 进程间通信的方式"></a>4. 进程间通信的方式</h3><ol><li>管道/匿名管道(pipes)</li><li>命名管道(name pipes)</li><li>信号(signal)</li><li>消息队列(message queuing)</li><li>信号量(semaphores)</li><li>共享内存(shared memory)</li><li>套接字(sockets)</li></ol><hr><h3 id="5-线程间的同步方式"><a href="#5-线程间的同步方式" class="headerlink" title="5. 线程间的同步方式"></a>5. 线程间的同步方式</h3><ol><li><p>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。 </p></li><li><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</p></li><li><p>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量； </p></li><li><p>事件：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>对比：</p><ul><li>临界区不是内核对象，互斥量、信号量和事件都是内核对象；</li><li>临界区只能用于进程内部的线程同步；</li><li>互斥量、信号量和事件可以用于不同进程间的线程同步；</li><li>临界区和互斥量都有“线程所有权”的概念，所以它们不能用来实现线程间的同步，只能实现线程间的互斥；</li><li>信号量和事件既可以实现线程间的同步，也可以实现线程间的互斥。</li></ul></li></ol><hr><h3 id="6-死锁产生的四个必要条件"><a href="#6-死锁产生的四个必要条件" class="headerlink" title="6. 死锁产生的四个必要条件"></a>6. 死锁产生的四个必要条件</h3><ul><li><strong>死锁</strong>： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 </li></ul><p>产生条件：</p><ol><li>互斥条件：进程对所分配到的资源进行排他性使用。一段时间内某个资源只能由一个进程使用，其他进程申请使用该资源只能等待，知道拥有者释放资源；</li><li>请求和保持条件：进程已经保持至少一个资源，又提出新的资源请求，该资源被其他进程占用，此请求进程进入阻塞状态，但不释放已保持的资源；</li><li>不剥夺条件：进程已获得的资源，在使用完成前，不能被剥夺，只能使用完成后由自己释放；</li><li>循环等待条件：进入死锁时，必然存在一个进程-资源环形链。</li></ol><hr><h3 id="7-如何避免死锁"><a href="#7-如何避免死锁" class="headerlink" title="7. 如何避免死锁"></a>7. 如何避免死锁</h3><ol><li>破坏互斥条件：做不到，因为用锁就是希望它们互斥；</li><li>破坏请求和保持条件：一次性申请所有资源；</li><li>破坏不剥夺条件：占用部分资源的线程在申请其他资源时，如果申请不到，可以主动释放已有资源；</li><li>破坏循环等待条件：按某一顺序申请资源，反序释放资源。</li></ol><hr><h3 id="8-上下文切换"><a href="#8-上下文切换" class="headerlink" title="8. 上下文切换"></a>8. 上下文切换</h3><ul><li>CPU 给线程分配时间片，执行完时间片后会切换线程；</li><li>切换前会保存当前线程的状态，下次时间片再给到这个线程时可以记得之前的状态；</li><li>从保存线程 A 的状态再切换到线程 B 时，重新加载线程 B 的这个过程叫做上下文切换。</li><li>上下文切换会消耗 CPU 大量时间。</li></ul><p><strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><hr><h3 id="9-sleep-方法和-wait-方法的对比"><a href="#9-sleep-方法和-wait-方法的对比" class="headerlink" title="9. sleep() 方法和 wait() 方法的对比"></a>9. sleep() 方法和 wait() 方法的对比</h3><ol><li><strong>最主要区别</strong>：<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁；</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code> 通常被用于暂停执行；</li><li><code>wait()</code> 方法被调用后，<strong>线程不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。<code>notify()</code> 方法唤醒的是等待时间最长的线程。<code>sleep()</code> 方法执行完成后，<strong>线程会自动苏醒</strong>。或使用<code>wait(long timeout)</code> 方法超时后，线程会自动苏醒。</li><li>两者都可以暂停线程的执行。</li></ol><hr><h3 id="10-start-方法和-run-方法"><a href="#10-start-方法和-run-方法" class="headerlink" title="10. start() 方法和 run() 方法"></a>10. start() 方法和 run() 方法</h3><p>new 一个 Thread，线程进入了新建状态; 调用 <code>start()</code> 方法，会启动一个线程并使线程进入就绪状态，<code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容。</p><p>而直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，而 <code>run()</code> 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong> </p><hr><h3 id="11-实现多线程-Thread-类和-Runnable-接口的对比"><a href="#11-实现多线程-Thread-类和-Runnable-接口的对比" class="headerlink" title="11. 实现多线程 Thread 类和 Runnable 接口的对比"></a>11. 实现多线程 Thread 类和 Runnable 接口的对比</h3><ul><li>继承 Thread 类和实现 Runnable 接口都可以实现多线程，相对来说更加推荐实现 Runnable 接口的方式。</li></ul><hr><h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h2><h3 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h3><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。 </p><ul><li>synchronized 关键字主要有三种使用方式：<ol><li><strong>修饰实例方法</strong>：作用于当前<strong>对象实例</strong>加锁，锁对象就是当前对象实例，就是 <code>this</code>。</li><li><strong>修饰静态方法</strong>：作用于<strong>当前类</strong>加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是<strong>类成员</strong>。这时的锁对象就是当前类的 class 属性，也就是 <strong>class 文件对象（反射）</strong>。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。 </li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。比如创建一个 object 对象，作为锁对象。</li></ol></li></ul><hr><h3 id="2-双重校验锁实现对象单例（还不是很懂）"><a href="#2-双重校验锁实现对象单例（还不是很懂）" class="headerlink" title="2. 双重校验锁实现对象单例（还不是很懂）"></a>2. 双重校验锁实现对象单例（还不是很懂）</h3><p><strong>单例模式</strong>：这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a>。</p><p><strong>注意</strong>：</p><ul><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//uniqueInstance采用volatile 关键字修饰也是很有必要</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行： </p><ol><li>为 uniqueInstance 分配内存空间；</li><li>初始化 uniqueInstance；</li><li>将 uniqueInstance 指向分配的内存地址。</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><ul><li><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。 </li></ul><hr><h3 id="3-synchronized-关键字的底层原理"><a href="#3-synchronized-关键字的底层原理" class="headerlink" title="3. synchronized 关键字的底层原理"></a>3. synchronized 关键字的底层原理</h3><ul><li><strong>synchronized 关键字的底层原理属于 JVM 层面</strong>。</li><li>JDK 1.6 对锁的实现引入了大量的优化，<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md" target="_blank" rel="noopener">详细信息参考</a></li></ul><hr><h3 id="4-synchronized-和-ReentrantLock-的对比"><a href="#4-synchronized-和-ReentrantLock-的对比" class="headerlink" title="4. synchronized 和 ReentrantLock 的对比"></a>4. synchronized 和 ReentrantLock 的对比</h3><ol><li>两者都是<strong>可重入锁</strong>：“可重入锁”概念是：<strong>自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的<strong>计数器</strong>都自增1，所以要等到锁的计数器下降为0时才能释放锁。 </li><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong>：synchronized 是依赖于 JVM 实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li><li><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong>：<ul><li><strong>等待可中断</strong>：ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<strong>正在等待锁的线程可以选择放弃等待，改为处理其他事情</strong>。 </li><li><strong>可实现公平锁</strong>：<strong>ReentrantLock 可以指定是公平锁还是非公平锁，而 synchronized 只能是非公平锁</strong>。<strong>所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。 </li><li><strong>可实现选择性通知</strong>：synchronized 关键字与 <code>wait()</code> 和 <code>notify()</code>/<code>notifyAll()</code> 方法相结合可以实现等待/通知机制。ReentrantLock 类借助于 Condition 接口与 <code>newCondition()</code> 方法也可以实现。Condition 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用 <code>notify()</code>/<code>notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。 </li></ul></li></ol><hr><h3 id="5-volatile-关键字"><a href="#5-volatile-关键字" class="headerlink" title="5. volatile 关键字"></a>5. volatile 关键字</h3><ul><li>Java 的内存模型：当前 Java 内存模型下，线程可以把变量读取到<strong>本地内存</strong>（如机器寄存器）中，而不是在主存中进行读写。因此可能导致一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</li><li><strong>计算机的主存，寄存器等硬件知识还需要补充</strong>。</li><li>要解决数据不一致的问题，就需要把变量声明为 <strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 </li><li><strong>volatile</strong> 关键字的主要作用就是<strong>保证变量的可见性</strong>，和防止<strong>指令重排序</strong>。 </li></ul><hr><h3 id="6-并发编程的三个重要特性"><a href="#6-并发编程的三个重要特性" class="headerlink" title="6. 并发编程的三个重要特性"></a>6. 并发编程的三个重要特性</h3><ol><li><strong>原子性</strong>：表示一个操作或多次操作，是<strong>不可中断的</strong>，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。<code>synchronized</code> 可以保证代码片段的原子性。 </li><li><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。 </li><li><strong>有序性</strong>：并发时，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><hr><h3 id="7-synchronized-关键字和-volatile-关键字的关系"><a href="#7-synchronized-关键字和-volatile-关键字的关系" class="headerlink" title="7. synchronized 关键字和 volatile 关键字的关系"></a>7. synchronized 关键字和 volatile 关键字的关系</h3><ul><li><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在。</li></ul><ol><li><strong>volatile 关键字</strong>是线程同步的 <strong>轻量级实现</strong>，所以 <strong>volatile 性能肯定比 synchronized 关键字要好</strong>。但是 <strong>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</li><li><strong>多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞</strong>。</li><li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong> </li><li><strong>volatile</strong> 关键字主要用于解决<strong>变量</strong>在多个线程之间的<strong>可见性</strong>，而 <strong>synchronized</strong> 关键字解决的是多个线程之间访问资源的<strong>同步性</strong>。</li></ol><hr><h2 id="3-ThreadLocal-和-线程池"><a href="#3-ThreadLocal-和-线程池" class="headerlink" title="3. ThreadLocal 和 线程池"></a>3. ThreadLocal 和 线程池</h2><h3 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong>JDK 中提供的 <code>ThreadLocal</code> 类正是为了解决这样的问题。 </p><p><code>ThreadLocal</code> 类主要解决的就是让<strong>每个线程绑定自己的值</strong>。如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的<strong>本地副本</strong>。<strong>他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值</strong>，从而避免了线程安全问题。</p><hr><h3 id="2-ThreadLocal-原理"><a href="#2-ThreadLocal-原理" class="headerlink" title="2. ThreadLocal 原理"></a>2. ThreadLocal 原理</h3><ul><li><p><code>Thread</code> 类源码中有两个 <code>ThreadLocalMap</code> 类型的变量，我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code> 或 <code>get</code> 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code> 方法。 </p></li><li><p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。 </p></li><li><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value的键值对。</strong></p></li><li><p><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类</strong>。 </p></li></ul><hr><h3 id="3-ThreadLocal-内存泄漏问题"><a href="#3-ThreadLocal-内存泄漏问题" class="headerlink" title="3. ThreadLocal 内存泄漏问题"></a>3. ThreadLocal 内存泄漏问题</h3><ul><li><p>观察源码可以发现，<code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。 </p></li><li><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法。</p></li></ul><hr><h3 id="4-使用线程池的好处"><a href="#4-使用线程池的好处" class="headerlink" title="4. 使用线程池的好处"></a>4. 使用线程池的好处</h3><ol><li><strong>降低资源消耗</strong>：重复利用已创建的线程来降低创建和销毁线程造成的消耗。</li><li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要的等到线程创建，只需要从线程池中取出空闲的线程，就能立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的<strong>分配，调优和监控</strong>。</li></ol><hr><h3 id="5-线程池的使用"><a href="#5-线程池的使用" class="headerlink" title="5. 线程池的使用"></a>5. 线程池的使用</h3><ol><li><strong>Executor</strong> 是一个顶层接口，在它里面只声明了一个方法 <code>execute(Runnable)</code>，返回值为void，参数为 Runnable 类型，从字面意思可以理解，就是用来执行传进去的任务的； </li><li><strong>ExecutorService</strong> 接口继承了 Executor 接口，并声明了一些方法：<code>submit()</code>、<code>invokeAll()</code> 以及 <code>shutdown()</code> 等；</li><li>抽象类 <strong>AbstractExecutorService</strong> 实现了 ExecutorService 接口，基本实现了ExecutorService 中声明的所有方法；</li><li><strong>ThreadPoolExecutor</strong> 继承了类 AbstractExecutorService。</li></ol><ul><li><p>在 <strong>ThreadPoolExecutor</strong> 类中有几个重要的方法：<code>execute(Runnable)</code>、<code>submit()</code> 和 <code>shutdown()</code>等。</p></li><li><p>《阿里巴巴Java开发手册》中强制线程池<strong>不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式</strong>。</p></li></ul><hr><h3 id="6-线程池的种类"><a href="#6-线程池的种类" class="headerlink" title="6. 线程池的种类"></a>6. 线程池的种类</h3><ul><li><strong>Executors</strong> 是 java.util.concurrent 包下的一个类，提供了若干个静态方法，用于生成不同类型的线程池。Executors一共可以创建下面这四类线程池： </li></ul><ol><li><strong>FixedThreadPool</strong> ： 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 该方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong>ScheduledThreadPool：</strong> 该方法返回一个<strong>可定期或者延时执行任务的定长线程池</strong>，支持定时及周期性任务执行。</li></ol><ul><li>ExecutorService 接口有两个实现类，分别是 AbstractExecutorService 和 <strong>ScheduledExecutorService</strong>，通过这个实现类也可以创建 ScheduledThreadPool。</li></ul><hr><h3 id="7-实现-Runnable-接口和-Callable-接口的区别"><a href="#7-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="7. 实现 Runnable 接口和 Callable 接口的区别"></a>7. 实现 Runnable 接口和 Callable 接口的区别</h3><p><code>Runnable</code> 自 Java 1.0以来一直存在，但 <code>Callable</code> 在 Java 1.5中引入，目的就是为了来处理 <code>Runnable</code> 不支持的用例。</p><p><strong><code>Runnable</code> 接口</strong>不会<strong>返回结果</strong>或<strong>抛出异常</strong>，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。 </p><ul><li><code>Runnable</code> 接口，只声明了一个 <code>run()</code> 方法，且<strong>无返回值</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * 被线程执行，没有返回值也无法抛出异常    */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><code>Callable</code> 接口，泛型接口，只声明了一个 <code>call()</code> 方法，<strong>返回值类型是传递进来的 V 类型，且会抛出异常</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 计算结果，或在无法这样做时抛出异常。     * @return 计算得出的结果     * @throws 如果无法计算结果，则抛出异常     */</span>    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。 </li></ul><hr><h3 id="8-execute-方法和-submit-方法的区别"><a href="#8-execute-方法和-submit-方法的区别" class="headerlink" title="8. execute() 方法和 submit() 方法的区别"></a>8. execute() 方法和 submit() 方法的区别</h3><ol><li><strong>返回值</strong>：<code>execute()</code>方法用于提交<strong>不需要返回值</strong>的任务，所以无法判断任务是否被线程池执行成功与否；<code>submit()</code> 方法用于提交<strong>需要返回值</strong>的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值。</li><li><strong>可接受的任务类型</strong>：<code>execute()</code>方法<strong>只能接受 Runnable 类型的任务</strong>；<code>submit()</code> 方法既可以接受 Runnable 类型的任务，<strong>也可以接受 Callable 类型的任务</strong>。</li><li><strong>异常处理</strong>：<code>execute()</code> 接受的是 Runnable 接口的任务，所以只能使用 try、catch 来捕获CheckedException，通过实现 UncaughtExceptionHandle 接口处理 UncheckedException，即和普通线程的处理方式完全一致；<code>submit()</code> 方法不管接受的是什么任务，都要通过返回值 <code>Future</code> 的 <code>get()</code> 方法来处理异常，否则都会吞掉异常。<code>submit()</code> 中的 <code>call()</code> 方法可以抛出异常，所以不管是 CheckedException 还是 UncheckedException，直接抛出即可。总结：<strong><code>submit()</code> 方法处理异常更方便</strong>。</li></ol><hr><h3 id="9-ThreadPoolExecutor-类分析"><a href="#9-ThreadPoolExecutor-类分析" class="headerlink" title="9.  ThreadPoolExecutor 类分析"></a>9.  ThreadPoolExecutor 类分析</h3><ol><li><p>重要参数（7大参数）分析</p><ol><li><strong>corePoolSize</strong>：核心线程数。定义了<strong>最小可以同时运行的线程数量</strong>。</li><li><strong>maximumPoolSize</strong>：最大线程数。当队列中存放的任务达到队列容量时，当前可以运行的线程数变成最大线程数。</li><li><strong>workQueue</strong>：等待队列。当前运行的线程数到达<strong>核心线程数</strong>时，新来的任务就会被存放在队列中。 </li><li><strong>keepAliveTime</strong>：当线程池中的线程数大于 <strong>corePoolSize</strong> 时，又没有新任务提交，<strong>核心线程外的线程</strong>会等待 keepAliveTime 后被回收销毁。</li><li><strong>unit</strong>：keepAliveTime 参数的时间单位。</li><li><strong>threadFactory</strong>：创建新线程时使用。</li><li><strong>handler</strong>：<strong>饱和策略</strong>。</li></ol></li><li><p>饱和策略</p><p><strong>定义</strong>：如果<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满</strong>了时，<code>ThreadPoolTaskExecutor</code> 定义一些策略: </p><ul><li><p><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code> 来拒绝新任务的处理。</p></li><li><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程（<strong>我理解为当前线程</strong>）运行任务，也就是直接在调用 <code>execute</code> 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</p></li><li><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</p></li><li><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。 </p></li><li><p><strong>总结</strong>：当不指定饱和策略时，默认使用 <strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。 </p></li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="10-线程池Demo：Runnable-TreadPoolExecutor"><a href="#10-线程池Demo：Runnable-TreadPoolExecutor" class="headerlink" title="10. 线程池Demo：Runnable + TreadPoolExecutor"></a>10. 线程池Demo：Runnable + TreadPoolExecutor</h3><ul><li>首先创建 Runnable 接口的实现类：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 * @author shuang.kou */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String command<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里写一个带参构造我没有看出作用，为此还重写了toString方法</span>    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Start. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" End. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CORE_POOL_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long KEEP_ALIVE_TIME <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用阿里巴巴推荐的创建线程池的方式</span>        <span class="token comment" spellcheck="true">//通过ThreadPoolExecutor构造函数自定义参数创建</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                CORE_POOL_SIZE<span class="token punctuation">,</span>                MAX_POOL_SIZE<span class="token punctuation">,</span>                KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//共创建了十个MyRunnable线程任务</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>            Runnable worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//执行Runnable</span>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//终止线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//没看懂这里的循环是什么作用</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finished all threads"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>输出为：</li></ul><pre class=" language-java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span></code></pre><hr><h3 id="11-线程池原理-执行策略"><a href="#11-线程池原理-执行策略" class="headerlink" title="11. 线程池原理 / 执行策略"></a>11. 线程池原理 / 执行策略</h3><p><img src="02-%E5%B9%B6%E5%8F%91.assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p><hr><h2 id="4-Atomic原子类-和-AQS"><a href="#4-Atomic原子类-和-AQS" class="headerlink" title="4. Atomic原子类 和 AQS"></a>4. Atomic原子类 和 AQS</h2><h3 id="1-Atomic原子类和其4种类型"><a href="#1-Atomic原子类和其4种类型" class="headerlink" title="1. Atomic原子类和其4种类型"></a>1. Atomic原子类和其4种类型</h3><ul><li>原子类就是具有原子性/原子操作特征的类。</li><li>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下 。</li></ul><ol><li><strong>原子更新基本类型</strong>：使用原子的方式更新基本类型<ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔型原子类</li></ul></li><li><strong>原子更新数组类型</strong>：使用原子的方式更新数组里的某个元素<ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul></li><li><strong>原子更新引用类型</strong>：<ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul></li><li><strong>原子更新字段（修改对象的属性）</strong>：<ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul></li></ol><hr><h3 id="2-AtomicInteger-的使用"><a href="#2-AtomicInteger-的使用" class="headerlink" title="2. AtomicInteger 的使用"></a>2. AtomicInteger 的使用</h3><ul><li>AtomicInteger 类的常用方法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并设置新的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并自增</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并自减</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并加上预期的值</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></code></pre><ul><li>AtomicInteger 类的使用示例：使用 AtomicInteger 之后，<strong>不用对 <code>increment()</code> 方法加锁也可以保证线程安全</strong>。 </li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AtomicIntegerTest</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建一个AtomicInteger对象，通过对象调用方法</span>        <span class="token keyword">private</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="3-AtomicInteger-类的原理"><a href="#3-AtomicInteger-类的原理" class="headerlink" title="3. AtomicInteger 类的原理"></a>3. AtomicInteger 类的原理</h3><ul><li>AtomicInteger 类的部分源码：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span></code></pre><hr><h3 id="4-CAS"><a href="#4-CAS" class="headerlink" title="4. CAS"></a>4. CAS</h3><hr><h3 id="5-AQS-Abstract-Queued-Synchronizer"><a href="#5-AQS-Abstract-Queued-Synchronizer" class="headerlink" title="5. AQS(Abstract Queued Synchronizer)"></a>5. AQS(Abstract Queued Synchronizer)</h3><p>AQS核心思想是，如果被请求的共享资源<strong>空闲</strong>，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为<strong>锁定状态</strong>。如果被请求的共享资源被<strong>占用</strong>，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将<strong>暂时获取不到锁的线程加入到队列中</strong>。</p><ul><li>CLH(Craig,Landin,and Hagersten)队列是一个<strong>虚拟</strong>的双向队列（<strong>虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系</strong>）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。 </li></ul><p>AQS使用一个 <strong>int 成员变量 state</strong> 来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//共享变量，使用volatile修饰保证线程可见性</span><span class="token comment" spellcheck="true">//返回同步状态的当前值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 设置同步状态的值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>         state <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="6-AQS-对资源的共享方式"><a href="#6-AQS-对资源的共享方式" class="headerlink" title="6. AQS 对资源的共享方式"></a>6. AQS 对资源的共享方式</h3><p>AQS定义<strong>两种资源共享方式</strong>：</p><ol><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。这其中又可以分为<strong>公平锁</strong>和<strong>非公平锁</strong>。<ul><li><strong>公平锁</strong>：按照线程在队列中顺序，先到者先拿到锁。</li><li><strong>非公平锁</strong>：所有线程同时抢锁，与顺序无关。</li></ul></li><li><strong>Share</strong>（共享）：多个线程可以同时执行，如 Semaphore/CountDownLatch。</li></ol><hr><h3 id="7-AQS-组件"><a href="#7-AQS-组件" class="headerlink" title="7. AQS 组件"></a>7. AQS 组件</h3><ul><li><strong>Semaphore</strong>（信号量）：允许多个线程同时访问。synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch</strong>（倒计时器）：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier</strong>（循环栅栏）：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</li></ul><hr><p>AQS原理和相关源码分析的文章：</p><p><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></p><p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发容器总结</title>
      <link href="/2020/08/05/bing-fa-rong-qi-zong-jie/"/>
      <url>/2020/08/05/bing-fa-rong-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="并发容器总结"><a href="#并发容器总结" class="headerlink" title="并发容器总结"></a>并发容器总结</h1><h2 id="1-ArrayList-的并发容器-CopyOnWriteArrayList"><a href="#1-ArrayList-的并发容器-CopyOnWriteArrayList" class="headerlink" title="1. ArrayList 的并发容器 CopyOnWriteArrayList"></a>1. ArrayList 的并发容器 CopyOnWriteArrayList</h2><h3 id="1-CopyOnWriteArrayList-简介"><a href="#1-CopyOnWriteArrayList-简介" class="headerlink" title="1. CopyOnWriteArrayList 简介"></a>1. CopyOnWriteArrayList 简介</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Object</span>    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable</code></pre><ul><li>实现了 <strong>RandomAccess 接口</strong>，实现这个接口表明集合是支持<strong>快速随机访问</strong>的。在 CopyOnWriteArrayList 中，可以<strong>通过元素的序号快速获取元素</strong>，这就是快速随机访问。</li><li>实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</li><li>实现了 <strong>java.io.serializable</strong> 接口，这表示 CopyOnWriteArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</li><li><strong>CopyOnWriteArrayList 是线程安全的</strong>。同样线程安全的数组容器还有有 Vector 。</li></ul><hr><h3 id="2-CopyOnWriteArrayList-读取操作的实现"><a href="#2-CopyOnWriteArrayList-读取操作的实现" class="headerlink" title="2. CopyOnWriteArrayList 读取操作的实现"></a>2. CopyOnWriteArrayList 读取操作的实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** The array, accessed only via getArray/setArray. */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>可见，<strong>CopyOnWriteArrayList 读取操作没有任何同步和锁操作</strong>。</li><li>读取操作并不会改变数组，因此对读取操作加锁是一种浪费资源，<strong>读取操作允许多个线程同时访问</strong>。ReentrantReadWriteLock 读写锁的思想是，<strong>读读共享、写写互斥、读写互斥和写读互斥</strong>。而 <strong>CopyOnWriteArrayList 可以做到读写不互斥，只有写写之间需要同步等待</strong>。</li><li>CopyOnWriteArrayList 即使发生修改，<strong>原内部数组也不会改变，而是产生一个新数组，然后将引用指向新数组</strong>，因此可以保证数据安全，读写可以同时进行。</li></ul><hr><h3 id="3-CopyOnWriteArrayList-写入操作的实现"><a href="#3-CopyOnWriteArrayList-写入操作的实现" class="headerlink" title="3. CopyOnWriteArrayList 写入操作的实现"></a>3. CopyOnWriteArrayList 写入操作的实现</h3><p>CopyOnWriteArrayList 写入操作 <code>add()</code> 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list e是要加入数组的元素     * @return {@code true} (as specified by {@link Collection#add})     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加锁</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝新数组，长度+1</span>            <span class="token comment" spellcheck="true">//把新元素放在数组的末尾</span>            newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放锁</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li>这里并发控制使用的是 <strong>ReentrantLock</strong>，没有使用 synchronized。</li></ul><hr><h3 id="4-CopyOnWriteArrayList-和-ArrayList-的对比"><a href="#4-CopyOnWriteArrayList-和-ArrayList-的对比" class="headerlink" title="4. CopyOnWriteArrayList 和 ArrayList 的对比"></a>4. CopyOnWriteArrayList 和 ArrayList 的对比</h3><hr><h3 id="5-CopyOnWriteArrayList-和-Vector-的对比"><a href="#5-CopyOnWriteArrayList-和-Vector-的对比" class="headerlink" title="5. CopyOnWriteArrayList 和 Vector 的对比"></a>5. CopyOnWriteArrayList 和 Vector 的对比</h3><hr><h2 id="2-队列的并发容器"><a href="#2-队列的并发容器" class="headerlink" title="2. 队列的并发容器"></a>2. 队列的并发容器</h2><h3 id="1-ConcurrentLinkedQueue-简介"><a href="#1-ConcurrentLinkedQueue-简介" class="headerlink" title="1. ConcurrentLinkedQueue 简介"></a>1. ConcurrentLinkedQueue 简介</h3><p>Java 提供的线程安全的 Queue 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中<strong>阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue</strong>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>ConcurrentLinkedQueue 使用链表作为其数据结构，<strong>ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了</strong>。它之所有能有很好的性能，是因为其内部复杂的实现。对于 ConcurrentLinkedQueue 知道<strong>主要使用 CAS 非阻塞算法来实现线程安全</strong>就好了。</p><p>ConcurrentLinkedQueue 适合在<strong>对性能要求相对较高，同时对队列的读写存在多个线程同时进行</strong>的场景。</p><hr><h3 id="2-BlockingQueue-简介"><a href="#2-BlockingQueue-简介" class="headerlink" title="2. BlockingQueue 简介"></a>2. BlockingQueue 简介</h3><ul><li><p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 <strong>BlockingQueue 提供了可阻塞的插入和移除的方法</strong>。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。 </p></li><li><p><strong>BlockingQueue 是一个接口</strong>，继承自 Queue，所以<strong>其实现类也可以作为 Queue 的实现来使用（多态）</strong>，而 Queue 又继承自 Collection 接口。 </p></li></ul><p>接下来主要介绍 BlockingQueue 的三个实现类：<strong>ArrayBlockingQueue、LinkedBlockingQueue 和 PriorityBlockingQueue</strong>。</p><hr><h3 id="3-ArrayBlockingQueue-简介"><a href="#3-ArrayBlockingQueue-简介" class="headerlink" title="3. ArrayBlockingQueue 简介"></a>3. ArrayBlockingQueue 简介</h3><ul><li><p><strong>ArrayBlockingQueue</strong> 是 BlockingQueue 接口的有界队列实现类，底层采用<strong>数组</strong>来实现。ArrayBlockingQueue 一旦创建，<strong>容量不能改变</strong>。其并发控制采用<strong>可重入锁</strong>来控制，<strong>不管是插入操作还是读取操作，都需要获取到锁才能进行操作</strong>。当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。</p></li><li><p>ArrayBlockingQueue 的锁是非公平锁，如果要保证公平性，通常会降低吞吐量。如果需要获得公平的 ArrayBlockingQueue，构造方法中提供了相关参数：</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> ArrayBlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="4-LinkedBlockingQueue-简介"><a href="#4-LinkedBlockingQueue-简介" class="headerlink" title="4. LinkedBlockingQueue 简介"></a>4. LinkedBlockingQueue 简介</h3><ul><li><strong>LinkedBlockingQueue</strong> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，<strong>与 ArrayBlockingQueue 相比起来具有更高的吞吐量</strong>，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，<strong>如果未指定，容量等于 Integer.MAX_VALUE</strong>。 </li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *某种意义上的无界队列，队列容量非常大     * Creates a {@code LinkedBlockingQueue} with a capacity of     * {@link Integer#MAX_VALUE}.     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *有界队列     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.     *     * @param capacity the capacity of this queue     * @throws IllegalArgumentException if {@code capacity} is not greater     *         than zero     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>我理解类似于 LinkedList 的线程安全版本。</li></ul><hr><h3 id="5-PriorityBlockingQueue-简介"><a href="#5-PriorityBlockingQueue-简介" class="headerlink" title="5. PriorityBlockingQueue 简介"></a>5. PriorityBlockingQueue 简介</h3><ul><li><strong>PriorityBlockingQueue</strong> 是一个<strong>支持优先级的无界阻塞队列</strong>。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</li><li>PriorityBlockingQueue 队列为无界队列。ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 可以通过在构造函数中传入 capacity 指定队列最大的容量。但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>。</li><li>PriorityBlockingQueue 并发控制采用的是 <strong>ReentrantLock</strong>。</li><li>简单地说，它就是 <strong>PriorityQueue 的线程安全版本</strong>。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的<strong>插入操作 <code>put()</code> 方法不会阻塞，因为它是无界队列。<code>take()</code> 方法在队列为空的时候会阻塞</strong> 。</li></ul><hr><h2 id="3-HashMap-的并发容器-ConcurrenHashMap"><a href="#3-HashMap-的并发容器-ConcurrenHashMap" class="headerlink" title="3. HashMap 的并发容器 ConcurrenHashMap"></a>3. HashMap 的并发容器 ConcurrenHashMap</h2><h3 id="1-ConcurrenHashMap-简介"><a href="#1-ConcurrenHashMap-简介" class="headerlink" title="1. ConcurrenHashMap 简介"></a>1. ConcurrenHashMap 简介</h3><p>在 ConcurrentHashMap 中，<strong>无论是读操作还是写操作都能保证很高的性能</strong>：在进行读操作时(几乎)不需要加锁，而在写操作时，通过<strong>锁分段技术</strong>只对所操作的段加锁，而不影响客户端对其它段的访问。 </p><ul><li>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 </li><li>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</li></ul><hr><h3 id="2-Java-7-和-Java-8-中ConcurrenHashMap-的区别"><a href="#2-Java-7-和-Java-8-中ConcurrenHashMap-的区别" class="headerlink" title="2. Java 7 和 Java 8 中ConcurrenHashMap 的区别"></a>2. Java 7 和 Java 8 中ConcurrenHashMap 的区别</h3><ol><li><strong>Java 7</strong> 中，ConcurrnetHashMap 由很多个 <strong>Segment</strong> 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>。</li></ol><p><img src="%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93.assets/Java7ConcurrenHashMap.png" alt=""></p><ul><li>整理：<ul><li><strong>Segment 的个数默认是 16</strong>，也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发；</li><li>Segment 的个数也会向上取得最近的 2 的整数幂；</li><li>Segment 中的 HashMap 默认容量是 2，负载因子 0.75f，扩容阈值 1.5，插入第二个值时才会扩容；</li><li>Segment 中的 HashMap 扩容机制和 HashMap 相同，容量扩容为原来的 2 倍。<strong>数据迁移后，只可能在原来的位置，或者（原来的位置 + 原来的容量）位置</strong>（HashMap 也是一样）；</li><li><strong>Segment 继承了 ReentrantLock</strong>，所以 Segment 内部可以很方便的获取锁。</li></ul></li></ul><ol start="2"><li><strong>Java 8</strong> 中，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>，非常类似于 Java 8 中的 HashMap。</li></ol><p><img src="%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93.assets/Java8_concurrenthashmap.png" alt=""></p><ul><li>整理：<ul><li>使用 <strong>CAS 和 synchronized 锁</strong>来保证并发安全；</li><li><strong>synchronized 只锁定当前链表或红黑二叉树的首节点</strong>，这样只要 hash 不冲突，就不会产生并发，提高效率。</li></ul></li></ul><hr><h3 id="3-ConcurrentHashMap-和-HashTable-的对比"><a href="#3-ConcurrentHashMap-和-HashTable-的对比" class="headerlink" title="3. ConcurrentHashMap 和 HashTable 的对比"></a>3. ConcurrentHashMap 和 HashTable 的对比</h3><ol><li>底层数据结构：JDK1.7之前ConcurrentHashMap由<strong>分段的数组+链表</strong>实现，JDK1.8采用的数据结构和HashMap一样，<strong>数组+链表/红黑树</strong>。HashTable和JDK1.8之前的HashMap采用<strong>数组+链表</strong>的形式。</li><li>实现线程安全的方式： <strong>ConcurrentHashMap **在JDK1.7时，对整个桶数组进行了分割分段（segment），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。** 整个看起来就像是优化过且线程安全的 HashMap 。<strong>HashTable</strong> 使用 synchronized 来保证线程安全，所有操作竞争一把锁，效率非常低下。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-Java基础</title>
      <link href="/2020/07/09/01-java-ji-chu/"/>
      <url>/2020/07/09/01-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-Java基础概念与常识"><a href="#1-Java基础概念与常识" class="headerlink" title="1. Java基础概念与常识"></a>1. Java基础概念与常识</h2><h3 id="1-Java的三大特性"><a href="#1-Java的三大特性" class="headerlink" title="1. Java的三大特性"></a>1. Java的三大特性</h3><p><strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>。</p><p><strong>封装</strong>：隐藏具体的属性和细节，仅对外提供公共访问方式。如getter，setter。<strong>目的/好处</strong>：增强安全性，简化编程，便于使用。</p><p><strong>继承</strong>：将多个相同的属性和方法提取出来，新建一个父类。<strong>目的/好处</strong>：代码复用。</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法（重写）。</li></ol><p><strong>多态</strong>： 在声明时使用父类，在实现或调用时使用具体的子类 ，不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。<strong>目的/好处</strong>：提高代码的灵活性和拓展性。</p><ul><li>多态有两种表现形式，<strong>重载</strong>和<strong>重写</strong>。</li><li>重载：一个类中可以有多个同名的方法，但参数列表必须不同，这表现的是同一个类中方法的多态性。</li><li>重写：子类中可以定义父类中同名的方法，这表现的是父子类方法的多态性。</li></ul><table><thead><tr><th align="center">区别点</th><th align="center">重载方法</th><th align="center">重写方法</th></tr></thead><tbody><tr><td align="center">发生范围</td><td align="center">同一个类</td><td align="center">父子类</td></tr><tr><td align="center">参数列表</td><td align="center">必须修改</td><td align="center">不能修改</td></tr><tr><td align="center">返回类型</td><td align="center">可修改</td><td align="center">不能修改</td></tr><tr><td align="center">异常</td><td align="center">可修改</td><td align="center">可以减少或删除，不能抛出新的或者更广的异常</td></tr><tr><td align="center">访问修饰符</td><td align="center">可修改</td><td align="center">不能做更严格的限制（可以降低限制）</td></tr><tr><td align="center">发生阶段</td><td align="center">编译期</td><td align="center">运行期</td></tr></tbody></table><hr><h3 id="2-JVM、JDK-和-JRE"><a href="#2-JVM、JDK-和-JRE" class="headerlink" title="2. JVM、JDK 和 JRE"></a>2. JVM、JDK 和 JRE</h3><ol><li><p>JVM：Java 虚拟机，是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和<strong>不同系统的 JVM</strong> 实现是 Java 语言“一次编译，随处运行”的关键所在。 </p></li><li><p>JDK：Java开发工具包，是功能齐全的 Java SDK，拥有 JRE 拥有的一切，此外还有编译器（javac）和工具（javadoc 和 jdb）。<strong>能够创建和编译程序</strong>。</p><ul><li>javadoc：它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。</li><li>jdb：调试器（Java Debugger），和 IDEA、Eclipse 等 IDE 中提供的调试功能共同依赖同一套调试 API，也就是 Java Platform Debugger Architecture (JPDA)。</li></ul></li><li><p>JRE：Java运行时环境，是运行已编译 Java 程序所需所有内容的集合，包括 JVM ，Java 类库。Java 命令等基础构件。但<strong>不能用于创建新程序</strong>。</p></li></ol><hr><h3 id="3-Java-和-C-的对比"><a href="#3-Java-和-C-的对比" class="headerlink" title="3. Java 和 C++ 的对比"></a>3. Java 和 C++ 的对比</h3><ol><li>两者都是面向对象的语言，都支持封装、继承和多态；</li><li>Java 不提供<strong>指针</strong>直接访问内存，程序内存更加安全。这里延伸出的一个问题是：<strong>*Java中的引用和C++中的指针有什么区别？</strong></li><li>Java 中的类是单<strong>继承</strong>的，C++ 中可以多继承。但 Java 中的接口是可以多继承的。</li><li>Java 有<strong>内存管理机制</strong>，不需要程序员手动释放内存。</li><li>C/C++ 中，字符串或字符数组最后都会有一个额外字符 ‘/0’ 来表示结束。但 Java 中没有结束符这个概念。<a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">参考文章</a>。</li></ol><hr><h3 id="4-Java-语言“编译与解释并存”"><a href="#4-Java-语言“编译与解释并存”" class="headerlink" title="4. Java 语言“编译与解释并存”"></a>4. Java 语言“编译与解释并存”</h3><ol><li>理解：高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。 <strong>编译型先编译完再执行，解释型边解释边执行</strong>。</li><li>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。 </li></ol><hr><h2 id="2-Java-基础核心"><a href="#2-Java-基础核心" class="headerlink" title="2. Java 基础核心"></a>2. Java 基础核心</h2><h3 id="1-Java中的基本数据类型"><a href="#1-Java中的基本数据类型" class="headerlink" title="1. Java中的基本数据类型"></a>1. Java中的基本数据类型</h3><table><thead><tr><th align="center">数据类型</th><th align="center">关键字</th><th align="center">内存占用</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">byte</td><td align="center">1字节</td><td align="center">Byte</td></tr><tr><td align="center">短整型</td><td align="center">short</td><td align="center">2字节</td><td align="center">Short</td></tr><tr><td align="center">整形</td><td align="center">int</td><td align="center">4字节</td><td align="center">Integer</td></tr><tr><td align="center">长整形</td><td align="center">long</td><td align="center">8字节</td><td align="center">Long</td></tr><tr><td align="center">单精度浮点数</td><td align="center">float</td><td align="center">4字节</td><td align="center">Float</td></tr><tr><td align="center">双精度浮点数</td><td align="center">double</td><td align="center">8字节</td><td align="center">Double</td></tr><tr><td align="center">字符型</td><td align="center">char</td><td align="center">2字节</td><td align="center">Character</td></tr><tr><td align="center">布尔型</td><td align="center">boolean</td><td align="center">1字节</td><td align="center">Boolean</td></tr></tbody></table><ul><li>自动装箱与拆箱，详细内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a><ul><li><strong>装箱</strong>：将基本类型用它们对应的应用类型包装起来；</li><li><strong>拆箱</strong>：将包装类转换为基本类型。</li></ul></li></ul><hr><h3 id="2-包装类和常量池"><a href="#2-包装类和常量池" class="headerlink" title="2. 包装类和常量池"></a>2. 包装类和常量池</h3><p>Java 中大部分基础类型的包装类都实现了<strong>常量池技术</strong>：</p><ol><li><strong>Byte、Short、Integer、Long</strong> 默认创建了数值 [-128,127] 的相应类型的缓存数据；</li><li><strong>Character</strong>创建了数值在 [0,127] 范围的缓存数据；</li><li><strong>Boolean</strong> 直接返回 true or false；</li></ol><ul><li>如果数值<strong>不属于</strong>缓存的范围，会创建新的对象。</li><li>两种浮点类型的包装类 <strong>Float</strong> 和 <strong>Double</strong> 没有实现常量池技术。</li><li><code>Integer i1=40</code>；Java 在编译的时候会直接将代码封装成 <code>Integer i1=Integer.valueOf(40);</code>，从而使用常量池中的对象。 </li><li><code>Integer i1 = new Integer(40);</code> 这种情况下会创建新的对象。 </li></ul><pre class=" language-java"><code class="language-java">  Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Integer i4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Integer i5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Integer i6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2+i3   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 <span class="token operator">+</span> i3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i4   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"40=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">i1<span class="token operator">=</span>i2   <span class="token boolean">true</span>i1<span class="token operator">=</span>i2<span class="token operator">+</span>i3   <span class="token boolean">true</span>i1<span class="token operator">=</span>i4   <span class="token boolean">false</span>i4<span class="token operator">=</span>i5   <span class="token boolean">false</span>i4<span class="token operator">=</span>i5<span class="token operator">+</span>i6   <span class="token boolean">true</span><span class="token number">40</span><span class="token operator">=</span>i5<span class="token operator">+</span>i6   <span class="token boolean">true</span></code></pre><ul><li><strong>装箱和拆箱的理解</strong>：语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。 </li></ul><hr><h3 id="3-字符型常量和字符串常量的区别"><a href="#3-字符型常量和字符串常量的区别" class="headerlink" title="3. 字符型常量和字符串常量的区别"></a>3. 字符型常量和字符串常量的区别</h3><ol><li>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干字符。</li><li>含义上：字符常量相当于一个整型值（ASCII），可以参加表达式运算；字符串常量代表一个地址值（内存中的位置）。</li><li>占内存大小：字符常量占 2 字节，字符串常量占若干字节。注意：<strong>char 在其他语言中占 1 字节居多，但在 Java 中占 2 字节</strong>。</li></ol><hr><h3 id="4-Java-泛型，类型擦除"><a href="#4-Java-泛型，类型擦除" class="headerlink" title="4. Java 泛型，类型擦除"></a>4. Java 泛型，类型擦除</h3><ul><li><p>泛型提供了编译时<strong>类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。 </p></li><li><p><strong>Java 的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。</strong><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">Java 泛型类型擦除</a></p></li><li><p>泛型一般有三种使用方式：<strong>泛型类</strong>、<strong>泛型接口</strong>和<strong>泛型方法</strong>。</p><ol><li><strong>泛型类</strong></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><span class="token comment" spellcheck="true">//在实例化泛型类时，必须指定T的具体类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>     <span class="token keyword">private</span> T key<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Generic</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实例化泛型类（<strong>类似 List 等类</strong>）：</p><pre class=" language-java"><code class="language-java">Generic<span class="token operator">&lt;</span>Integer<span class="token operator">></span> genericInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generic</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><strong>泛型接口</strong></li></ol><ul><li>实现泛型接口时，可以不指定类型，也可以指定类型。</li></ul><ol start="3"><li><strong>泛型方法</strong></li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span> E <span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray <span class="token punctuation">)</span>   <span class="token punctuation">{</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span> E element <span class="token operator">:</span> inputArray <span class="token punctuation">)</span><span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"%s "</span><span class="token punctuation">,</span> element <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这是一个打印数组的方法，可以处理各种类型的数组。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//基本数据类型的数组必须是包装类，如Integer、Double</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> stringArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printArray</span><span class="token punctuation">(</span>stringArray<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="4"><li><p><strong>泛型常用通配符</strong></p><ol><li>？ 表示不确定类型；</li><li>T   表示一个具体的类型；</li><li>K V 表示键值中的 key value；</li><li>E   表示 element。</li></ol><ul><li>更多内容查看：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">聊一聊Java泛型中的通配符</a></li></ul></li></ol></li></ul><hr><h3 id="5-static关键字"><a href="#5-static关键字" class="headerlink" title="5. static关键字"></a>5. static关键字</h3><ul><li>意思是静态的、全局的，被修饰内容在一定范围内是<strong>共享的</strong>，谁都可以访问，此时需要注意<strong>并发</strong>读写的问题。</li></ul><ol><li><p><strong>修饰的对象</strong></p><ul><li>static 只能修饰<strong>类变量、方法和方法块</strong>。</li></ul><ol><li><p>当 static 修饰<strong>类变量</strong>时，如果该变量是 public 修饰，表示该变量任何类都可以访问，而且无需初始化类，直接使用<strong>类名.static变量</strong>这种形式访问即可。</p><ul><li>当 static 修饰<strong>类变量</strong>时， 需要注意<strong>线程</strong>安全问题，有两种解决方法，一是使用线程安全的数据结构，如用 <code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code> 。二是每次访问时手动加锁。</li></ul></li><li><p>当 static 修饰<strong>方法</strong>时，代表该方法和类对象是无关的，任意类都可以访问（权限public）。</p><ul><li>当 static 修饰<strong>方法</strong>时，该方法只能调用被 static 修饰的方法，不能调用其他方法。</li><li>当 static 修饰<strong>方法</strong>时，该方法内部的变量在执行时是<strong>没有</strong>线程安全的问题的。方法执行时，数据运行在<strong>栈</strong>里，栈的数据每个线程都是隔离开的，所有不会有线程安全的问题。</li></ul></li><li><p>当 static 修饰<strong>方法块</strong>时，叫做静态代码块，常常用在类启动之前，进行初始化。需要<strong>注意</strong>的是，静态代码块只能调用被 static 修饰的变量，并且要写在前面，否则会报错。</p></li></ol></li><li><p><strong>初始化的时机</strong></p><ol><li><strong>父类</strong>的静态变量和静态代码块比子类优先初始化；</li><li>一个类中，<strong>静态变量</strong>和静态代码块比构造器先初始化。</li></ol><ul><li>类中被 static 修饰的<strong>方法</strong>，在类初始化的时候<strong>不会初始化</strong>，只有当被调用时，才会被执行。</li></ul></li></ol><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super" target="_blank" rel="noopener">更多关键字内容参考</a>。</li></ul><hr><h3 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h3><ol><li>被 final 修饰的类，表明该类无法继承；</li><li>被 final 修饰的方法，表明该方法无法覆盖重写；</li><li>被 final 修饰的变量，表明该变量的内存地址无法改变，并且在声明时必须完成初始化。</li></ol><ul><li>被 final 修饰的变量，并不是不可以修改其值，对于 List 和 Map 这种集合类，被 final 修饰后，其<strong>内部值</strong>是可以修改的，但<strong>内存地址</strong>不可以修改。</li></ul><hr><h3 id="7-volatile关键字"><a href="#7-volatile关键字" class="headerlink" title="7. volatile关键字"></a>7. volatile关键字</h3><ul><li>volatile 的意思是可见的，常用来修饰某个<strong>共享变量</strong>，作用是当共享变量被修改后，会及时将变化通知到其他线程。</li></ul><p>我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU <strong>缓存</strong>打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。</p><p>这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。</p><p>这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。</p><p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。</p><hr><h3 id="8-default关键字"><a href="#8-default关键字" class="headerlink" title="8. default关键字"></a>8. default关键字</h3><ul><li>default 关键字一般用在接口的方法上，表明对于该方法，子类无需覆盖重写，但接口中必须有默认实现。</li></ul><hr><h3 id="9-Java-中的值传递"><a href="#9-Java-中的值传递" class="headerlink" title="9. Java 中的值传递"></a>9. Java 中的值传递</h3><ul><li><strong>按值调用(call by value)</strong>表示方法接收的是调用者提供的<strong>值</strong>，而<strong>按引用调用（call by reference)</strong>表示方法接收的是调用者提供的<strong>变量地址</strong>。</li><li><strong>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值</strong>。</li><li><strong>Java 程序设计语言总是采用按值调用</strong>。也就是说，<strong>方法得到的是所有参数值的一个拷贝</strong>。</li></ul><p>例1：<strong>基础类型</strong>的参数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num1 = "</span> <span class="token operator">+</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num2 = "</span> <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> <span class="token number">20</span>b <span class="token operator">=</span> <span class="token number">10</span>num1 <span class="token operator">=</span> <span class="token number">10</span>num2 <span class="token operator">=</span> <span class="token number">20</span></code></pre><ul><li><strong>基础类型的参数按值传递，拷贝得到的就是变量的值，原变量的值不能被修改</strong>。</li></ul><p>例2：<strong>对象</strong>作为参数，交换对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小张"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Student s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小李"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Test<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Student x<span class="token punctuation">,</span> Student y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Student temp <span class="token operator">=</span> x<span class="token punctuation">;</span>    x <span class="token operator">=</span> y<span class="token punctuation">;</span>    y <span class="token operator">=</span> temp<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x:"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"y:"</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">x<span class="token operator">:</span>小李y<span class="token operator">:</span>小张s1<span class="token operator">:</span>小张s2<span class="token operator">:</span>小李</code></pre><ul><li><strong>对象类型</strong>的参数按值传递，但要注意的是，<strong>对象类型的值就是对象的地址值，因此拷贝得到的对象与原对象指向同一个地址</strong>。</li><li><strong>本例中进行交换操作，只是对拷贝的对象进行交换，并不会影响到原对象。但如果对拷贝的对象进行修改内容的操作，则会对原对象造成影响。</strong></li></ul><p>例3：<strong>对象</strong>作为参数，修改对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小张"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Student s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小李"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Student x<span class="token punctuation">,</span> Student y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String temp <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    x<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    y<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x:"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"y:"</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">原s1<span class="token operator">:</span>小张原s2<span class="token operator">:</span>小李x<span class="token operator">:</span>小李y<span class="token operator">:</span>小张新s1<span class="token operator">:</span>小李新s2<span class="token operator">:</span>小张</code></pre><ul><li><strong>本例中对拷贝的对象进行交换内容的操作，导致原对象内容也发生了改变</strong>。</li></ul><hr><h3 id="10-深拷贝和浅拷贝"><a href="#10-深拷贝和浅拷贝" class="headerlink" title="10. 深拷贝和浅拷贝"></a>10. 深拷贝和浅拷贝</h3><ol><li><strong>浅拷贝</strong>：对于引用数据类型进行引用传递的拷贝，称为浅拷贝。<strong>修改拷贝对象的内容，原对象也会发生改变</strong>。</li><li><strong>深拷贝</strong>：对于引用数据类型，创建一个新的对象，并复制其内容，称为深拷贝。<strong>修改拷贝对象的内容，原对象不会发生改变</strong>。</li></ol><ul><li><strong>基本数据类型始终都是值传递</strong>。</li></ul><hr><h3 id="11-异常"><a href="#11-异常" class="headerlink" title="11. 异常"></a>11. 异常</h3><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p><ul><li><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual Machine Error），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 </li><li><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。 </li><li><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong> </li></ul><hr><h3 id="12-thy-catch-finally"><a href="#12-thy-catch-finally" class="headerlink" title="12. thy-catch-finally"></a>12. thy-catch-finally</h3><ul><li><strong>try块</strong>：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 </li><li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。 </li><li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。<strong>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行</strong>。</li></ul><p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p><ol><li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li><li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><ul><li><strong>注意</strong>：当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。 </li></ul><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/%E5%BC%82%E5%B8%B82.png" alt="异常层次图"></p><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/%E5%BC%82%E5%B8%B8.png" alt=""></p><hr><h3 id="13-I-O流"><a href="#13-I-O流" class="headerlink" title="13. I/O流"></a>13. I/O流</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 </p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/IO%E6%B5%811.png" alt=""></p><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/IO%E6%B5%812.png" alt=""></p><hr><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h2><h3 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1. 面向对象和面向过程"></a>1. 面向对象和面向过程</h3><ul><li><strong>面向过程</strong>：可以理解为一件复杂的事，分为几个步骤，一步一步去做。</li><li><strong>面向对象</strong>：可以理解为一件复杂的事，分为一个模块，分别找不同的人来做。</li><li>面向过程和面向对象的语言<strong>性能对比</strong>：</li></ul><p>Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p><hr><h3 id="2-构造器和构造方法"><a href="#2-构造器和构造方法" class="headerlink" title="2. 构造器和构造方法"></a>2. 构造器和构造方法</h3><ol><li>构造器 (Constructor) 不可以被重写 (override)，但可以被重载 (overload)，所以一个类中可以有多个构造函数。</li><li><strong>无参构造方法的作用</strong>：Java 中构造方法执行的顺序是<strong>先父类构造方法，再子类构造方法</strong>。如果在子类中，子类构造方法前没有用 <code>super</code> 来调用父类特定的构造方法，则会<strong>自动调用父类中的 “无参构造方法”</strong>。因此，如果父类中没有 “无参构造方法”，而子类中又没有用 <code>super</code> 来调用父类特定的构造方法，编译时就会发生错误。</li></ol><hr><h3 id="3-Java中抽象类和接口的区别"><a href="#3-Java中抽象类和接口的区别" class="headerlink" title="3. Java中抽象类和接口的区别"></a>3. Java中抽象类和接口的区别</h3><ol><li>抽象类用abstract修饰，接口用interface修饰；</li><li>抽象类只能被单继承，接口可以实现多个；</li><li>抽象类中可以有非抽象方法，接口中必须都是抽象方法；</li><li>接口中成员变量必须是public static final修饰，必须赋初值，实现类不能重新定义或修改。抽象类中的成员变量默认default，子类可以重新定义或修改；</li><li>抽象类中允许有静态方法(static修饰)，接口中的方法不允许有静态方法。 </li></ol><hr><h3 id="4-Java中抽象类和普通类的区别"><a href="#4-Java中抽象类和普通类的区别" class="headerlink" title="4. Java中抽象类和普通类的区别"></a>4. Java中抽象类和普通类的区别</h3><ol><li>抽象类中有抽象方法，普通类中没有；</li><li>抽象类中可以有构造方法，但不能实例化。普通类可以实例化；</li><li>抽象方法不能被声明为静态(static修饰)，普通类中的方法都可以被声明为静态；</li><li>抽象类的子类必须重写所有抽象方法，否则必须是抽象类。普通类的子类只需声明继承；</li></ol><hr><h3 id="5-成员变量和局部变量的区别"><a href="#5-成员变量和局部变量的区别" class="headerlink" title="5. 成员变量和局部变量的区别"></a>5. 成员变量和局部变量的区别</h3><ol><li>从语法形式上看：成员变量是定义在类中，方法外的，局部变量是定义于方法内的。成员变量可以被<strong>权限修饰符如 <code>public</code> <code>private</code> *<em>等修饰，而局部变量不可以。成员变量可以被 *</em><code>static</code> *<em>修饰，而局部变量不可以。但是两者都可以被 *</em><code>final</code></strong> 修饰。</li><li>从存储方式上看：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存</strong>，<strong>局部变量则存在于栈内存</strong>。 </li><li>从生存时间上看：成员变量是对象的一部分，它随着<strong>对象</strong>的创建而存在，而局部变量随着<strong>方法</strong>的调用而自动消失。 </li><li>初值：成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值，<strong>在使用前必须手动赋值</strong>。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
