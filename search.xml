<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/09/28/she-ji-mo-shi/"/>
      <url>/2020/09/28/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><h3 id="1-单例模式简介"><a href="#1-单例模式简介" class="headerlink" title="1. 单例模式简介"></a>1. 单例模式简介</h3><p>单例模式就是保证<strong>一个类只有一个实例</strong>。</p><p><strong>目的</strong>：频繁的创建一个类的对象、管理对象和销毁对象是十分耗费资源的，只创建一个对象来避免这些消耗。某些特殊情况下，要求一个类的对象只能有一个。</p><p><strong>特点</strong>：关键在于<strong>构造器私有化</strong>。</p><ol><li>构造函数私有化，用 private 修饰构造函数，使外界无法显示地创建对象。</li><li>在类的内部创建一个实例对象。</li><li>向外界提供一个得到实例对象的方法。</li></ol><p><strong>破坏</strong>：在特殊情况下，单例模式会被攻击破坏。</p><ol><li><strong>序列化与反序列化</strong>：利用输出流（OutputStream）与输入流（InputStream），先写出在读入，这时会产生一个新的对象。原因是在读入（InputStream），也就是<strong>反序列化时，会通过反射调用类的无参构造</strong>，创建出新的对象。</li><li><strong>反射</strong>：反射可以通过 <code>setAccessable(true)</code> 获取私有构造器，通过构造器创建出多个不同的对象。上述序列化和反序列化其实也是用到反射。</li></ol><p><strong>解决方式</strong>：</p><ol><li><strong>序列化与反序列化</strong>：在单例模式的类中，添加一个 <code>readResolve()</code> 方法，返回单例对象。原因是反序列化过程中，会判读是否有 <code>readResolve()</code> 方法，如果有，使用该方法的返回值作为反序列化的返回值。</li></ol><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>            handles<span class="token punctuation">.</span><span class="token function">lookupException</span><span class="token punctuation">(</span>passHandle<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>            desc<span class="token punctuation">.</span><span class="token function">hasReadResolveMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Object rep <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">invokeReadResolve</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">/**     * Returns true if represented class is serializable or externalizable and     * defines a conformant readResolve method.  Otherwise, returns false.     */</span>    <span class="token keyword">boolean</span> <span class="token function">hasReadResolveMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">requireInitialized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>readResolveMethod <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ol start="2"><li><strong>反射</strong>：使用枚举单例模式，因为<strong>枚举类型在底层屏蔽了反射调用</strong>。</li></ol><hr><h3 id="2-饿汉式单例模式"><a href="#2-饿汉式单例模式" class="headerlink" title="2. 饿汉式单例模式"></a>2. 饿汉式单例模式</h3><ul><li>在类的内部先创建出一个实例对象，向外界提供方法获取。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hungry</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在类的内部创建私有对象，必须是静态变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Hungry single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hungry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">Hungry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//对外提供的获得对象的方法，必须是静态方法，通过类名调用</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Hungry <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> single<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//内部的其他方法可以不是静态方法，通过获得的单例对象调用</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"饿汉式单例模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>缺点</strong></p></blockquote><ol><li>类中先创建出了一个对象，在外部不需要使用这个实例对象时，是一种<strong>内存浪费</strong>。</li><li><strong>不能保证线程安全</strong>。</li></ol><hr><h3 id="2-懒汉式单例模式"><a href="#2-懒汉式单例模式" class="headerlink" title="2. 懒汉式单例模式"></a>2. 懒汉式单例模式</h3><ul><li>不直接在类中创建实例对象，需要时先判断对象是否已创建，如果没有创建就先创建，如果已经创建就直接返回。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Lazy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//单例对象作为一个静态私有变量，不直接初始化</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Lazy lazy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">Lazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//对外提供的获得对象的方法，必须是静态方法，通过类名调用    </span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Lazy <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazy <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            lazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lazy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> lazy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"懒汉式单例模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>缺点：<strong>不能保证线程安全</strong>。</li></ul><hr><h3 id="3-双重校验锁单例模式"><a href="#3-双重校验锁单例模式" class="headerlink" title="3. 双重校验锁单例模式"></a>3. 双重校验锁单例模式</h3><ul><li>在懒汉式单例模式的基础上加双重校验锁。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DCL</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对实例对象加volatile关键字保证可见性和有序性</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DCL dcl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DCL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//采用静态代码块的方式，锁住类的Class对象，保证锁的唯一性</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> DCL <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一个if判断是提高程序效率，已创建了对象直接返回，不用进同步代码块</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dcl <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>DCL<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//只有外层判断是不够的，可能会创建出多个对象，所以这里还要进行一次判断</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dcl <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    dcl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DCL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dcl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"双重校验锁单例模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>特点</strong></p></blockquote><ul><li><strong>一定要用 volatile 修饰实例对象变量</strong>，保证可见性和有序性（防止指令重排）。</li><li><strong>加锁前有一次非空判断，加锁后也有一次非空判断</strong>。</li><li><strong>保证线程安全</strong>（反射调用除外）。</li></ul><hr><h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4. 静态内部类单例模式"></a>4. 静态内部类单例模式</h3><ul><li>静态内部类的特点，<strong>被调用时才进行初始化</strong>。</li><li><strong>保证线程安全</strong>。</li><li>推荐使用。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//静态内部类，必须是静态才能被getInstance()访问到</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//必须是静态才能通过类名访问到，而且用final修饰保证不变。</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> InnerClass IC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> InnerClass <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Inner<span class="token punctuation">.</span>IC<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态内部类单例模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="5-枚举单例模式"><a href="#5-枚举单例模式" class="headerlink" title="5. 枚举单例模式"></a>5. 枚举单例模式</h3><ul><li>反射可以通过 <code>setAccessable(true)</code> 获取私有构造器，通过构造器创建出多个不同的对象。</li><li>以上的所有单例模式，都可以被反射破解，<strong>只有枚举单例模式不会被反射破解</strong>。</li><li>枚举是 JDK 1.5 之后引入的新特性，<strong>其底层源码屏蔽了反射调用</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//实例对象</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"枚举式单例模式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="6-测试总结"><a href="#6-测试总结" class="headerlink" title="6. 测试总结"></a>6. 测试总结</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Hungry hungry1 <span class="token operator">=</span> Hungry<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Hungry hungry2 <span class="token operator">=</span> Hungry<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hungry1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hungry1 <span class="token operator">==</span> hungry2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Lazy lazy1 <span class="token operator">=</span> Lazy<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Lazy lazy2 <span class="token operator">=</span> Lazy<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lazy1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lazy1 <span class="token operator">==</span> lazy2<span class="token punctuation">)</span><span class="token punctuation">;</span>        DCL dcl1 <span class="token operator">=</span> DCL<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DCL dcl2 <span class="token operator">=</span> DCL<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dcl1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dcl1 <span class="token operator">==</span> dcl2<span class="token punctuation">)</span><span class="token punctuation">;</span>        InnerClass ic1 <span class="token operator">=</span> InnerClass<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InnerClass ic2 <span class="token operator">=</span> InnerClass<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ic1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ic1 <span class="token operator">==</span> ic2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Enum e1 <span class="token operator">=</span> Enum<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>        Enum e2 <span class="token operator">=</span> Enum<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>        e1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e1 <span class="token operator">==</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出为：</p><pre><code>饿汉式单例模式true懒汉式单例模式true双重校验锁单例模式true静态内部类单例模式true枚举式单例模式true</code></pre><ul><li>饿汉式</li><li>懒汉式</li><li>DCL 双重校验锁（进阶懒汉式）</li><li>静态内部类实现懒汉式（最推荐写法）</li><li>枚举方式（最安全、简洁写法）</li></ul><hr><h2 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h2><h3 id="1-代理模式简介"><a href="#1-代理模式简介" class="headerlink" title="1. 代理模式简介"></a>1. 代理模式简介</h3><ul><li>委托一个类作为另一个类的代理，将被代理类隐藏起来，<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。同时代理类可以有被代理类没有的方法，作为补充。</li><li>举例：房产中介。房东只要卖房，交给中介代理，中介可以带房客看房，给房子打广告等等，这些都是不需要房东去做的。<strong>但最终的卖房一定是房东来执行</strong>。</li><li>举例：经纪人。明星要接活动，交给经纪人代理，经纪人可以谈合作，谈价钱，打广告等等，这些都是不需要明星去做的。<strong>但最终的活动一定是明星来执行</strong>。</li><li>不管代理类中有多少方法，<strong>被代理类中要执行的方法一定是被代理类自己执行</strong>。</li><li>从例子中看，代理人就是帮被代理人处理其不想做的事，被代理人只做自己想做的。且代理人处理的是通用事务，对于多个被代理人都可以适用。</li><li>放到 Java 中看，被代理类是核心业务，代理类是可以被剥离出的辅助方法的集合，代理类可以代理不同的被代理类，为其提供方法的补充。典型案例就是 spring 的 AOP，基于动态代理实现。</li></ul><hr><h3 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h3><p>由程序员创建或由特定工具自动生成源代码，再对其编译。<strong>在程序运行前，代理类的 .class 文件就已经存在</strong>。</p><ul><li>业务接口：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 * 业务接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">business</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 业务1     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 业务2     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>被代理类：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 * 被代理类，需要实现业务接口 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Agent</span> <span class="token keyword">implements</span> <span class="token class-name">business</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被代理类执行核心业务1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被代理类执行核心业务2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>静态代理类：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 * 静态代理类，也需要实现业务接口 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticProxy</span> <span class="token keyword">implements</span> <span class="token class-name">business</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Agent agent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//还需要向代理类中注入被代理类，被代理类还可见</span>    <span class="token keyword">public</span> <span class="token function">StaticProxy</span><span class="token punctuation">(</span>Agent a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>agent <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//前置方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行前置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//后置方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行后置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//重写业务方法</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        agent<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        agent<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>主方法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//有参构造，被代理类对外界可见</span>        StaticProxy sp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Agent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre><code>代理类执行前置方法被代理类执行核心业务1代理类执行后置方法================代理类执行前置方法被代理类执行核心业务2代理类执行后置方法</code></pre><hr><p>上述方式被代理类需要注入，仍然对外界可见。将被代理类在代理类内部创建，就可以使<strong>被代理类对外界透明（不可见）</strong>。</p><ul><li>代理类：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticProxy</span> <span class="token keyword">implements</span> <span class="token class-name">business</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//令被代理类在代理类内部创建，外界不可见</span>    <span class="token keyword">private</span> Agent agent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Agent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//无参构造</span>    <span class="token keyword">public</span> <span class="token function">StaticProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行前置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行后置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        agent<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        agent<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>主方法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//无参构造，被代理类不可见</span>        StaticProxy sp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h3><p>动态代理的代理类是动态生成的，不是由程序员写好的。<strong>在程序运行时，代理类的 .class 文件才被创建</strong>。</p><p>Spring 的 AOP 就是基于动态代理实现的。根据是否有接口，动态代理可以分为两类：</p><ul><li>基于接口的动态代理：由 JDK 提供的 Proxy 类实现。</li><li>基于类的动态代理：由 cglib 实现。</li></ul><hr><h3 id="4-基于-Proxy-的动态代理"><a href="#4-基于-Proxy-的动态代理" class="headerlink" title="4. 基于 Proxy 的动态代理"></a>4. 基于 Proxy 的动态代理</h3><blockquote><p>基于 Proxy 的动态代理，<strong>其被代理类必须实现某个接口</strong>。</p></blockquote><p>主要使用的类和接口：</p><ul><li><strong>InvocationHandler</strong>：函数式接口，其中只有一个方法 <code>invoke()</code>。<code>invoke()</code> 方法返回值为一个 Object 类，共有三个参数：<ol><li>Object proxy：调用该方法的代理实例，即<strong>动态代理实例</strong>。</li><li>method：动态代理实例调用的方法。</li><li>Object[] args：method 方法的参数。</li></ol></li><li><strong>Proxy</strong>：代理类，主要方法为 <code>newProxyInstance()</code> ，该方法返回一个 Object 动态代理实例，需要用<strong>接口（不能是实现类）接收</strong>，该方法有三个参数：<ol><li>ClassLoader loader：可以传入被代理类的 ClassLoader ，也可以传入实现 InvocationHandler 接口的类的 ClassLoader。一般只要没有自己定义 ClassLoader，传入的都是 AppClassLoader。</li><li>interface：被代理类实现的接口。</li><li>InvocationHandler h：实现 InvocationHandler 类的实例对象。</li></ol></li></ul><hr><p>分步整理：</p><ol><li><strong>实现 InvocationHandler 接口</strong>。可以定义一个类，也可以用 lamda 表达式，重写其 <code>invoke()</code> 方法。<strong>最终动态代理实例调用的方法都会被拦截，转而执行 <code>invoke()</code> 方法</strong>。</li><li><strong>调用 Proxy 类的静态方法 <code>newProxyInstance()</code></strong>。将上一步实现 InvocationHandler 接口的实例，作为第三个参数传入。</li><li>接收 <code>newProxyInstance()</code> 方法的返回值，<strong>用接口接收</strong>，即为动态代理实例，可以通过这个实例调用（被代理类实现的）接口中的方法。</li></ol><hr><blockquote><p><strong>用类实现 InvocationHandler 接口</strong>：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//把被代理对象隐藏起来</span>    Agent agent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Agent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//向外界提供获得动态代理实例的方法，就是调用了Proxy类的静态方法newProxyInstance()</span>    <span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里传入的参数分别是：</span>        <span class="token comment" spellcheck="true">//1. 当前类，也就是InvocationHandler接口实现类的ClassLoader</span>        <span class="token comment" spellcheck="true">//2. 被代理类实现的接口</span>        <span class="token comment" spellcheck="true">//3. 当前类，也就是InvocationHandler接口实现类</span>        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>agent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//重写invoke方法，动态代理实例执行的所有方法都会被拦截，转而执行invoke方法，所以要实现的逻辑如添加前置方法和后置方法，都要在invoke中实现。</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截到"</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object obj <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>agent<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行前置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行后置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>主方法调用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//首先获得实现InvocationHandler接口类的实例，我们在这个类中提供了获得动态代理实例的方法</span>        DynamicProxy dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过dp获得动态代理实例，用接口business接收</span>        business proxy <span class="token operator">=</span> <span class="token punctuation">(</span>business<span class="token punctuation">)</span> dp<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过动态代理实例调用方法</span>        proxy<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-JAVA"><code class="language-JAVA">package 代理模式;import java.lang.reflect.Proxy;/** * @author 巨瑞康 */public class Test {    public static void main(String[] args) {        //首先获得实现InvocationHandler接口类的实例        DynamicProxy dp = new DynamicProxy();        //当然获得动态代理实例也可以不封装在DynamicProxy类中，而在主函数中写        //先获得被代理类的实例        Agent agent = new Agent();        //调用Proxy类的静态方法newProxyInstance()，这里传入的参数分别是：        //1. Agent类，也就是被代理类的ClassLoader        //2. 被代理类实现的接口        //3. InvocationHandler接口实现类的实例对象        business proxy2 = (business) Proxy.newProxyInstance(agent.getClass().getClassLoader(),agent.getClass().getInterfaces(),new DynamicProxy());        //通过动态代理实例调用方法        proxy.doBusiness1();        System.out.println("================");        proxy.doBusiness2();    }}</code></pre><p>输出：</p><pre><code>拦截到doBusiness1方法代理类执行前置方法被代理类执行核心业务1代理类执行后置方法================拦截到doBusiness2方法代理类执行前置方法被代理类执行核心业务2代理类执行后置方法</code></pre><hr><blockquote><p><strong>用 lamda 表达式直接生成动态代理实例</strong></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//先获得被代理类的实例</span>        Agent agent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Agent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用Proxy类的静态方法newProxyInstance()，这里传入的参数分别是：</span>        <span class="token comment" spellcheck="true">//1. Agent类，也就是被代理类的ClassLoader</span>        <span class="token comment" spellcheck="true">//2. 被代理类实现的接口</span>        <span class="token comment" spellcheck="true">//3. InvocationHandler接口的lamda表达式，这里传入的args1是为了避免与mian函数的args冲突</span>        business proxy0 <span class="token operator">=</span> <span class="token punctuation">(</span>business<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>agent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> agent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args1<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//由于是lamda表达式，只能重写invoke方法，所以前置和后置方法需要在当前类中定义</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截到"</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object obj <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>agent<span class="token punctuation">,</span> args1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//前置方法需要在当前类中定义，并且用static修饰让主方法看到</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行前置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//后置方法需要在当前类中定义，并且用static修饰让主方法看到</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理类执行后置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>拦截到doBusiness1方法代理类执行前置方法被代理类执行核心业务1代理类执行后置方法================拦截到doBusiness2方法代理类执行前置方法被代理类执行核心业务2代理类执行后置方法</code></pre><hr><h3 id="5-基于-cglib-的动态代理"><a href="#5-基于-cglib-的动态代理" class="headerlink" title="5. 基于 cglib 的动态代理"></a>5. 基于 cglib 的动态代理</h3><blockquote><p>基于 cglib 的动态代理，<strong>其被代理类不需要实现接口</strong></p></blockquote><ol><li>其原理是生成了一个子类，去继承被代理类，从而进行代理。</li><li>缺点：由于继承的局限性，<strong>被 final 修饰的类不能被代理，被代理类中的被 final 修饰的方法不能被重写</strong>。</li><li>导包：不使用 Spring 或 maven，只是测试使用的话，需要手动导入 cglib 的 jar 包。而 cglib.jar 会依赖一些其他的包如 asm 包，没有导入的话会报错，这两个包之间的版本不匹配也会报错，所以不建议使用。<strong>最好的方法是使用 cglib-nodep 包</strong>，不需要依赖，直接就可以使用，我使用的是 cglib-nodep-3.3.0.jar。</li></ol><hr><p>主要使用的类和接口：</p><ul><li><strong>MethodInterceptor</strong>：拦截器接口，类似 JDK 中的 InvocationHandler。实现这个接口，重写其中的 <code>intercept()</code> 方法。<code>intercept()</code> 方法返回值为一个 Object 类，共有四个参数：<ol><li>Object o：cglib 生成的代理类对象。</li><li>Method method：被拦截的被代理类的方法。</li><li>Object[] objects：方法的参数。</li><li>MethodProxy methodProxy：代理方法。</li></ol></li><li><strong>Enhancer</strong>：提供生成代理类对象的方法。有三个必要的方法：<ul><li>setSuperClass：设置 enhancer 对象的父类，参数类型是 .class。</li><li>setCallback：设置回调对象，参数类型是拦截器接口的实现类对象。</li><li>create：生成代理类实例对象，需要<strong>用被代理类接收</strong>。</li></ul></li></ul><hr><blockquote><p><strong>实现 MethodInterceptor 接口</strong></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里是通过代理方法去调用父类的方法执行</span>        Object object <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span>objects<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cglib代理类执行前置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cglib代理类执行后置方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>主方法内生成代理类</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获得一个Enhancer对象</span>        Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//给enhancer对象设置父类，这里不需要父类的对象，直接用类名.class即可</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>Agent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//给enhancer对象设置回调对象，即自定义拦截器</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//利用enhancer对象生成代理实例对象，用父类接收</span>        Agent cglib <span class="token operator">=</span> <span class="token punctuation">(</span>Agent<span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过代理实例调用方法</span>        cglib<span class="token punctuation">.</span><span class="token function">doBusiness1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cglib<span class="token punctuation">.</span><span class="token function">doBusiness2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>cglib代理类执行前置方法被代理类执行核心业务1cglib代理类执行后置方法================cglib代理类执行前置方法被代理类执行核心业务2cglib代理类执行后置方法</code></pre><hr><h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><h3 id="1-工厂模式简介"><a href="#1-工厂模式简介" class="headerlink" title="1. 工厂模式简介"></a>1. 工厂模式简介</h3><blockquote><p><strong>工厂模式的作用</strong></p></blockquote><ol><li>工厂模式最主要的作用就是<strong>解耦</strong>，当一个类需要另一个类的实例对象时，不需要显式的 new 一个对象，而是通过工厂进行生产，直接从工厂中获得，这样就减少了两个类之间的耦合性。</li><li>当需求改变时，不用修改代码，只要从工厂中取需要的实例对象即可。</li></ol><blockquote><p><strong>工厂模式的分类</strong></p></blockquote><ol><li>简单/静态工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ol><hr><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h3><blockquote><p><strong>简介</strong></p></blockquote><p>已知一些类，创建一个工厂，通过接收参数判断是这些类中的哪一个，然后创建出对应的实例对象。</p><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1419489-20190628144601084-563759643.png" alt=""></p><blockquote><p><strong>代码实现</strong></p></blockquote><ol><li>Product 目标为手机，因此至少需要准备三件事：手机接口，实现类小米手机和苹果手机。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 手机接口     */</span>    <span class="token keyword">void</span> <span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IPhone</span> <span class="token keyword">implements</span> <span class="token class-name">Phone</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一台苹果手机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">IPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产了一台苹果手机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MiPhone</span> <span class="token keyword">implements</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一台小米手机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MiPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产了一台小米手机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>就当前的两个手机类创建一个工厂</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhoneFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Phone <span class="token function">makePhone</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"MiPhone"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MiPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"iPhone"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MiPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>测试：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        PhoneFactory pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhoneFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone mi <span class="token operator">=</span> pf<span class="token punctuation">.</span><span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token string">"miphone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone apple <span class="token operator">=</span> pf<span class="token punctuation">.</span><span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token string">"iphone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mi<span class="token punctuation">.</span><span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        apple<span class="token punctuation">.</span><span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>生产了一台小米手机生产了一台小米手机这是一台小米手机这是一台小米手机</code></pre><hr><h3 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h3><blockquote><p><strong>简介</strong></p></blockquote><p>工厂方法模式是指建立一个抽象工厂，将生产产品的任务分配给具体的工厂实现类，每一个产品有一个对应的工厂。</p><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1419489-20190628154133368-906051111.png" alt=""></p><blockquote><p><strong>代码实现</strong></p></blockquote><ol><li>创建一个工厂类接口，并对不同的产品创建不同的工厂类。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象工厂     */</span>    Phone <span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MiFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Phone <span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MiPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppleFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Phone <span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>测试：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractFactory miFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MiFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractFactory appleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AppleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone mi <span class="token operator">=</span> miFactory<span class="token punctuation">.</span><span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone apple <span class="token operator">=</span> appleFactory<span class="token punctuation">.</span><span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mi<span class="token punctuation">.</span><span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        apple<span class="token punctuation">.</span><span class="token function">thisPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>生产了一台小米手机生产了一台苹果手机这是一台小米手机这是一台苹果手机</code></pre><hr><h3 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h3><blockquote><p><strong>简介</strong></p></blockquote><p>抽象工厂模式通过在抽象工厂中增加创建产品的接口，并在子工厂中实现新产品的创建，达到一个工厂生产多种产品的效果。</p><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1419489-20190628170705865-1781414242.png" alt=""></p><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1419489-20190628164001258-637961514.png" alt=""></p><blockquote><p><strong>代码实现</strong></p></blockquote><ol><li>创建电脑接口，实现类小米电脑和苹果电脑。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Computer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 电脑接口     */</span>    <span class="token keyword">void</span> <span class="token function">thisComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MiComputer</span> <span class="token keyword">implements</span> <span class="token class-name">Computer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">thisComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一台小米电脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MiComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产了一台小米电脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mac</span> <span class="token keyword">implements</span> <span class="token class-name">Computer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">thisComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是一台苹果电脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Mac</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产了一台苹果电脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>重写抽象工厂和两个实现类工厂。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象工厂     */</span>    Phone <span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Computer <span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MiFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Phone <span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MiPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Computer <span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MiComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppleFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Phone <span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Computer <span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Mac</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>测试：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author 巨瑞康 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractFactory miFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MiFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractFactory appleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AppleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone miPhone <span class="token operator">=</span> miFactory<span class="token punctuation">.</span><span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone iphone <span class="token operator">=</span> appleFactory<span class="token punctuation">.</span><span class="token function">makePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Computer miComputer <span class="token operator">=</span> miFactory<span class="token punctuation">.</span><span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Computer mac <span class="token operator">=</span> appleFactory<span class="token punctuation">.</span><span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>生产了一台小米手机生产了一台苹果手机生产了一台小米电脑生产了一台苹果电脑</code></pre><hr><h3 id="5-三种模式对比"><a href="#5-三种模式对比" class="headerlink" title="5. 三种模式对比"></a>5. 三种模式对比</h3><ol><li>简单工厂模式：<ul><li>优点：一个工厂创建多种产品，代码量少，实现简单。</li><li>缺点：需求改变时，如增加一个华为手机，首先增加一个华为手机实现类，<strong>但需要改变工厂类中的代码（如增加判断是否是华为手机）。这点可以用反射来改善</strong>。</li></ul></li><li>工厂方法模式：<ul><li>优点：当需求改变时，如增加一个华为手机，只需要增加对应的类或工厂类，<strong>不需要改动已有的代码</strong>，易维护，增强系统的拓展性。</li><li>缺点：每有一个产品就需要一个对应的工厂类，代码量大。</li></ul></li><li>抽象方法模式：<ul><li>优点：多了一层抽象，将多个产品放在一个工厂中生产，减少了工厂的数量。</li><li>缺点：复杂，难于扩展。如需要生产平板，就要修改抽象工厂，修改每个工厂实现类。</li></ul></li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择题常用知识点</title>
      <link href="/2020/09/28/xuan-ze-ti-chang-yong-zhi-shi-dian/"/>
      <url>/2020/09/28/xuan-ze-ti-chang-yong-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="选择题常用知识点"><a href="#选择题常用知识点" class="headerlink" title="选择题常用知识点"></a>选择题常用知识点</h1><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h2><h3 id="1-度数和节点数的关系"><a href="#1-度数和节点数的关系" class="headerlink" title="1. 度数和节点数的关系"></a>1. 度数和节点数的关系</h3><ol><li><strong>深度为 k 的二叉树，最多有 2 ^ k - 1 个节点</strong>；</li><li>二叉树的节点<strong>有几个孩子度数就为几</strong>，分别用 n0，n1，n2 表示；</li><li><strong>n0 节点就是叶子节点</strong>；</li><li>度数为 0 的节点个数是度数为 2 的节点个数加一，即 <strong>n0 = n2 + 1</strong>；</li><li>完全二叉树是指叶子节点只在最后一层，并且先有左孩子再有右孩子的树。<strong>完全二叉树度为 1 的节点（n1 节点）只会是 0 个或 1 个</strong>；</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/08/25/java-ji-chu/"/>
      <url>/2020/08/25/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-Java基础概念与常识"><a href="#1-Java基础概念与常识" class="headerlink" title="1. Java基础概念与常识"></a>1. Java基础概念与常识</h2><h3 id="1-Java的三大特性"><a href="#1-Java的三大特性" class="headerlink" title="1. Java的三大特性"></a>1. Java的三大特性</h3><p><strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>。</p><p><strong>封装</strong>：隐藏具体的属性和细节，仅对外提供公共访问方式。如getter，setter。<strong>目的/好处</strong>：增强安全性，简化编程，便于使用。</p><p><strong>继承</strong>：将多个相同的属性和方法提取出来，新建一个父类。<strong>目的/好处</strong>：代码复用。</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法（重写）。</li></ol><p><strong>多态</strong>： 在声明时使用父类，在实现或调用时使用具体的子类 ，不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。<strong>目的/好处</strong>：提高代码的灵活性和拓展性。</p><ul><li>多态有两种表现形式，<strong>重载</strong>和<strong>重写</strong>。</li><li>重载：一个类中可以有多个同名的方法，但参数列表必须不同，这表现的是同一个类中方法的多态性。</li><li>重写：子类中可以定义父类中同名的方法，这表现的是父子类方法的多态性。</li></ul><table><thead><tr><th align="center">区别点</th><th align="center">重载方法</th><th align="center">重写方法</th></tr></thead><tbody><tr><td align="center">发生范围</td><td align="center">同一个类</td><td align="center">父子类</td></tr><tr><td align="center">参数列表</td><td align="center">必须修改</td><td align="center">不能修改</td></tr><tr><td align="center">返回类型</td><td align="center">可修改</td><td align="center">不能修改</td></tr><tr><td align="center">异常</td><td align="center">可修改</td><td align="center">可以减少或删除，不能抛出新的或者更广的异常</td></tr><tr><td align="center">访问修饰符</td><td align="center">可修改</td><td align="center">不能做更严格的限制（可以降低限制）</td></tr><tr><td align="center">发生阶段</td><td align="center">编译期</td><td align="center">运行期</td></tr></tbody></table><hr><h3 id="2-JVM、JDK-和-JRE"><a href="#2-JVM、JDK-和-JRE" class="headerlink" title="2. JVM、JDK 和 JRE"></a>2. JVM、JDK 和 JRE</h3><ol><li><p>JVM：Java 虚拟机，是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和<strong>不同系统的 JVM</strong> 实现是 Java 语言“一次编译，随处运行”的关键所在。 </p></li><li><p>JDK：Java开发工具包，是功能齐全的 Java SDK，拥有 JRE 拥有的一切，此外还有编译器（javac）和工具（javadoc 和 jdb）。<strong>能够创建和编译程序</strong>。</p><ul><li>javadoc：它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。</li><li>jdb：调试器（Java Debugger），和 IDEA、Eclipse 等 IDE 中提供的调试功能共同依赖同一套调试 API，也就是 Java Platform Debugger Architecture (JPDA)。</li></ul></li><li><p>JRE：Java运行时环境，是运行已编译 Java 程序所需所有内容的集合，包括 JVM ，Java 类库。Java 命令等基础构件。但<strong>不能用于创建新程序</strong>。</p></li></ol><hr><h3 id="3-Java-和-C-的对比"><a href="#3-Java-和-C-的对比" class="headerlink" title="3. Java 和 C++ 的对比"></a>3. Java 和 C++ 的对比</h3><ol><li>两者都是面向对象的语言，都支持封装、继承和多态；</li><li>Java 不提供<strong>指针</strong>直接访问内存，程序内存更加安全。这里延伸出的一个问题是：<strong>Java中的引用和C++中的指针有什么区别？</strong></li><li>Java 中的类是单<strong>继承</strong>的，C++ 中可以多继承。但 Java 中的接口是可以多继承的。</li><li>Java 有<strong>内存管理机制</strong>，不需要程序员手动释放内存。</li><li>C/C++ 中，字符串或字符数组最后都会有一个额外字符 ‘/0’ 来表示结束。但 Java 中没有结束符这个概念。<a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">参考文章</a>。</li></ol><hr><h3 id="4-Java-语言“编译与解释并存”"><a href="#4-Java-语言“编译与解释并存”" class="headerlink" title="4. Java 语言“编译与解释并存”"></a>4. Java 语言“编译与解释并存”</h3><ol><li>理解：高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。 <strong>编译型先编译完再执行，解释型边解释边执行</strong>。</li><li>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。 </li></ol><hr><h2 id="2-Java-基础核心"><a href="#2-Java-基础核心" class="headerlink" title="2. Java 基础核心"></a>2. Java 基础核心</h2><h3 id="1-Java中的基本数据类型"><a href="#1-Java中的基本数据类型" class="headerlink" title="1. Java中的基本数据类型"></a>1. Java中的基本数据类型</h3><table><thead><tr><th align="center">数据类型</th><th align="center">关键字</th><th align="center">内存占用</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">byte</td><td align="center">1字节</td><td align="center">Byte</td></tr><tr><td align="center">短整型</td><td align="center">short</td><td align="center">2字节</td><td align="center">Short</td></tr><tr><td align="center">整形</td><td align="center">int</td><td align="center">4字节</td><td align="center">Integer</td></tr><tr><td align="center">长整形</td><td align="center">long</td><td align="center">8字节</td><td align="center">Long</td></tr><tr><td align="center">单精度浮点数</td><td align="center">float</td><td align="center">4字节</td><td align="center">Float</td></tr><tr><td align="center">双精度浮点数</td><td align="center">double</td><td align="center">8字节</td><td align="center">Double</td></tr><tr><td align="center">字符型</td><td align="center">char</td><td align="center">2字节</td><td align="center">Character</td></tr><tr><td align="center">布尔型</td><td align="center">boolean</td><td align="center">1字节</td><td align="center">Boolean</td></tr></tbody></table><ul><li>自动装箱与拆箱，详细内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a><ul><li><strong>装箱</strong>：将基本类型用它们对应的应用类型包装起来；</li><li><strong>拆箱</strong>：将包装类转换为基本类型。</li></ul></li></ul><hr><h3 id="2-包装类和常量池"><a href="#2-包装类和常量池" class="headerlink" title="2. 包装类和常量池"></a>2. 包装类和常量池</h3><p>Java 中大部分基础类型的包装类都实现了<strong>常量池技术</strong>：</p><ol><li><strong>Byte、Short、Integer、Long</strong> 默认创建了数值 [-128,127] 的相应类型的缓存数据；</li><li><strong>Character</strong> 创建了数值在 [0,127] 范围的缓存数据；</li><li><strong>Boolean</strong> 直接返回 true or false；</li></ol><ul><li>如果数值<strong>不属于</strong>缓存的范围，会创建新的对象。</li><li>两种浮点类型的包装类 <strong>Float</strong> 和 <strong>Double</strong> 没有实现常量池技术。</li><li><code>Integer i1 = 40</code>；Java 在编译的时候会直接将代码封装成 <code>Integer i1=Integer.valueOf(40);</code>，从而使用常量池中的对象。 </li><li><code>Integer i1 = new Integer(40);</code> 这种情况下会创建新的对象。 </li></ul><pre class=" language-java"><code class="language-java">  Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Integer i4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Integer i5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Integer i6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2+i3   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 <span class="token operator">+</span> i3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i4   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"40=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">i1<span class="token operator">=</span>i2   <span class="token boolean">true</span>i1<span class="token operator">=</span>i2<span class="token operator">+</span>i3   <span class="token boolean">true</span>i1<span class="token operator">=</span>i4   <span class="token boolean">false</span>i4<span class="token operator">=</span>i5   <span class="token boolean">false</span>i4<span class="token operator">=</span>i5<span class="token operator">+</span>i6   <span class="token boolean">true</span><span class="token number">40</span><span class="token operator">=</span>i5<span class="token operator">+</span>i6   <span class="token boolean">true</span></code></pre><ul><li><strong>装箱和拆箱的理解</strong>：语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。 </li></ul><hr><h3 id="3-字符型常量和字符串常量的区别"><a href="#3-字符型常量和字符串常量的区别" class="headerlink" title="3. 字符型常量和字符串常量的区别"></a>3. 字符型常量和字符串常量的区别</h3><ol><li>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干字符。</li><li>含义上：字符常量相当于一个整型值（ASCII），可以参加表达式运算；字符串常量代表一个地址值（内存中的位置）。</li><li>占内存大小：字符常量占 2 字节，字符串常量占若干字节。注意：<strong>char 在其他语言中占 1 字节居多，但在 Java 中占 2 字节</strong>。</li></ol><hr><h3 id="4-Java-泛型，类型擦除"><a href="#4-Java-泛型，类型擦除" class="headerlink" title="4. Java 泛型，类型擦除"></a>4. Java 泛型，类型擦除</h3><ul><li><p>泛型提供了编译时<strong>类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。 </p></li><li><p><strong>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。</strong><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">Java 泛型类型擦除</a></p></li><li><p>泛型一般有三种使用方式：<strong>泛型类</strong>、<strong>泛型接口</strong>和<strong>泛型方法</strong>。</p><ol><li><strong>泛型类</strong></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><span class="token comment" spellcheck="true">//在实例化泛型类时，必须指定T的具体类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>     <span class="token keyword">private</span> T key<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Generic</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实例化泛型类（<strong>类似 List 等类</strong>）：</p><pre class=" language-java"><code class="language-java">Generic<span class="token operator">&lt;</span>Integer<span class="token operator">></span> genericInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generic</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><strong>泛型接口</strong></li></ol><ul><li>实现泛型接口时，可以不指定类型，也可以指定类型。</li></ul><ol start="3"><li><strong>泛型方法</strong></li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span> E <span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray <span class="token punctuation">)</span>   <span class="token punctuation">{</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span> E element <span class="token operator">:</span> inputArray <span class="token punctuation">)</span><span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"%s "</span><span class="token punctuation">,</span> element <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这是一个打印数组的方法，可以处理各种类型的数组。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//基本数据类型的数组必须是包装类，如Integer、Double</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> stringArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printArray</span><span class="token punctuation">(</span>stringArray<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="4"><li><p><strong>泛型常用通配符</strong></p><ol><li>？ 表示不确定类型；</li><li>T   表示一个具体的类型；</li><li>K V 表示键值中的 key value；</li><li>E   表示 element。</li></ol><ul><li>更多内容查看：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">聊一聊Java泛型中的通配符</a></li></ul></li></ol></li></ul><hr><h3 id="5-static关键字"><a href="#5-static关键字" class="headerlink" title="5. static关键字"></a>5. static关键字</h3><ul><li>意思是静态的、全局的，被修饰内容在一定范围内是<strong>共享的</strong>，谁都可以访问，此时需要注意<strong>并发</strong>读写的问题。</li></ul><ol><li><p><strong>修饰的对象</strong></p><ul><li>static 只能修饰<strong>类变量、方法和方法块</strong>。</li></ul><ol><li><p>当 static 修饰<strong>类变量</strong>时，如果该变量是 public 修饰，表示该变量任何类都可以访问，而且无需初始化类，直接使用<strong>类名.static变量</strong>这种形式访问即可。</p><ul><li>当 static 修饰<strong>类变量</strong>时， 需要注意<strong>线程</strong>安全问题，有两种解决方法，一是使用线程安全的数据结构，如用 <code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code> 。二是每次访问时手动加锁。</li></ul></li><li><p>当 static 修饰<strong>方法</strong>时，代表该方法和类对象是无关的，任意类都可以访问（权限public）。</p><ul><li>当 static 修饰<strong>方法</strong>时，该方法只能调用被 static 修饰的方法，不能调用其他方法。</li><li>当 static 修饰<strong>方法</strong>时，该方法内部的变量在执行时是<strong>没有</strong>线程安全的问题的。方法执行时，数据运行在<strong>栈</strong>里，栈的数据每个线程都是隔离开的，所有不会有线程安全的问题。</li></ul></li><li><p>当 static 修饰<strong>方法块</strong>时，叫做静态代码块，常常用在类启动之前，进行初始化。需要<strong>注意</strong>的是，静态代码块只能调用被 static 修饰的变量，并且要写在前面，否则会报错。</p></li></ol></li><li><p><strong>初始化的时机</strong></p><ol><li><strong>父类</strong>的静态变量和静态代码块比子类优先初始化；</li><li>一个类中，<strong>静态变量</strong>和静态代码块比构造器先初始化。</li></ol><ul><li>类中被 static 修饰的<strong>方法</strong>，在类初始化的时候<strong>不会初始化</strong>，只有当被调用时，才会被执行。</li></ul></li></ol><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super" target="_blank" rel="noopener">更多关键字内容参考</a>。</li></ul><hr><h3 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h3><ol><li>被 final 修饰的类，表明该类无法继承；</li><li>被 final 修饰的方法，表明该方法无法覆盖重写；</li><li>被 final 修饰的变量，表明该变量的内存地址无法改变，并且在声明时必须完成初始化。</li></ol><ul><li>被 final 修饰的变量，并不是不可以修改其值，对于 List 和 Map 这种集合类，被 final 修饰后，其<strong>内部值</strong>是可以修改的，但<strong>内存地址</strong>不可以修改。</li></ul><hr><h3 id="7-volatile关键字"><a href="#7-volatile关键字" class="headerlink" title="7. volatile关键字"></a>7. volatile关键字</h3><ul><li>volatile 的意思是可见的，常用来修饰某个<strong>共享变量</strong>，作用是当共享变量被修改后，会及时将变化通知到其他线程。</li></ul><p>我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU <strong>缓存</strong>打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。</p><p>这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。</p><p>这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。</p><p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。</p><hr><h3 id="8-default关键字"><a href="#8-default关键字" class="headerlink" title="8. default关键字"></a>8. default关键字</h3><ul><li>default 关键字一般用在接口的方法上，表明对于该方法，子类无需覆盖重写，但接口中必须有默认实现。</li></ul><hr><h3 id="9-Java-中的值传递"><a href="#9-Java-中的值传递" class="headerlink" title="9. Java 中的值传递"></a>9. Java 中的值传递</h3><ul><li><strong>按值调用(call by value)</strong>表示方法接收的是调用者提供的<strong>值</strong>，而<strong>按引用调用（call by reference)</strong>表示方法接收的是调用者提供的<strong>变量地址</strong>。</li><li><strong>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值</strong>。</li><li><strong>Java 程序设计语言总是采用按值调用</strong>。也就是说，<strong>方法得到的是所有参数值的一个拷贝</strong>。</li></ul><p>例1：<strong>基础类型</strong>的参数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num1 = "</span> <span class="token operator">+</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num2 = "</span> <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> <span class="token number">20</span>b <span class="token operator">=</span> <span class="token number">10</span>num1 <span class="token operator">=</span> <span class="token number">10</span>num2 <span class="token operator">=</span> <span class="token number">20</span></code></pre><ul><li><strong>基础类型的参数按值传递，拷贝得到的就是变量的值，原变量的值不能被修改</strong>。</li></ul><p>例2：<strong>对象</strong>作为参数，交换对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小张"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Student s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小李"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Test<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Student x<span class="token punctuation">,</span> Student y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Student temp <span class="token operator">=</span> x<span class="token punctuation">;</span>    x <span class="token operator">=</span> y<span class="token punctuation">;</span>    y <span class="token operator">=</span> temp<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x:"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"y:"</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">x<span class="token operator">:</span>小李y<span class="token operator">:</span>小张s1<span class="token operator">:</span>小张s2<span class="token operator">:</span>小李</code></pre><ul><li><strong>对象类型</strong>的参数按值传递，但要注意的是，<strong>对象类型的值就是对象的地址值，因此拷贝得到的对象与原对象指向同一个地址</strong>。</li><li><strong>本例中进行交换操作，只是对拷贝的对象进行交换，并不会影响到原对象。但如果对拷贝的对象进行修改内容的操作，则会对原对象造成影响。</strong></li></ul><p>例3：<strong>对象</strong>作为参数，修改对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小张"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Student s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小李"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Student x<span class="token punctuation">,</span> Student y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String temp <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    x<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    y<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x:"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"y:"</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">原s1<span class="token operator">:</span>小张原s2<span class="token operator">:</span>小李x<span class="token operator">:</span>小李y<span class="token operator">:</span>小张新s1<span class="token operator">:</span>小李新s2<span class="token operator">:</span>小张</code></pre><ul><li><strong>本例中对拷贝的对象进行交换内容的操作，导致原对象内容也发生了改变</strong>。</li></ul><hr><h3 id="10-深拷贝和浅拷贝"><a href="#10-深拷贝和浅拷贝" class="headerlink" title="10. 深拷贝和浅拷贝"></a>10. 深拷贝和浅拷贝</h3><ol><li><strong>浅拷贝</strong>：对于引用数据类型进行引用传递的拷贝，称为浅拷贝。<strong>修改拷贝对象的内容，原对象也会发生改变</strong>。</li><li><strong>深拷贝</strong>：对于引用数据类型，创建一个新的对象，并复制其内容，称为深拷贝。<strong>修改拷贝对象的内容，原对象不会发生改变</strong>。</li></ol><ul><li><strong>基本数据类型始终都是值传递</strong>。</li></ul><hr><h3 id="11-异常"><a href="#11-异常" class="headerlink" title="11. 异常"></a>11. 异常</h3><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p><ul><li><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual Machine Error），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 </li><li><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。 </li><li><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong> </li></ul><hr><h3 id="12-thy-catch-finally"><a href="#12-thy-catch-finally" class="headerlink" title="12. thy-catch-finally"></a>12. thy-catch-finally</h3><ul><li><strong>try块</strong>：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 </li><li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。 </li><li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。<strong>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行</strong>。</li></ul><p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p><ol><li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li><li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><ul><li><strong>注意</strong>：当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。 </li></ul><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/%E5%BC%82%E5%B8%B82.png" alt="异常层次图"></p><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/%E5%BC%82%E5%B8%B8.png" alt=""></p><hr><h3 id="13-I-O流"><a href="#13-I-O流" class="headerlink" title="13. I/O流"></a>13. I/O流</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 </p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/IO%E6%B5%811.png" alt=""></p><p><img src="01-Java%E5%9F%BA%E7%A1%80.assets/IO%E6%B5%812.png" alt=""></p><hr><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h2><h3 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1. 面向对象和面向过程"></a>1. 面向对象和面向过程</h3><ul><li><strong>面向过程</strong>：可以理解为一件复杂的事，分为几个步骤，一步一步去做。</li><li><strong>面向对象</strong>：可以理解为一件复杂的事，分为一个模块，分别找不同的人来做。</li><li>面向过程和面向对象的语言<strong>性能对比</strong>：</li></ul><p>Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p><hr><h3 id="2-构造器和构造方法"><a href="#2-构造器和构造方法" class="headerlink" title="2. 构造器和构造方法"></a>2. 构造器和构造方法</h3><ol><li>构造器 (Constructor) 不可以被重写 (override)，但可以被重载 (overload)，所以一个类中可以有多个构造函数。</li><li><strong>无参构造方法的作用</strong>：Java 中构造方法执行的顺序是<strong>先父类构造方法，再子类构造方法</strong>。如果在子类中，子类构造方法前没有用 <code>super</code> 来调用父类特定的构造方法，则会<strong>自动调用父类中的 “无参构造方法”</strong>。因此，如果父类中没有 “无参构造方法”，而子类中又没有用 <code>super</code> 来调用父类特定的构造方法，编译时就会发生错误。</li></ol><hr><h3 id="3-Java中抽象类和接口的区别"><a href="#3-Java中抽象类和接口的区别" class="headerlink" title="3. Java中抽象类和接口的区别"></a>3. Java中抽象类和接口的区别</h3><ol><li>抽象类用abstract修饰，接口用interface修饰；</li><li>抽象类只能被单继承，接口可以实现多个；</li><li>抽象类中可以有非抽象方法，接口中必须都是抽象方法；</li><li>接口中成员变量必须是public static final修饰，必须赋初值，实现类不能重新定义或修改。抽象类中的成员变量默认default，子类可以重新定义或修改；</li><li>抽象类中允许有静态方法(static修饰)，接口中的方法不允许有静态方法。 </li></ol><hr><h3 id="4-Java中抽象类和普通类的区别"><a href="#4-Java中抽象类和普通类的区别" class="headerlink" title="4. Java中抽象类和普通类的区别"></a>4. Java中抽象类和普通类的区别</h3><ol><li>抽象类中有抽象方法，普通类中没有；</li><li>抽象类中可以有构造方法，但不能实例化。普通类可以实例化；</li><li>抽象方法不能被声明为静态(static修饰)，普通类中的方法都可以被声明为静态；</li><li>抽象类的子类必须重写所有抽象方法，否则必须是抽象类。普通类的子类只需声明继承；</li></ol><hr><h3 id="5-成员变量和局部变量的区别"><a href="#5-成员变量和局部变量的区别" class="headerlink" title="5. 成员变量和局部变量的区别"></a>5. 成员变量和局部变量的区别</h3><ol><li>从语法形式上看：成员变量是定义在类中，方法外的，局部变量是定义于方法内的。成员变量可以被<strong>权限修饰符如 <code>public</code> <code>private</code> *<em>等修饰，而局部变量不可以。成员变量可以被 *</em><code>static</code> *<em>修饰，而局部变量不可以。但是两者都可以被 *</em><code>final</code></strong> 修饰。</li><li>从存储方式上看：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存</strong>，<strong>局部变量则存在于栈内存</strong>。 </li><li>从生存时间上看：成员变量是对象的一部分，它随着<strong>对象</strong>的创建而存在，而局部变量随着<strong>方法</strong>的调用而自动消失。 </li><li>初值：成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值，<strong>在使用前必须手动赋值</strong>。</li></ol><hr><h2 id="4-反射"><a href="#4-反射" class="headerlink" title="4. 反射"></a>4. 反射</h2><h3 id="1-反射简介"><a href="#1-反射简介" class="headerlink" title="1. 反射简介"></a>1. 反射简介</h3><blockquote><p><strong>框架设计的灵魂</strong></p></blockquote><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。<strong>将类的各个组成部分封装为一个个对象，这就是反射</strong>。</p><hr><h3 id="2-Class-类"><a href="#2-Class-类" class="headerlink" title="2. Class 类"></a>2. Class 类</h3><p>Class 类是一个特殊的类，<strong>它的实例表示正在运行的 Java 应用程序中的类和接口</strong>，也就是说 JVM 中有实例对象的类都有一个 Class 对象。</p><p>Class 没有公共构造方法。<strong>Class 对象是在加载类时由 Java 虚拟机自动构造的</strong>。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。 <strong>这里与类加载过程相关</strong>。</p><p>类加载过程中，类加载器会将 <strong>.class 文件</strong>中的内容读取进内存，<strong>整体封装为一个 Class 对象</strong>。同时，抽取出<strong>成员变量封装为 Field 对象，构造方法封装为 Constructor 对象，成员方法封装为 Method 对象，并在 Class 对象中以数组形式保存</strong>。</p><hr><h3 id="3-获取-Class-类对象的三种方式"><a href="#3-获取-Class-类对象的三种方式" class="headerlink" title="3. 获取 Class 类对象的三种方式"></a>3. 获取 Class 类对象的三种方式</h3><p>根据 Java 代码经历的三个阶段，有三种不同的方式获取 Class 对象：</p><ol><li><strong>还未进行类加载</strong>，只是 .class 文件时：<strong><code>Class.forName(String className)</code> 方法</strong>，其中参数是全类名（包名+类名）。将字节码文件加载进内存，返回 Class 对象。<ul><li>多用于<strong>配置文件</strong>，将类名定义在配置文件中，读取文件加载类。</li></ul></li><li><strong>已经加载经内存，但还未创建对象</strong>：类名.class 方法，通过类名的属性 class 获取。<ul><li>多用于<strong>传入参数</strong>。</li></ul></li><li><strong>已经创建了对象</strong>：<code>对象.getClass()</code> 方法。这是定义在 Object 类中的方法。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. Class.forName(String className)</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span>    Class <span class="token class-name">stuClass1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"fanshe.Student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//可能会报错，检查包名或类名写的是否正确</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2. 类名.class方法</span>Class <span class="token class-name">stuClass2</span> <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3. 对象.getClass()方法</span><span class="token comment" spellcheck="true">//这一new产生一个Student对象，一个Class对象（类加载机制）。</span>Student stu1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class <span class="token class-name">stuClass</span> <span class="token operator">=</span> stu1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="4-Class-对象获取成员变量等对象的方法"><a href="#4-Class-对象获取成员变量等对象的方法" class="headerlink" title="4. Class 对象获取成员变量等对象的方法"></a>4. Class 对象获取成员变量等对象的方法</h3><ol><li>获取成员变量们<ul><li><code>Field[] getFields()</code> ：获取所有 <strong>public 修饰</strong>的成员变量；</li><li><code>Field getField(String name)</code>   获取指定名称的 public 修饰的成员变量；</li><li><code>Field[] getDeclaredFields()</code>  获取所有的成员变量，<strong>不考虑修饰符</strong>。私有方法是对外不可见的，但在反射前可以使用<strong>暴力反射</strong>，忽略访问权限检查；</li><li><code>Field getDeclaredField(String name)</code></li></ul></li><li>获取构造方法们：<ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code>：public 修饰；</li><li><code>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</code>：这里的参数也要是 Class 对象。</li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>：所有构造方法，不考虑修饰符；</li><li><code>Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</code>  </li></ul></li><li>获取成员方法们：<ul><li><code>Method[] getMethods()</code>：public 修饰，<strong>获取所有方法时，也会获得父类中的方法</strong>；</li><li><code>Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</code> </li><li><code>Method[] getDeclaredMethods()</code>：所有构造方法，不考虑修饰符；</li><li><code>Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li></ul></li><li>获取全类名：<code>getName()</code>。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//0. 获取Class对象</span>Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1. 获取Field对象</span>Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2. 获取Constructor对象</span>Constructor con <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3. 获取Method对象</span><span class="token comment" spellcheck="true">//既要传入方法名，也要传入参数Class对象，因为可能有重载</span>Method methodEat <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>eat<span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4. 获取全类名（包名+类名）</span>String className <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="5-获取成员变量等对象的使用"><a href="#5-获取成员变量等对象的使用" class="headerlink" title="5. 获取成员变量等对象的使用"></a>5. 获取成员变量等对象的使用</h3><ol><li>成员变量的使用：<ul><li>设置值：<code>void set(Object obj, Object value)</code> ，<strong>需要传入一个实例，也就是要有一个 Person 对象</strong>。</li><li>获取值：<code>get(Object obj)</code>，同样需要传入实例。</li><li>忽略访问权限修饰符的安全检查：<code>setAccessible(true)</code>，暴力反射。</li></ul></li><li>构造方法们的使用：<ul><li>创建对象：<code>newInstance(Object... initargs参数)</code> ：需要构造方法的参数。</li><li>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法。</li></ul></li><li>成员方法们的使用：<ul><li>执行方法：<code>invoke(Object obj, Object... args)</code> ：需要一个实例和参数。</li><li>获取方法名称：<code>getName()</code>，获取方法名</li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//0. 准备一个Person对象</span>Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1. Field对象的使用</span>Field a <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object value <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2. Constructor对象的使用</span>Constructor con <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object person <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//空参可以用Class对象直接创建</span>Object person1 <span class="token operator">=</span> con1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object person2 <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3. Method对象的使用</span>Method methodEat <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>eat<span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>methodEat<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>“饭”<span class="token punctuation">)</span><span class="token punctuation">;</span>String methodName <span class="token operator">=</span> methodEat<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="6-反射的优势和应用场景"><a href="#6-反射的优势和应用场景" class="headerlink" title="6. 反射的优势和应用场景"></a>6. 反射的优势和应用场景</h3><ul><li>优势：<ol><li><strong>在程序运行过程中</strong>，获取和操作类的各个组成部分封装成的对象。</li><li><strong>解耦</strong>，提高程序的灵活性和可扩展性。动态编译可以最大程度的支持多态，而多态的最大意义又在于降低类的耦合性。例如：只要修改配置文件，而不用修改代码，或<strong>工厂设计模式</strong>。<ul><li><strong>如果不使用反射，每次增加一种水果，都要修改工厂类中的源码</strong>，而修改源码往往是一种非常危险的行为，也比较麻烦。</li><li><strong>如果使用反射，则不需要修改代码</strong>，直接在调用时输入新水果名称即可。</li></ul></li></ol></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">fruit</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">implements</span> <span class="token class-name">fruit</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">implements</span> <span class="token class-name">fruit</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//若不使用反射，工厂类为</span><span class="token keyword">class</span> <span class="token class-name">Factory</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> fruit <span class="token function">getInstance</span><span class="token punctuation">(</span>String fruitName<span class="token punctuation">)</span><span class="token punctuation">{</span>          fruit f<span class="token operator">=</span>null<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//每有一个新的水果，就要在工厂类中加一个if判断</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>fruitName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"Orange"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>fruitName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Orange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> f<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//若使用反射，工厂类为</span><span class="token keyword">class</span> <span class="token class-name">Factory</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> fruit <span class="token function">getInstance</span><span class="token punctuation">(</span>String ClassName<span class="token punctuation">)</span><span class="token punctuation">{</span>          fruit f<span class="token operator">=</span>null<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//这里使用的是Class类的方法，构造出的是空参</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>              f<span class="token operator">=</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>ClassName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>              e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> f<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">hello</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//这里的参数是全类名，提供给forName()方法</span>        <span class="token comment" spellcheck="true">//若是不使用反射，直接使用水果名即可</span>        fruit f<span class="token operator">=</span>Factory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"Reflect.Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>              f<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><ul><li>应用场景：<ol><li>JDBC 数据库连接；</li><li>Spring 的 IOC 和 AOP 都和反射有联系。</li></ol></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/08/25/jvm/"/>
      <url>/2020/08/25/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-内存区域"><a href="#1-内存区域" class="headerlink" title="1. 内存区域"></a>1. 内存区域</h2><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt=""></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" alt=""></p><hr><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>程序计数器是一块较小的内存空间，主要有两个作用：</p><ol><li>字节码解释器通过改变程序计数器的值来依次<strong>读取指令</strong>，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换后能够从之前的位置继续执行。</li><li><strong>注意</strong>：<strong>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡</strong>。</li></ol><hr><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><ol><li>虚拟机栈由一个个<strong>栈帧</strong>组成，描述的是 <strong>Java 方法执行的内存模型</strong>。</li><li>每个方法被执行的时候都会创建一个栈帧，用于<strong>存储局部变量表、操作栈、动态链接和方法出口等信息</strong>。执行 <code>return</code> 语句和抛出异常会使栈帧出栈。<strong>每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。</li><li><strong>局部变量表</strong>：一片连续的内存空间，用来存放<strong>方法参数</strong>，以及方法内定义的<strong>局部变量</strong>。存放着编译期间已知的数据类型(八大基本类型和<strong>对象引用-reference 类型</strong>，returnAddress 类型。 </li><li><strong>reference 类型</strong>：与基本类型不同的是它不等同本身，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄，或其他与该对象有关的位置。</li><li><strong>错误</strong>：Java 虚拟机栈可能出现两种类型的错误<ol><li>线程请求的栈深度大于虚拟机允许的栈深度，将发生 <strong>StackOverflowError</strong>。</li><li>若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存，发生 <strong>OutOfMemoryError</strong>。 </li></ol></li><li><strong>生命周期</strong>：Java 虚拟机栈也是<strong>线程私有</strong>的，它的<strong>生命周期和线程相同</strong>。</li></ol><p><img src="05-JVM.assets/10006199-728567b81e7abff5-1596702433480.webp" alt=""></p><hr><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><ol><li>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li><li>Native 方法：<strong>该方法的实现由非 Java 语言实现</strong>，可能底层调用的 C 或者 C++。</li><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li><li>方法执行完毕后相应的栈帧也会出栈并释放内存空间，<strong>也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误</strong>。</li></ol><hr><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><ol><li>Java 虚拟机所管理的内存中<strong>最大的一块</strong>，<strong>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建</strong>。</li><li>此内存区域的<strong>唯一目的</strong>就是<strong>存放对象实例</strong>，<strong>几乎所有的对象实例以及数组</strong>都在这里分配内存。</li><li>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</li><li>根据虚拟机规范，Java 堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。<strong>它的内存大小可以设为固定大小，也可以扩展</strong>。</li><li>如果堆中没有内存完成实例分配，而且堆无法扩展，将发生<strong>OutOfMemoryError</strong>（和内存无关，与配置的大小有关）。</li></ol><hr><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><ol><li>方法区与 Java 堆一样，是<strong>各个线程共享</strong>的内存区域。</li><li>方法区用于<strong>存储已被虚拟机加载的类信息</strong><ul><li>类的完整有效名，直接父类和修饰符。</li><li>方法信息，名称，修饰符，返回值类型，参数列表，方法字节码等等。</li><li>类加载器的引用。</li><li>Class 类对象的引用。</li><li>常量、静态变量，如 static 修饰的变量加载类的时候就被加载到方法区中。</li></ul></li><li><strong>运行时常量池存在于方法区</strong>，存放类加载后的各种常量和符号引用。</li><li>方法区是一个规定，类似于接口。<strong>永久代</strong>是实现方式，类似于实现了接口的类。JDK 1.8 以后，方法区被彻底移除，取而代之的是<strong>元空间</strong>（MetaSpace）。</li><li><strong>元空间</strong>：元空间使用<strong>直接内存</strong>，受本机可用内存的限制，溢出的几率更小，可以加载的类更多。</li></ol><hr><h2 id="2-虚拟机对象"><a href="#2-虚拟机对象" class="headerlink" title="2. 虚拟机对象"></a>2. 虚拟机对象</h2><h3 id="1-对象的创建过程"><a href="#1-对象的创建过程" class="headerlink" title="1. 对象的创建过程"></a>1. 对象的创建过程</h3><ol><li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，<strong>首先将去检查</strong>这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。<strong>如果没有，那必须先执行相应的类加载过程</strong>。</li><li><strong>分配内存</strong>：在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。分配方式有<strong>指针碰撞</strong>和<strong>空闲列表</strong>两种。</li><li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作<strong>保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头</strong>：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个<strong>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法</strong>：一般来说，执行 new 指令之后会接着执行 init 方法，<strong>把对象按照程序员的意愿进行初始化</strong>，这样一个真正可用的对象才算完全产生出来。</li></ol><hr><h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><ol><li><strong>对象头</strong>：对象头包括两部分信息，<strong>第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）</strong>。<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，<strong>虚拟机通过这个指针来确定这个对象是那个类的实例</strong>。</li><li><strong>实例数据</strong>：实例数据部分是<strong>对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容</strong>。</li><li><strong>对齐填充</strong>：仅仅<strong>起占位作用</strong>。虚拟机的自动内存管理系统要求对象起始地址<strong>必须是 8 字节的整数倍</strong>，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ol><hr><h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h3><p>Java 程序通过<strong>虚拟机栈上的 reference 数据（在局部变量表中）</strong>来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ol><li><strong>句柄</strong>：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，<strong>reference 中存储的就是对象的句柄地址，而句柄中储存了对象实例数据的地址和类型数据的地址</strong>。</li></ol><p><img src="05-JVM.assets/10006199-27ef5c978077ed1c.webp" alt=""></p><ol start="2"><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置对象实例数据，但类型数据跟句柄访问方式一样。</li></ol><p><img src="05-JVM.assets/10006199-6cefc46d23c2d549.webp" alt=""></p><p><strong>对比</strong>：</p><ul><li><strong>句柄访问</strong>时，reference 储存的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是常态）<strong>只需改变句柄中实例数据的指针，不需要改动引用 reference 本身</strong>。</li><li><strong>直接访问</strong>时，<strong>相比于句柄访问少了一次指针定位的开销时间</strong>，速度更快。</li></ul><hr><h2 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3. 垃圾回收"></a>3. 垃圾回收</h2><h3 id="1-分代和区域划分"><a href="#1-分代和区域划分" class="headerlink" title="1. 分代和区域划分"></a>1. 分代和区域划分</h3><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：<strong>新生代和老年代</strong>，再细致一点有：<strong>Eden 空间、From Survivor、To Survivor 空间（8:1:1）</strong>等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存</strong>。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt=""></p><hr><h3 id="2-对象分配的区域"><a href="#2-对象分配的区域" class="headerlink" title="2. 对象分配的区域"></a>2. 对象分配的区域</h3><ul><li>大多数情况下，<strong>对象在新生代中 Eden 区分配</strong>。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC（新生代 GC）。</li><li><strong>需要大量连续内存空间的大对象</strong>，比如字符串和数组，<strong>直接进入老年代</strong>，不在 Eden 区中分配。这是为了避免大对象在分配内存时，由于<strong>分配担保机制</strong>带来的复制而降低效率。</li></ul><hr><h3 id="3-判断对象死亡"><a href="#3-判断对象死亡" class="headerlink" title="3. 判断对象死亡"></a>3. 判断对象死亡</h3><p>判断对象是否死亡有两种算法：</p><ol><li><strong>引用计数法</strong>：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用的问题</strong>。 </li><li><strong>可达性分析算法</strong>：这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，<strong>若一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的</strong>。被判定为需要执行的对象将会<strong>被放在一个队列中进行第二次标记</strong>，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。可作为 GC Roots 的对象包括下面四种：<ul><li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，也就是平时所说的 Java 对象，存放在堆中；</li><li><strong>本地方法栈（Native方法）中引用的对象</strong>；</li><li><strong>方法区中类静态属性引用的对象</strong>，一般指被 static 修饰引用的对象，加载类时就加载到内存中；</li><li><strong>方法区中常量引用的对象</strong>。</li></ul></li></ol><hr><h3 id="4-引用与垃圾回收"><a href="#4-引用与垃圾回收" class="headerlink" title="4. 引用与垃圾回收"></a>4. 引用与垃圾回收</h3><p>Java 中将引用分为四种，分别为强引用、软引用、弱引用和虚引用。</p><ol><li><strong>强引用</strong>：我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。<strong>如果一个对象具有强引用，那么垃圾回收器绝不会回收它。当内存空间不足时，也不会回收</strong>。Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</li><li><strong>软引用</strong>：如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，就会回收该对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</li><li><strong>弱引用</strong>：如果一个对象只具有弱引用，在垃圾回收器线程发现时，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。 </li><li><strong>虚引用</strong>：顾名思义就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收</strong>。</li></ol><p>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><hr><h3 id="5-常量与类的回收"><a href="#5-常量与类的回收" class="headerlink" title="5. 常量与类的回收"></a>5. 常量与类的回收</h3><ol><li><p>判断常量是废弃常量：<strong>当前常量没有被任何对象引用</strong>，就说明该常量是废弃常量。假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p></li><li><p>判断类是无用类：判断类是无用类需要满足三个条件</p><ol><li>该类<strong>所有的实例都已经被回收</strong>，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <strong>ClassLoader 已经被回收</strong>。</li><li>该类对应的 <strong>java.lang.Class 对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ol><p>满足以上三个条件的类为无用类，<strong>可以被回收，但并不是一定会回收</strong>。</p></li></ol><hr><h3 id="6-垃圾收集算法"><a href="#6-垃圾收集算法" class="headerlink" title="6. 垃圾收集算法"></a>6. 垃圾收集算法</h3><ol><li><strong>标记-清除算法</strong>：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。这种算法带来的问题：<strong>空间问题（会产生大量不连续的碎片）</strong>，导致新的对象在分配时，寻找可用地址的效率变低（效率问题），甚至<strong>可能因为没有足够的连续内存，而触发一次垃圾回收</strong>。<img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpeg" alt=""></li><li><strong>复制算法</strong>：它<strong>将内存分为大小相同的两块（From Survivor 和 To Survivor），每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉</strong>。这样就使每次的内存回收都是对内存区间的一半进行回收。 <img src="05-JVM.assets/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png" alt=""><ul><li>优点：<strong>不会产生内存碎片</strong>，分配对象的空间时只要按顺序分配即可。</li><li>缺点：把能够使用的内存分为两份，<strong>每次最多只能使用一半内存</strong>，内存空间浪费大。同时<strong>当对象的存活率较高时，需要大量的复制移动操作，效率低</strong>。</li></ul></li><li><strong>标记-整理算法</strong>：首先标记出所有不需要回收的对象，<strong>让所有存活对象向一端移动，然后直接清理掉边界以外的内存</strong>。<img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/94057049.png" alt=""><ul><li>优点：不会造成内存碎片，也不用把内存分为两份，内存利用率高。</li><li>缺点：标记后需要移动存活对象，消耗大量时间。</li></ul></li><li><strong>分代收集算法</strong>：在<strong>新生代中，每次收集都会有大量对象死去，所以可以选择复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</strong>。</li></ol><hr><h3 id="7-新生代垃圾回收流程"><a href="#7-新生代垃圾回收流程" class="headerlink" title="7. 新生代垃圾回收流程"></a>7. 新生代垃圾回收流程</h3><ol><li>新生代垃圾回收算法采用复制算法，内存分为 <strong>Eden 空间、From Survivor、To Survivor 空间（8:1:1）</strong>，优先使用 Eden 区。</li><li>GC 开始前，对象只会存于 Eden 和 From Survivor 区域，<strong>To Survivor（保留空间）为空</strong>。</li><li>GC 进行时：<ul><li><strong>Eden 区所有存活的对象都被复制到 To Survivor区</strong>。</li><li>而 <strong>From Survivor 区</strong>仍存活的对象中，<strong>年龄值达到阈值，移到老年代，没有达到则复制到 To Survivor 区</strong>。</li><li>年龄阈值默认 15 是因为对象头中年龄占 4bit，新生代每熬过一次垃圾回收，年龄 +1，最高为 15。</li></ul></li><li>GC 结束后，From Survivor 区域为空，<strong>将 From Survivor 区域和 To Survivor 区域互换</strong>。</li></ol><hr><h3 id="8-分配担保"><a href="#8-分配担保" class="headerlink" title="8. 分配担保"></a>8. 分配担保</h3><ol><li><p><strong>什么是分配担保</strong>：</p><ol><li><p>在发生<strong>新生代垃圾回收</strong>前，虚拟机会检查<strong>老年代最大可用连续空间是否大于新生代所有对象的总空间</strong>。如果大于，则此次垃圾回收是安全的。</p></li><li><p>如果小于，<strong>虚拟机会查看是否允许担保失败</strong>，如果允许，则会检查老年代最大可用连续空间是否大于<strong>历次移动到老年代的对象的平均大小</strong>，如果大于，则尝试一次新生代垃圾回收（有风险），<strong>如果小于或不允许风险，改为进行一次老年代垃圾回收</strong>。</p></li></ol></li><li><p><strong>为什么要进行分配担保</strong>：是因为新生代采用<strong>复制收集算法</strong>，假如大量对象在 Minor GC 后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而 Survivor 空间是比较小的，这时就需要老年代进行分配担保，<strong>把 Survivor 无法容纳的对象放到老年代</strong>。</p></li><li><p><strong>大对象分配</strong>：当为大对象分配内存时，如果该对象在垃圾回收时不被回收掉，由于 Survivor 空间较小，大概率出现 Survivor 空间不够的情况，根据分配担保机制，则需要移动到老年代，为了省去复制移动的消耗，<strong>直接在老年代进行分配</strong>。</p></li></ol><hr><h3 id="9-垃圾收集器"><a href="#9-垃圾收集器" class="headerlink" title="9. 垃圾收集器"></a>9. 垃圾收集器</h3><p>如果说垃圾收集算法是内存回收的方法论，那垃圾收集器就是内存回收的具体实现。垃圾收集器可以分为五种：</p><ol><li><p><strong>Serial 收集器</strong>：针对<strong>新生代</strong>进行垃圾收集。Serial （串行）收集器是一个单线程收集器，<strong>采用复制算法，只会使用一条垃圾收集线程，并且在进行垃圾收集时会暂停其他所有工作线程</strong>，直至收集结束。</p><ul><li>优点：<strong>简单而高效</strong>，对于限定单核处理时，没有线程切换的开销。</li><li>缺点：<strong>Stop the World</strong>。会使其他线程停顿，影响用户体验。</li><li><strong>Serial Old 收集器是 Serial 收集器的老年代版本</strong>，采用标记整理算法，用途则是作为 CMS（Concurrent Mode Failure）失败时的备选方案。<br><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/46873026.png" alt=""></li></ul></li><li><p><strong>ParNew 收集器</strong>：针对<strong>新生代</strong>进行垃圾收集。是 Serial 收集器的多线程版本，<strong>除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法和回收策略等）和 Serial 收集器完全一样</strong>，和 Serial 共用了许多代码。在多核的情况下，多线程收集相对单线程效率更高，但也要 <strong>Stop the World</strong>。<br> <img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22018368.png" alt=""></p></li><li><p><strong>Parallel Scavenge 收集器</strong>：针对<strong>新生代</strong>进行垃圾收集。关注点是<strong>吞吐量</strong>，所谓吞吐量是 CPU 中用于运行用户代码的时间与 CPU 消耗总时间的比值。<strong>Parallel Old 收集器是其老年代版本</strong>。</p><ul><li><strong>和 ParNew 的对比</strong>：如 ParNew 等其他收集器，目标都是尽可能缩短 Stop the World 的时间，而 Parallel Scavenge 收集器的目标是达到一个<strong>可控的吞吐量</strong>。</li></ul></li><li><p><strong>CMS 收集器</strong>：Concurrent Mark Sweep 收集器是以回收停顿时间最短为目标的收集器，是 Hotspot 虚拟机第一款真正意义上的<strong>并发收集器，实现了垃圾收集线程和用户线程（基本上）同时工作</strong>。CMS 收集器是由<strong>标记-清除</strong>算法实现的，垃圾收集整个过程分为四步：初始标记、并发标记、重新标记和并发清除。<strong>优点是并发收集，低停顿，缺点是对 CPU 资源敏感、无法处理浮动垃圾和产生大量空间碎片</strong>。</p><ul><li>初始标记：仅仅标记与 GC Root 有直接关联的对象，速度快，但要 <strong>Stop the World</strong>。</li><li>并发标记：由 GC Root 开始进行 Tracing 的过程，这个过程可以<strong>和用户线程共同进行的</strong>。</li><li>重新标记：修正并发标记期间由于用户程序运行导致的标记变动。需要 <strong>Stop the World</strong>，时间比初始标记稍长，但远比并发标记时间短。</li><li>并发清除：清除没有被标记的对象。这个过程可以<strong>和用户线程共同进行的</strong>。</li><li><strong>Concurrent Mode Failure</strong>：由于 CMS 是和用户线程同时执行的，用户线程在执行过程中也可能产生垃圾，这部分垃圾叫<strong>浮动垃圾</strong>。为了保护用户线程有足够的空间运行，需要在内存中预留一块区域，如果这个区域不够，则会发生垃圾回收失败。这是就需要启动备选方案 <strong>Serial Old 收集器</strong>进行垃圾收集。</li></ul></li><li><p><strong>G1 收集器</strong>：Garbage First 垃圾优先收集器，面向服务器，主要针对配备多颗处理器和大容量内存的机器。<strong>以极高概率满足 GC 停顿时间的同时，还具备高吞吐量的特征</strong>。</p><ul><li><p>G1 弱化了分代的概念，将 Java 堆分为若干大小相同的 region，并且维护了一个优先列表，每次根据用户允许的时间，<strong>优先选择回收价值最大的 region</strong>。</p></li><li><p>用户可以规定在一个<strong>长度为 M 毫秒的时间片内，垃圾收集的时间不得超过 N 毫秒</strong>。</p></li><li><p>初始标记：仅仅标记与 GC Root 有直接关联的对象，速度快，但要 <strong>Stop the World</strong>。</p></li><li><p>并发标记：由 GC Root 开始进行 Tracing 的过程，这个过程可以<strong>和用户线程共同进行的</strong>。</p></li><li><p>最终标记：修正并发标记期间由于用户程序运行导致的标记变动。需要 <strong>Stop the World</strong>。</p></li><li><p>筛选回收：筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</p></li><li><p><strong>与 CMS 收集器相比，不会产生空间碎片，可以压缩空间（整体基于标记整理算法，局部基于复制算法实现），且可设定最大停顿时间</strong>。<br><img src="05-JVM.assets/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png" alt=""></p></li></ul></li></ol><hr><h2 id="4-类加载"><a href="#4-类加载" class="headerlink" title="4. 类加载"></a>4. 类加载</h2><h3 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1. 类加载过程"></a>1. 类加载过程</h3><p>首先，在代码编译后，就会生成 JVM 能够识别的二进制字节流文件（.class文件）。JVM 把这个文件加载到内存的过程，就是类加载过程。</p><p>类加载过程分为三步：<strong>加载-&gt;连接-&gt;初始化</strong>，其中，连接过程又可以分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt=""></p><hr><h3 id="2-加载"><a href="#2-加载" class="headerlink" title="2. 加载"></a>2. 加载</h3><p>这个加载是指类加载过程中的第一步，加载，需要使用到<strong>类加载器</strong>。在这个阶段，JVM 主要完成三件事：</p><ol><li>通过一个类的全类名（包名和类名）获取定义此类的二进制字节流文件（.class文件）。获取可以通过 jar 包和 war 包等方式；</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。虽为对象，但不在堆中，<strong>存放在方法区</strong>。</li></ol><ul><li><strong>数组类型不通过类加载器创建，由 JVM 直接创建</strong>。</li></ul><hr><h3 id="3-连接"><a href="#3-连接" class="headerlink" title="3. 连接"></a>3. 连接</h3><p>连接是类加载过程中的第二步，又可以分为三步：</p><ol><li><strong>验证</strong>：这一步主要是对 .class 文件的各个方面进行验证，<strong>验证类是否有正确的结构，类数据是否符合虚拟机的要求，程序语义是否合法，确保不会危害虚拟机安全</strong>。<ol><li>文件格式验证：验证二进制字节流文件是否符合文件格式规范；</li><li>元数据验证：对字节码文件进行语义分析，验证其信息符合 Java 语言规范；</li><li>字节码验证：验证程序语义是合法的，符合逻辑的；</li><li>符号引用验证：确保解析能正确执行。</li></ol></li><li><strong>准备</strong>：<strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<ol><li>这时进行分配内存的<strong>仅为静态变量（static）</strong>，不包括实例变量；</li><li><strong>没有被 final 修饰的变量赋默认的零值</strong>，到初始化阶段才会赋设定的值。被 final 修饰的变量直接赋设定的值。</li></ol></li><li><strong>解析</strong>：将二进制数据中的<strong>符号引用替换为直接引用</strong>。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ol><hr><h3 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h3><p>初始化阶段是执行类构造器中 <code>&lt;clinit&gt;()</code> 方法的过程。主要工作是<strong>为静态变量赋设定的初值</strong>。</p><p>Java 虚拟机规范中规定了有且只有 5 中情况下，<strong>必须对类进行初始化</strong>：</p><ol><li>使用 new 关键字创建实例，使用 <code>getstatic()</code> <code>putstatic()</code> 访问或设置一个静态变量，使用 <code>invokestatic()</code> 调用一个静态方法时，对应类必须经过初始化。</li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时，如果类没有初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类没有经过初始化，则触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。</li><li>当一个接口中定义了默认方法（default修饰，JDK 1.8 加入），有该接口的实现类发生了初始化，则该接口要在其之前被初始化。</li></ol><hr><h3 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5. 卸载"></a>5. 卸载</h3><p>加载后的类再被使用之后，需要进行卸载。卸载一个类需要满足三个要求：</p><ol><li>该类所有对象都被回收；</li><li>该类没有在其他任何地方被引用；</li><li><strong>该类的类加载器实例被回收</strong>。</li></ol><ul><li>注意：由 JVM 自带的类加载器加载的类是不会被卸载的，但是由我们自定义的类加载器加载的类是可能被卸载的。 </li></ul><hr><h3 id="6-类加载器"><a href="#6-类加载器" class="headerlink" title="6. 类加载器"></a>6. 类加载器</h3><p>JVM 中内置了三个重要的 ClassLoader：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><ul><li><strong>CustomClassLoader（用户类加载器）</strong>：除了 JVM 自带的类加载器，用户可以自定义类加载器，用于加载指定路径的 class 文件。继承 java.lang.ClassLoader。</li></ul><p><strong>判断两个类是不是同一个类</strong>需要满足三个条件：是否由同一个 class 文件加载，是否由同一个 JVM 加载，和是否由同一个类加载器加载。</p><hr><h3 id="7-双亲委派机制"><a href="#7-双亲委派机制" class="headerlink" title="7. 双亲委派机制"></a>7. 双亲委派机制</h3><p>当一个类需要进行类加载时：</p><ul><li>首先判断当前类是否被加载过，被加载过的类会直接返回；</li><li>如果没有，当前类不会尝试自己去加载这个类，而是把这个请求委派给父类去完成；</li><li>每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中；</li><li>当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。</li><li>当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。 </li></ul><p><img src="05-JVM.assets/7634245-7b7882e1f4ea5d7d.webp" alt=""></p><hr><h3 id="8-双亲委派机制的作用"><a href="#8-双亲委派机制的作用" class="headerlink" title="8. 双亲委派机制的作用"></a>8. 双亲委派机制的作用</h3><ol><li><strong>防止重复加载</strong>。</li><li><strong>保证 JVM 中的核心类不被篡改</strong>。如 String 类，无论哪个加载器要加载这个类，由于双亲委派机制，最终都会交由最顶层的启动类加载器来加载，这样保证了 String 类在各种类加载器环境中，都是同一个类。如果没有双亲委派机制的话，各个加载器自己加载 String 类，就会加载出多个 String 类，使程序出现混乱。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2020/08/25/mysql/"/>
      <url>/2020/08/25/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-MySQL-基础"><a href="#1-MySQL-基础" class="headerlink" title="1. MySQL 基础"></a>1. MySQL 基础</h2><h3 id="1-SQL-分类"><a href="#1-SQL-分类" class="headerlink" title="1. SQL 分类"></a>1. SQL 分类</h3><p>SQL 可以分为两个部分：<strong>数据定义语言（DDL）和数据操作语言（DML）</strong>。</p><ul><li>DDL 部分的作用是<strong>创建/删除数据库或创建/删除表</strong>，也可以<strong>定义索引（键）</strong>，规定表之间的链接，以及施加表间的约束。重要的 DDL 语句有：<ul><li><em>CREATE DATABASE</em> - 创建新数据库</li><li><em>ALTER DATABASE</em> - 修改数据库</li><li><em>CREATE TABLE</em> - 创建新表</li><li><em>ALTER TABLE</em> - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li><em>CREATE INDEX</em> - 创建索引（搜索键）</li><li><em>DROP INDEX</em> - 删除索引</li></ul></li><li>DML 部分的作用是<strong>对表中的数据进行增删改查</strong>。重要的 DML 语句有：<ul><li><em>SELECT</em> - 从数据库表中获取数据</li><li><em>UPDATE</em> - 更新数据库表中的数据</li><li><em>DELETE</em> - 从数据库表中删除数据</li><li><em>INSERT INTO</em> - 向数据库表中插入数据</li></ul></li></ul><hr><h3 id="2-SQL-数据类型"><a href="#2-SQL-数据类型" class="headerlink" title="2. SQL 数据类型"></a>2. SQL 数据类型</h3><ul><li><strong>Text 数据类型</strong></li></ul><table><thead><tr><th align="center"></th><th align="center">使用方式</th></tr></thead><tbody><tr><td align="center">CHAR(size)</td><td align="center">保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。</td></tr><tr><td align="center">VARCHAR(size)</td><td align="center">保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。</td></tr><tr><td align="center">TINYTEXT</td><td align="center">存放最大长度为 255 个字符的字符串。</td></tr><tr><td align="center">TEXT</td><td align="center">存放最大长度为 65,535 个字符的字符串。</td></tr></tbody></table><ul><li><strong>Number 数据类型</strong></li></ul><table><thead><tr><th align="center">数据类型</th><th align="center">使用方式</th></tr></thead><tbody><tr><td align="center">TINYINT(size)</td><td align="center">-128 到 127 常规，0 到 255 无符号。在括号中规定最大位数。</td></tr><tr><td align="center">INT(size)</td><td align="center">-2147483648 到 2147483647 常规，0 到 4294967295 无符号。在括号中规定最大位数。</td></tr><tr><td align="center">FLOAT(size,d)</td><td align="center">带有浮动小数点的小数字，在括号中规定最大位数，在 d 参数中规定小数点右侧的最大位数。</td></tr><tr><td align="center">DOUBLE(size,d)</td><td align="center">带有浮动小数点的大数字，在括号中规定最大位数，在 d 参数中规定小数点右侧的最大位数。</td></tr><tr><td align="center">DECIMAL(size,d)</td><td align="center">作为字符串存储的 DOUBLE 类型，允许固定的小数点。</td></tr></tbody></table><ul><li><strong>Date 数据类型</strong></li></ul><table><thead><tr><th align="center">数据类型</th><th align="center">使用方式</th></tr></thead><tbody><tr><td align="center">DATE()</td><td align="center">日期。格式：YYYY-MM-DD，注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’</td></tr><tr><td align="center">DATETIME()</td><td align="center">日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS，注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td></tr><tr><td align="center">TIME()</td><td align="center">时间。格式：HH:MM:SS 注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’</td></tr><tr><td align="center">YEAR()</td><td align="center">2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</td></tr></tbody></table><hr><h3 id="3-DDL-语句的使用"><a href="#3-DDL-语句的使用" class="headerlink" title="3. DDL 语句的使用"></a>3. DDL 语句的使用</h3><ol><li><strong>CRUD 数据库</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--创建 C--</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> 数据库名<span class="token comment" spellcheck="true">--查询 R---</span><span class="token keyword">SHOW</span> <span class="token keyword">DATABASES</span> <span class="token comment" spellcheck="true">--修改 U--</span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> 数据库名 <span class="token keyword">character set</span> 字符集名称<span class="token comment" spellcheck="true">--删除 D--</span><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> 数据库名<span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> DB1<span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> DB1</code></pre><ol start="2"><li><strong>CRUD 表</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--创建 C--</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名称 <span class="token punctuation">(</span>列名称 列数据类型<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--查询 R---</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span> <span class="token comment" spellcheck="true">--修改 U--</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">character set</span> 字符集名称<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 列名 数据类型<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 CHANGE 列名 新列名 新数据类型<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> 列名<span class="token comment" spellcheck="true">--删除 D--</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> 表名称<span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>tbl<span class="token punctuation">`</span><span class="token punctuation">(</span>   <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> UNSIGNED <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>   <span class="token punctuation">`</span>title<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>   <span class="token punctuation">`</span>author<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>   <span class="token punctuation">`</span><span class="token keyword">date</span><span class="token punctuation">`</span> <span class="token keyword">DATE</span><span class="token punctuation">,</span>   <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> tb1</code></pre><hr><h3 id="4-DQL（DML-中-SELECT）语句"><a href="#4-DQL（DML-中-SELECT）语句" class="headerlink" title="4. DQL（DML 中 SELECT）语句"></a>4. DQL（DML 中 SELECT）语句</h3><ol><li>最基本的使用方法</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法--</span>    <span class="token keyword">select</span>        字段列表<span class="token operator">/</span>列名称    <span class="token keyword">from</span>        表名    <span class="token keyword">where</span>        条件列表    <span class="token keyword">group</span> <span class="token keyword">by</span>        分组字段    <span class="token keyword">having</span>        分组之后的条件    <span class="token keyword">order</span> <span class="token keyword">by</span>        排序    <span class="token keyword">limit</span>        分页限定<span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">SELECT</span> LastName<span class="token punctuation">,</span>FirstName <span class="token keyword">FROM</span> Persons</code></pre><ol start="2"><li><strong>DISTINCT 语句</strong></li></ol><p>在表中可能查出有重复值的答案，使用 DISTINCT 语句用于返回唯一不同的值。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法--</span><span class="token comment" spellcheck="true">--SELEC后多加一个DISTINCT</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 列名称 <span class="token keyword">FROM</span> 表名称<span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">SELECT</span> Company <span class="token keyword">FROM</span> Orders</code></pre><hr><ol start="3"><li><strong>WHERE 语句</strong></li></ol><p><strong>有条件的从表中选取数据</strong>，条件列表。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法--</span><span class="token keyword">SELECT</span> 列名称 <span class="token keyword">FROM</span> 表名称 <span class="token keyword">WHERE</span> 列 运算符 值<span class="token comment" spellcheck="true">--举例--</span><span class="token comment" spellcheck="true">--用单引号来环绕文本值，数值不要用引号--</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> City<span class="token operator">=</span><span class="token string">'Beijing'</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> Year<span class="token operator">></span><span class="token number">1965</span><span class="token comment" spellcheck="true">--BETWEEN区间左闭右开--</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> Year <span class="token operator">BETWEEN</span> <span class="token number">1965</span> <span class="token operator">AND</span> <span class="token number">2020</span><span class="token comment" spellcheck="true">--模糊查询：LIKE--</span><span class="token comment" spellcheck="true">--占位符：_ 表示单个任意字符；% 表示多个任意字符--</span><span class="token comment" spellcheck="true">-- 查询姓马的有哪些？</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'马%'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查询姓名第二个字是化的人</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">"_化%"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查询姓名是3个字的人</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'___'</span><span class="token punctuation">;</span></code></pre><hr><ol start="4"><li><strong>聚合函数</strong></li></ol><p>将一列数据作为一个整体，进行纵向的计算，<strong>聚合函数后可以起别名，后续的使用更加方便</strong>。</p><ol><li><code>count()</code>：计算个数</li><li><code>max()</code>：计算最大值</li><li><code>min()</code>：计算最小值</li><li><code>sum()</code>：计算和</li><li><code>avg()</code>：计算平均值</li></ol><ul><li>聚合函数的计算排除 null 值，一般情况下选择非空的列，如<strong>主键</strong>。也可以使用 <code>IFNULL()</code> 函数。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--计算个数--</span><span class="token comment" spellcheck="true">--使用主键--</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> STU<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--使用 IFNULL() 函数--</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>IFNULL<span class="token punctuation">(</span>Math<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> STU<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--计算最大值，并起别名，AS可以省略--</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span> <span class="token keyword">AS</span> 数学第一名 <span class="token keyword">FROM</span> STU<span class="token punctuation">;</span></code></pre><hr><ol start="5"><li><strong>GROUP BY 语句</strong></li></ol><p>分组查询：分组之后查询的字段，应该为 分组字段（其他字段没有意义） 聚合函数1 聚合函数2 …</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--按性别分组，计算每个性别的人数，和数学平均分。显示 sex count avg 三列--</span><span class="token keyword">SELECT</span> sex<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span> <span class="token keyword">FROM</span> STU <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sex<span class="token comment" spellcheck="true">--按性别分组，计算数学平均分，低于 70 分不参与计算--</span><span class="token keyword">SELECT</span> sex<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span> <span class="token keyword">FROM</span> STU <span class="token keyword">WHERE</span> Math<span class="token operator">></span><span class="token number">70</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sex</code></pre><hr><ol start="6"><li><strong>HAVING 语句</strong></li></ol><p>分组之后的条件，<strong>聚合函数后可以起别名，后续的使用更加方便</strong>。使用在 <code>GROUP BY</code> 之后：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--按性别分组，计算数学平均分，低于 70 分不参与计算，并且人数大于 2 才查询，小于 2 不查询--</span><span class="token keyword">SELECT</span> sex<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span> <span class="token keyword">FROM</span> STU <span class="token keyword">WHERE</span> Math<span class="token operator">></span><span class="token number">70</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sex <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span><span class="token comment" spellcheck="true">--用起别名的方式简化--</span><span class="token keyword">SELECT</span> sex<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">AS</span> 人数<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Math<span class="token punctuation">)</span> <span class="token keyword">FROM</span> STU <span class="token keyword">WHERE</span> Math<span class="token operator">></span><span class="token number">70</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sex <span class="token keyword">HAVING</span> 人数 <span class="token operator">></span> <span class="token number">2</span></code></pre><ul><li><code>WHERE</code> 和 <code>HAVING</code> 的区别：<ol><li><strong><code>WHERE</code> 在分组之前进行限定</strong>，如果不满足条件，则不参与分组。<strong><code>HAVING</code> 在分组之后进行限定</strong>，如果不满足结果，则不会被查询出来。</li><li><code>WHERE</code> 后不可以跟<strong>聚合函数</strong>，<code>HAVING</code> 可以进行聚合函数的判断。</li></ol></li></ul><hr><ol start="7"><li><strong>ORDER BY 语句</strong></li></ol><p><strong>ORDER BY 语句用于对结果集进行排序，默认按升序排序</strong>，如果希望按降序排序，可以使用 DESC 关键字。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">SELECT</span> Company<span class="token punctuation">,</span> Number <span class="token keyword">FROM</span> Table1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Number<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Table1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Math <span class="token keyword">ASC</span><span class="token punctuation">,</span> English <span class="token keyword">DESC</span></code></pre><hr><ol start="8"><li><strong>LIMIT 语句</strong></li></ol><ul><li><p>语法：<strong>LIMIT 开始的索引，每页查询的条数</strong>；</p></li><li><p>公式：<strong>开始的索引 = （当前页码 - 1）* 每页显示的条数</strong></p></li><li><p><strong>LIMIT 是 MySQL 特有的分页方式</strong>，其他数据库如 Oracle 不能使用。</p></li></ul><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--每页显示3条--</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 第1页        </span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 第2页        </span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">LIMIT</span> <span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 第3页</span></code></pre><hr><ol start="9"><li><strong>AND 和 OR</strong> 等运算符</li></ol><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--可用运算符如下--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>  <span class="token operator">>=</span>  <span class="token operator">&lt;=</span>  <span class="token operator">=</span>  <span class="token operator">&lt;></span><span class="token punctuation">(</span><span class="token operator">!=</span><span class="token punctuation">)</span><span class="token operator">BETWEEN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">AND</span>   <span class="token operator">LIKE</span><span class="token punctuation">(</span>模糊查询<span class="token punctuation">)</span>   <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token operator">AND</span><span class="token punctuation">(</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>  <span class="token operator">OR</span><span class="token punctuation">(</span><span class="token operator">||</span><span class="token punctuation">)</span>  <span class="token operator">NOT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> FirstName<span class="token operator">=</span><span class="token string">'Thomas'</span> <span class="token operator">AND</span> LastName<span class="token operator">=</span><span class="token string">'Carter'</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> firstname<span class="token operator">=</span><span class="token string">'Thomas'</span> <span class="token operator">OR</span> lastname<span class="token operator">=</span><span class="token string">'Carter'</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>FirstName<span class="token operator">=</span><span class="token string">'Thomas'</span> <span class="token operator">OR</span> FirstName<span class="token operator">=</span><span class="token string">'William'</span><span class="token punctuation">)</span><span class="token operator">AND</span> LastName<span class="token operator">=</span><span class="token string">'Carer'</span></code></pre><hr><h3 id="5-其他-DML-语句"><a href="#5-其他-DML-语句" class="headerlink" title="5. 其他 DML 语句"></a>5. 其他 DML 语句</h3><ol><li><strong>INSERT INTO 语句</strong></li></ol><p><strong>INSERT INTO 语句用于向表格中插入新的行。</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法--</span><span class="token comment" spellcheck="true">--所有列的值都要插入--</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名称 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--也可以指定要插入的列--</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名称 <span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Persons <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'Gates'</span><span class="token punctuation">,</span> <span class="token string">'Bill'</span><span class="token punctuation">,</span> <span class="token string">'LA'</span><span class="token punctuation">,</span> <span class="token string">'USA'</span><span class="token punctuation">)</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Persons <span class="token punctuation">(</span>LastName<span class="token punctuation">,</span> Address<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'Wilson'</span><span class="token punctuation">,</span> <span class="token string">'Champs-Elysees'</span><span class="token punctuation">)</span></code></pre><ol start="2"><li><strong>UPDATE 语句</strong></li></ol><p><strong>Update 语句用于修改表中的数据。</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法--</span><span class="token keyword">UPDATE</span> 表名称 <span class="token keyword">SET</span> 列名称 <span class="token operator">=</span> 新值 <span class="token keyword">WHERE</span> 列名称 <span class="token operator">=</span> 某值<span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">UPDATE</span> Person <span class="token keyword">SET</span> FirstName <span class="token operator">=</span> <span class="token string">'Fred'</span> <span class="token keyword">WHERE</span> LastName <span class="token operator">=</span> <span class="token string">'Wilson'</span><span class="token keyword">UPDATE</span> Person <span class="token keyword">SET</span> Address <span class="token operator">=</span> <span class="token string">'Zhongshan 23'</span><span class="token punctuation">,</span> City <span class="token operator">=</span> <span class="token string">'Nanjing'</span><span class="token keyword">WHERE</span> LastName <span class="token operator">=</span> <span class="token string">'Wilson'</span></code></pre><ol start="3"><li><strong>DELETE 语句</strong></li></ol><p><strong>DELETE 语句用于删除表中的行。</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法--</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名称 <span class="token keyword">WHERE</span> 列名称 <span class="token operator">=</span> 值<span class="token comment" spellcheck="true">--举例--</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Person <span class="token keyword">WHERE</span> LastName <span class="token operator">=</span> <span class="token string">'Wilson'</span> <span class="token comment" spellcheck="true">--在不删除表的情况下删除所有行--</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名称<span class="token keyword">DELETE</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名称</code></pre><hr><h3 id="6-约束"><a href="#6-约束" class="headerlink" title="6. 约束"></a>6. 约束</h3><p>概念：对表中的数据进行限定，保证数据的<strong>正确性、有效性和完整性</strong>。</p><ol><li><strong>非空约束</strong>：NOT NULL，<strong>某一列的值不能为 NULL</strong>。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--1.创建表时添加非空约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> STU<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span>NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--2.创建完表后再添加非空约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">MODIFY</span> NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token comment" spellcheck="true">--3.删除NAME的非空约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">MODIFY</span> NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span></code></pre><ol start="2"><li><strong>唯一约束</strong>：UNIQUE，<strong>某一列的值不能重复</strong>。可以有 NULL 值，但只能由一个。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--1.创建表时添加唯一约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> STU<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span>NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--2.创建完表后再添加唯一约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">MODIFY</span> NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token comment" spellcheck="true">--3.删除NAME的唯一约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> NAME</code></pre><ol start="3"><li><strong>主键约束</strong>：主键是表中记录的唯一标识，<strong>非空且唯一</strong>。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--1.创建表时添加主键约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> STU<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--2.创建完表后再添加主键约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">MODIFY</span> id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token comment" spellcheck="true">--3.删除主键约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">DROP</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token comment" spellcheck="true">--4.自动增长：数值类型的列，主键值自动增长</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> STU<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--5.创建后添加自增</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU id <span class="token keyword">INT</span> <span class="token keyword">auto_increment</span><span class="token comment" spellcheck="true">--6.删除自增</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">MODIFY</span> id <span class="token keyword">INT</span></code></pre><ol start="4"><li><strong>外键约束</strong>：使<strong>表与表之间产生关系</strong>，从而保证数据的正确性。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--0.用法</span><span class="token keyword">create</span> <span class="token keyword">table</span> 表名<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    外键列    <span class="token keyword">constraint</span> 外键名称 <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>外键列名称<span class="token punctuation">)</span> <span class="token keyword">references</span> 主表名称<span class="token punctuation">(</span>主表列名称<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--1.创建表时添加外键约束，是单独的一行，并不是跟在某个列之后，前一列后要加逗号</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> STU<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span> class_id <span class="token keyword">INT</span><span class="token punctuation">,</span>     <span class="token keyword">CONSTRAINT</span> stu_class_id FOREING <span class="token keyword">KEY</span><span class="token punctuation">(</span>class_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> class<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--2.创建表后添加外键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> stu_class_id <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>class_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> class<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token comment" spellcheck="true">--3.删除外键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> stu_class_id<span class="token comment" spellcheck="true">--4.设置级联 ON UPDATE CASCADE / DELETE UPDATE CASCADE</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> STU <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> stu_class_id <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>class_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> class<span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span></code></pre><hr><h3 id="7-多表关系"><a href="#7-多表关系" class="headerlink" title="7. 多表关系"></a>7. 多表关系</h3><ol><li><strong>多对一关系</strong>：如学生和班级，一个班级对应多个学生。实现方式：<strong>在多的一方建立外键，指向一的一方的主键</strong>。</li><li><strong>多对多关系</strong>：如学生和课程。实现方式：<strong>借助第三张中间表</strong>，中间表至少包含两个字段，作为外键分别指向其他两张表的主键。</li><li><strong>一对一关系</strong>：如学生和学号。在任意一方添加<strong>唯一外键</strong>，指向另一方主键。</li></ol><hr><h3 id="8-多表查询"><a href="#8-多表查询" class="headerlink" title="8. 多表查询"></a>8. 多表查询</h3><p>多表查询时会产生笛卡尔积，即很多冗余且不正确的信息，因此需要一些方法来规避。</p><ol><li><strong>内连接</strong>：INNER JOIN / JOIN ON (条件)，<strong>仅查询符合条件的部分</strong>。</li></ol><pre class=" language-SQL"><code class="language-SQL">--用法 INNER 可以省略SELECT STU.name, STU.gender,class.name FROM STU (INNER) JOIN class ON STU.'class_id' = class.'id'</code></pre><ol start="2"><li><strong>左外连接</strong>：LEFT JOIN ON (条件)。<strong>查询左表所有的行，不符合条件的列用 null 表示</strong>。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法</span><span class="token keyword">SELECT</span> STU<span class="token punctuation">.</span>name<span class="token punctuation">,</span> STU<span class="token punctuation">.</span>gender<span class="token punctuation">,</span>class<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> STU <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> class <span class="token keyword">ON</span> STU<span class="token punctuation">.</span><span class="token string">'class_id'</span> <span class="token operator">=</span> class<span class="token punctuation">.</span><span class="token string">'id'</span></code></pre><ol start="3"><li><strong>右外连接</strong>：RIGHT JOIN ON (条件)。<strong>查询右表所有的行，不符合条件的列用 null 表示</strong>。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--用法</span><span class="token keyword">SELECT</span> STU<span class="token punctuation">.</span>name<span class="token punctuation">,</span> STU<span class="token punctuation">.</span>gender<span class="token punctuation">,</span>class<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> STU <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> class <span class="token keyword">ON</span> STU<span class="token punctuation">.</span><span class="token string">'class_id'</span> <span class="token operator">=</span> class<span class="token punctuation">.</span><span class="token string">'id'</span></code></pre><ol start="4"><li><strong>全外连接</strong>：FULL JOIN ON（条件）。<strong>查询两表所有的行，不符合条件的列用 null 表示</strong>。</li><li><strong>子查询</strong>：嵌套查询</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--子查询的结果可以是单行单列、多行单列和多行多列的</span><span class="token comment" spellcheck="true">--单行单列演示</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> emp<span class="token punctuation">.</span><span class="token punctuation">`</span>salary<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">FROM</span> emp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--这个子查询结果 最高工资 是单行单列的</span><span class="token comment" spellcheck="true">--多行单列演示 使用 IN 函数</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> NAME <span class="token operator">=</span> <span class="token string">'财务部'</span> <span class="token operator">OR</span> NAME <span class="token operator">=</span> <span class="token string">'市场部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">--多行多列演示 子查询结果作为一张虚拟表</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span>     dept t1 <span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> emp<span class="token punctuation">.</span><span class="token punctuation">`</span>join_date<span class="token punctuation">`</span> <span class="token operator">></span> <span class="token string">'2011-11-11'</span><span class="token punctuation">)</span> t2 <span class="token comment" spellcheck="true">--子查询结果作为t2表</span><span class="token keyword">WHERE</span>     t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>dept_id<span class="token punctuation">;</span></code></pre><hr><h3 id="9-MySQL-分层架构"><a href="#9-MySQL-分层架构" class="headerlink" title="9. MySQL 分层架构"></a>9. MySQL 分层架构</h3><p>MySQL 可以分为 <strong>server 层和存储引擎层</strong>两层。</p><ol><li><strong>server 层</strong>：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li><li><strong>存储引擎层</strong>：负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在 MySQL 默认的存储引擎是 InnoDB。</li></ol><ul><li>不同的存储引擎共用一个 server 层。</li></ul><p><img src="MySQL.assets/20200127101623119.png" alt=""></p><hr><h3 id="10-server-层"><a href="#10-server-层" class="headerlink" title="10. server 层"></a>10. server 层</h3><ol><li><p><strong>连接器</strong>：负责跟客户端建立连接、获取权限、维持和管理连接。 这里 Java 使用的是 JDBC 连接，同时还可以引申出数据库连接池。连接分为两种：</p><ol><li>短连接：连接时间短，查询几次就断开，再次连接时重新建立新的连接。</li><li>长连接：连接成功后，如果客户端一直有请求，则一直使用同一个连接。</li></ol><ul><li><strong>对比</strong>：短连接经常断开再连接十分浪费资源，建议<strong>尽量使用长连接</strong>。而长连接的缺点是，一直使用长连接内存消耗很大，可能造成 OOM。</li><li>长连接避免 OOM 有两种方式：一是定期断开重连。而是在执行一个比较消耗内存的操作后，执行 mysql_reset_connection 重新初始化连接。</li></ul></li><li><p><strong>查询缓存</strong>：查询时会先查找缓存，如果没有再向下执行查找。MySQL 8.0 后查询缓存已经被移除。</p></li><li><p><strong>分析器</strong>：对 SQL 语句进行分析，首先是<strong>词法分析</strong>，通过空格和逗号等分隔，识别出每个单词的意义。然后是<strong>语法分析</strong>，根据词法分析的结果，判断 SQL 语句是否满足语法。</p></li><li><p><strong>优化器</strong>：对 SQL 语句进行优化，如判断是否使用索引，使用哪个索引，多表查询的联合顺序等。</p></li><li><p><strong>执行器</strong>：执行器执行 SQL 语句，在执行前会先判断是否有权限，如果有，则执行语句。执行器执行时，会根据引擎的定义，去使用引擎提供的接口。</p></li></ol><hr><h3 id="11-存储引擎层：InnoDB"><a href="#11-存储引擎层：InnoDB" class="headerlink" title="11. 存储引擎层：InnoDB"></a>11. 存储引擎层：InnoDB</h3><p>InnoDB主要包括了内存池、后台线程以及存储文件。</p><p><img src="MySQL.assets/205Rb363_0.jpg" alt=""></p><blockquote><p>后台线程：</p></blockquote><ol><li><strong>Master Thread</strong>：主要负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（Insert Buffer）、undo页的回收等。</li><li><strong>IO Thread</strong>：在 InnoDB 中大量使用了 AIO 来处理写 IO 请求，而 IO Thread 的工作主要是负责这些 IO 请求的回调处理。IO Thread 分为 <strong>write、read、insert buffer 和 log IO thread</strong> 四种。</li><li><strong>Purge Thread</strong>：事务被提交后，其所使用的 undo log 可能不再需要，因此需要 Purge Thread 来回收已经使用并分配的 undo 页。</li><li><strong>Page Cleaner Thread</strong>：Page Cleaner Thread是一个用于协助Master Thread刷新脏页到磁盘的线程。</li></ol><blockquote><p><strong>Buffer Pool</strong></p></blockquote><p>InnoDB 存储引擎是基于磁盘存储的，而<strong>缓冲池是一块内存区域</strong>，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。</p><ul><li>在数据库中进行<strong>读取页</strong>的操作，首先将从磁盘读到的页存放在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</li><li>在数据库中进行<strong>修改页</strong>的操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是<strong>通过一种称为 Checkpoint 的机制刷新回磁盘</strong>。</li><li>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</li></ul><blockquote><p><strong>Buffer Pool 管理</strong></p></blockquote><ol><li><strong>LRU List</strong>：基于<strong>最近最少使用算法</strong>，并做了优化。<ol><li>按照 5 ：3 的比例（old 比例 37%）把链表分成 young 和 old 区域，有一个 old 指针指向 old 区的首节点，实际还是一条链表。</li><li><strong>新加入缓存的页放入 old 区域</strong>，可以设置时间，在 x 秒内再次被访问就移动到链表的头部。这个策略是对大表全表扫描的优化，虽然用到了缓存池，但不影响 young 区域，保证正常业务的查询命中率。</li></ol></li><li><strong>Free List</strong>：当需要从缓冲池中分页时，首先从 Free 列表中查找是否有可用的空闲页，若有则将该页从 Free 列表中删除，放入到 LRU 列表中。否则，根据 LRU 算法，淘汰 LRU 列表末尾的页，将该内存空间分配给新的页。</li><li><strong>Flush List</strong>：在 LRU 列表中的页被修改后，称该页为<strong>脏页</strong>，Flush List 即为储存脏页的列表，数据库会通过 Checkpoint 机制将脏页刷新回磁盘。Flush List 中的页也存在于 LRU List。</li></ol><blockquote><p><strong>redo log buffer</strong></p></blockquote><p>InnoDB 首先将 redo log 放入到 redo log buffer，然后按一定频率将其刷新到 redo log file。下列三种情况下会将 redo log buffer 刷新到 redo log file：</p><ol><li>Master Thread 每秒将 redo log buffer 刷新到 redo log file。</li><li>每个事务提交时会将 redo log buffer 刷新到 redo log file。</li><li>当 redo log 缓冲池剩余空间小于1/2 时，会将 redo log buffer 刷新到 redo log file。</li></ol><blockquote><p><strong>Insert Buffer</strong></p></blockquote><p>对于<strong>非主键索引</strong>的插入或更新操作，不是每一次直接插入到索引页中，而是<strong>先判断插入的非主键索引页是否在缓冲池中</strong>，若在，则直接插入；若不在，则先放入到一个 Insert Buffer 对象中，然后再以一定的频率和情况进行 <strong>Insert Buffer 和非主键索引叶子节点的 merge（合并）操作，这时通常能将多个插入合并到一个操作中</strong>（因为在一个索引页中），这就大大提高了对于非主键索引插入的性能。</p><p><strong>InnoDB 对 DML 操作（Insert、Delete、Update）都进行缓冲</strong>，分别是 Insert Buffer、Delete Buffer、Purge Buffer。</p><p>将 Buffer 中的操作应用到原数据页，得到最新结果的过程称为<strong>merge</strong>。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭的过程中，也会执行merge操作。</p><hr><h3 id="12-InnoDB-和-MyISAM-的区别"><a href="#12-InnoDB-和-MyISAM-的区别" class="headerlink" title="12. InnoDB 和 MyISAM 的区别"></a>12. InnoDB 和 MyISAM 的区别</h3><ol><li>InnoDB 支持事务，MyISAM 不支持事务；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>InnoDB 是聚集索引，MyISAM 是非聚集索引（索引部分中有具体解释）；</li><li>InnoDB 不保存行数，如果使用 <code>COUNT()</code> 还需要全表扫描。MyISAM 保存行数，可以直接返回；</li><li>InnoDB 支持行锁和表锁，但行锁是锁在索引上的，如果不能命中索引，就会退化为表锁。MyISAM 不支持行锁，仅支持表锁；</li><li>InnoDB 必须有主键，如果没有定义，会自动生成一个（用户不可见）。MyISAM 可以没有主键；</li></ol><ul><li>读操作多的情况下，MyISAM 更好，因为 InnoDB 要维护更多的数据。</li></ul><hr><h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h2><h3 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h3><p>概念：<strong>事务是逻辑上的一组操作，要么同时成功，要么同时失败</strong>。</p><p>举例：<strong>事务最经典也经常被拿出来说例子就是转账了</strong>。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><p>使用步骤：</p><pre class=" language-SQL"><code class="language-SQL">--开启一个事务，两种方式BEGINSTART TRANSACTION--进行一组操作UPDATE Persons SET Money=Money-1000 WHERE Name='小明'UPDATE Persons SET Money=Money+1000 WHERE Name='小红'--如果成功，则提交COMMIT--如果出错，则回滚ROLLBACK</code></pre><hr><h3 id="2-事务的四大特性"><a href="#2-事务的四大特性" class="headerlink" title="2. 事务的四大特性"></a>2. 事务的四大特性</h3><ol><li><strong>原子性</strong>：事务是<strong>最小的执行单位</strong>，不允许分割。事务的原子性确保动作要么全部成功，要么全部失败；</li><li><strong>持久性</strong>：一个事务被提交或回滚之后，<strong>数据库会持久化的保存数据</strong>，即使数据库发生故障也不应该对其有任何影响。</li><li><strong>隔离性</strong>：多个并发事务之间<strong>相互独立</strong>，并发访问数据库时，各并发事务之间的数据库是独立的。</li><li><strong>一致性</strong>：执行事务的前后，数据总量保持一致（完整性保持稳定）。如小明和小红每人有 1000 块钱，小明给小红转了 1000 块钱，不管成功还是失败，两个人的总量仍然是 2000。</li></ol><hr><h3 id="3-并发事务导致的问题"><a href="#3-并发事务导致的问题" class="headerlink" title="3. 并发事务导致的问题"></a>3. 并发事务导致的问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题：</p><ol><li><strong>脏读</strong>：并发事务在读取数据时，<strong>读取到了另一个事务还没有提交的数据</strong>。</li><li><strong>不可重复读（虚读）</strong>：在同一个事务中，<strong>两次读取到的数据不一样</strong>。也就是说在这个事务两次读取之间，有另一个并发事务修改了这个数据，导致其两次读取到的数据不一样。</li><li><strong>幻读</strong>：它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<strong>在 MySQL 中不会出现幻读</strong>。</li><li><strong>丢失修改</strong>：一个事务的修改被另一个并发事务修改覆盖，称为丢失修改。<strong>是不可重复读的特殊情况</strong>。</li></ol><p>注意：</p><ol><li><strong>不可重复读和脏读的区别</strong>：<strong>脏读</strong>读取到的是另一个事务<strong>未提交</strong>的数据，<strong>不可重复读</strong>读取到的是前一个事务<strong>已提交</strong>的数据。</li><li><strong>不可重复读和幻读的区别</strong>：两者读取到的都是前一个事务<strong>已提交</strong>的数据，但<strong>不可重复读</strong>读取到的是对某些<strong>数据的修改</strong>，<strong>幻读</strong>读取到的是<strong>记录的增加或减少</strong>。</li></ol><hr><h3 id="4-事务的隔离级别"><a href="#4-事务的隔离级别" class="headerlink" title="4. 事务的隔离级别"></a>4. 事务的隔离级别</h3><ol><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。 </li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。 </li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。 </li></ol><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>随着隔离级别的递增，安全性越来越高，但<strong>效率越来越低</strong>。</li><li><strong>MySQL 的默认隔离级别是 REPEATABLE-READ</strong>，Oracle 的默认隔离级别是 READ-COMMITTED。</li></ul><hr><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h2><h3 id="1-索引简介"><a href="#1-索引简介" class="headerlink" title="1. 索引简介"></a>1. 索引简介</h3><ul><li>在<strong>不读取整个表</strong>的情况下，<strong>索引使数据库更快的查找数据</strong>，但使得写相对变慢。</li><li>索引可以分为聚集索引和非聚集索引：<ul><li>聚集索引存储物理上连续存在的记录，如123456；</li><li>非聚集索引存储逻辑上的的连续记录，如某一作家的书可以在第一个和第十个书架上；</li></ul></li><li><strong>主键和外键列一定要建立索引</strong>。</li><li><strong>经常查询的列最好建立索引</strong>，相对的不经常查询的列最好不要建立索引。</li><li><strong>经常存取的列避免建立索引</strong>。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--创建索引的语法</span><span class="token keyword">CREATE</span>     <span class="token keyword">INDEX</span> index_name<span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token keyword">ON</span>    表名（列名）<span class="token comment" spellcheck="true">--举例：在Person表中的姓名列建立索引</span><span class="token keyword">CREATE</span>     <span class="token keyword">INDEX</span> personIndex<span class="token keyword">ON</span>    Persons<span class="token punctuation">(</span>name<span class="token punctuation">)</span></code></pre><hr><h3 id="2-索引的存储方式"><a href="#2-索引的存储方式" class="headerlink" title="2. 索引的存储方式"></a>2. 索引的存储方式</h3><ol><li>数据库索引是存储在外部磁盘上的，当数据库索引量很大时，就不能把整个索引加载到内存，只能逐一加载磁盘页，每一次加载都是一次 I/O 操作，这个过程耗时长；</li><li>二叉树当数据量很大时，深度会非常深。<strong>对于树来说，磁盘页数就是树的高度</strong>。若使用二叉树存储索引，读取时需要读取很多磁盘页，也就是要进行相当多的 I/O 操作，因此使用二叉树耗时长；</li><li><strong>数据库索引的存储方式是 B/B+ 树</strong>，这是一种多叉树，它的<strong>每个节点最多包含 m 个孩子</strong>，m 被称为 B 树的阶，m 的大小取决于磁盘页的大小。这种树的特征是<strong>矮胖</strong>，可以减少 I/O 次数。</li></ol><hr><h3 id="3-B树的结构"><a href="#3-B树的结构" class="headerlink" title="3. B树的结构"></a>3. B树的结构</h3><ol><li>B 树的<strong>每个节点最多包含 m 个孩子</strong>，m 被称为 B 树的阶，m 的大小取决于磁盘页的大小。</li><li>B 树的存储方式符合<strong>搜索树</strong>的规范，节点左子树的数据都比当前节点小，右子树的数据都比当前节点大，且<strong>每个节点内部按非降序排列</strong>。</li><li>若根节点不是叶子节点，则<strong>根节点至少有两个孩子</strong>。</li><li><strong>非叶子节点至少有 m/2 个孩子，最多有 m 个孩子</strong>。</li><li><strong>非叶子节点有 k 个孩子，则非叶子节点中的数据个数等于 k - 1</strong>。如当前节点有 3 个数据，则该节点有 4 个孩子。<strong>k - 1 个数据分割 k 个孩子节点</strong>。</li><li>所有叶子节点处于同一层。</li></ol><p><img src="06-MySQL.assets/7862980-9f37abf83ae7a973.webp" alt=""></p><hr><h3 id="4-B树和B-树的对比"><a href="#4-B树和B-树的对比" class="headerlink" title="4. B树和B+树的对比"></a>4. B树和B+树的对比</h3><ol><li><strong>B树每个节点中存储的数据都是键值对</strong>，即索引-数据对；<strong>B+树中非叶子节点只存储关键字，用来索引，叶子节点中存储了所有数据</strong>。</li><li><strong>B+树非叶子节点中数据个数为 k 个</strong>，B树为 k-1 个。</li><li><strong>B+树叶子节点有指向相邻节点的指针</strong>，按照关键字从小到大的顺序连接，形成一个有序链表。B树不是这种结构。</li><li>B+树中同一个数字会在不同的节点中出现，<strong>父节点中会记录每个孩子中的最大或最小元素</strong>。</li></ol><p><img src="06-MySQL.assets/0611ff5a5103461e843ab627f8821419_th.png" alt=""></p><hr><h3 id="5-B-树的优势"><a href="#5-B-树的优势" class="headerlink" title="5. B+树的优势"></a>5. B+树的优势</h3><ol><li>单一节点中存储的数据更多，使得 B+树更加矮胖，<strong>查询的 I/O 次数更少</strong>；</li><li>所有的查询都要查询到叶子节点，<strong>查询性能稳定</strong>。B树每个节点都可能查到数据，所以不稳定。</li><li>叶子节点形成有序链表，<strong>便于范围查找</strong>。B树只能通过中序遍历查找，十分繁琐。</li></ol><hr><h3 id="6-哈希索引"><a href="#6-哈希索引" class="headerlink" title="6. 哈希索引"></a>6. 哈希索引</h3><p>哈希索引就是采用一定的<strong>哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可<strong>立刻定位到相应的位置，速度非常快</strong>。</p><p>哈希索引有好几个局限：</p><ul><li>哈希索引也没办法利用索引完成<strong>排序</strong>。</li><li>不支持<strong>最左匹配原则</strong>。</li><li>在有大量重复键值情况下，哈希索引的效率也是极低的—-&gt;<strong>哈希碰撞</strong>问题。</li><li><strong>不支持范围查询</strong>。</li></ul><hr><h3 id="7-索引最左匹配原则"><a href="#7-索引最左匹配原则" class="headerlink" title="7. 索引最左匹配原则"></a>7. 索引最左匹配原则</h3><ul><li>索引可以简单如一个列<code>(a)</code>，也可以复杂如多个列<code>(a, b, c, d)</code>，即<strong>联合索引</strong>。 </li><li>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询 <code>(&gt;、&lt;、between、like</code> 左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li><li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li><li>例如：有索引 <code>(a, b, c, d)</code>，查询条件 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中 a、b、c，无法命中 d。(很简单：索引命中只能是<strong>相等</strong>的情况，不能是范围匹配) 。</li><li><strong>不需要考虑=、in等的顺序</strong>，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。 例如有索引 <code>(a, b, c, d)</code>，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL会自动优化为 <code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中 a、b、c。</li></ul><hr><h3 id="8-聚集索引和非聚集索引"><a href="#8-聚集索引和非聚集索引" class="headerlink" title="8. 聚集索引和非聚集索引"></a>8. 聚集索引和非聚集索引</h3><ul><li>聚集索引是<strong>索引结构和数据一起存放的索引</strong>，找到索引就找到了数据；</li><li>非聚集索引是<strong>索引结构和数据分开存放的索引</strong>，索引和数据用两个文件储存。</li></ul><p><strong>InnoDB 和 MyISAM 的区别</strong>：</p><ul><li><strong>InnoDB 使用聚集索引。聚集索引是唯一的</strong>，一个表中只有一个，一般是主键。<strong>只有聚集索引的 B+ 树的叶子节点储存了行的所有信息</strong>。其他再建立的索引都是非聚集索引，<strong>B+树的叶子节点储存当前列的信息和主键值</strong>。查询时，<strong>要先拿到主键，再通过主键去查询数据</strong>，这个过程也叫做<strong>回表</strong>。</li><li><strong>MyISAM 使用非聚集索引</strong>，索引的 B+ 树的叶子节点储存的是指向行数据的地址，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，所以<strong>不会出现回表</strong>。</li></ul><hr><h3 id="9-覆盖索引"><a href="#9-覆盖索引" class="headerlink" title="9. 覆盖索引"></a>9. 覆盖索引</h3><p>我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是<strong>主键和索引列息</strong>。最终还是要回表，也就是要通过主键再查找一次。 </p><ul><li><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong> </li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--创建单列索引username，进行查询时，只查询username不需要进行回表</span><span class="token keyword">select</span> username <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">'Java3y'</span><span class="token comment" spellcheck="true">--如果既要查询username又要查询age，则需要进行回表</span><span class="token keyword">select</span> username <span class="token punctuation">,</span> age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">'Java3y'</span><span class="token comment" spellcheck="true">--若想要不回表，可以将单列索引升级为联合索引(username,age)，再进行查询则不需要回表</span><span class="token keyword">select</span> username <span class="token punctuation">,</span> age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">'Java3y'</span></code></pre><hr><h3 id="10-不触发索引"><a href="#10-不触发索引" class="headerlink" title="10. 不触发索引"></a>10. 不触发索引</h3><ol><li>条件中<strong>多个字段（列）使用 or</strong>，即使有条件带索引也不会使用。多条件查询统一字段是使用 or 索引会生效。<strong>可以用 in 代替 or</strong>。</li><li>多列索引 / 联合索引<strong>没有使用第一个或左边的索引</strong>，之后就不会使用索引。（最左匹配原则）</li><li>模糊查询 <strong>like 以 % 开头</strong>。</li><li>如果列类型是<strong>字符串，数据没有用引号（发生了类型转换）</strong>。</li><li>在索引列上使用 <strong>IS NULL / IS NOT NULL</strong> 操作。</li><li><strong>索引上有数学运算</strong>。</li><li><strong>索引上有函数运算</strong>。</li><li>查询条件里有<strong>不等号（NOT  &lt;  !=）</strong>。</li><li>MySQL 估计<strong>全表扫描更快时</strong>。</li></ol><hr><h3 id="11-建立索引的原则"><a href="#11-建立索引的原则" class="headerlink" title="11. 建立索引的原则"></a>11. 建立索引的原则</h3><ol><li>对于经常查询的字段，建立索引；</li><li>频繁增删改的字段，不建议建立索引；</li><li>索引数量适当，不建议建立太多索引；</li><li>数据量小的表不建议建立索引；</li><li>区分度低的列不建议建立索引；</li><li>尽量对字段小的列建立索引，如 INT 肯定比 VARCHAR(100) 字段小；</li></ol><hr><h3 id="12-命中索引但效率低"><a href="#12-命中索引但效率低" class="headerlink" title="12. 命中索引但效率低"></a>12. 命中索引但效率低</h3><ol><li>查询范围太大</li><li>没有用到覆盖索引，造成回表</li><li>查询字段过多</li><li>索引字段太大</li><li>命中的不是最优索引</li></ol><hr><h2 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h2><h3 id="1-粒度锁"><a href="#1-粒度锁" class="headerlink" title="1. 粒度锁"></a>1. 粒度锁</h3><p>MySQL 不同的存储引擎支持不同的锁机制，所有的<strong>存储引擎</strong>都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现： <strong>表级锁和行级锁</strong>。</p><ul><li>MyISAM 采用的是表级锁，InnoDB 采用的是表级锁和行级锁。</li><li>MySQL 在执行 SQL 语句时，会<strong>自动加锁</strong>（表锁一般是透明的，不用手动加锁）。</li><li>在 InnoDB 存储引擎中，如果没有使用索引，<strong>表锁也是自动加的</strong>。</li></ul><ol><li><strong>表级锁</strong>：开销小，加锁快；<strong>不会出现死锁</strong>；发生冲突的概率高，<strong>并发度低</strong>；表锁适合以查询为主，并发用户少的情况。</li><li><strong>行级锁</strong>：开销大，加锁慢；<strong>会出现死锁</strong>；发生冲突的概率低，<strong>并发度高</strong>。行锁适合大量按索引并发，更新少量数据，同时又有并发查询的情况。</li></ol><hr><h3 id="2-表锁"><a href="#2-表锁" class="headerlink" title="2. 表锁"></a>2. 表锁</h3><p>表锁分为两种：表读锁和表写锁。</p><ol><li><strong>表读锁</strong>：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li><strong>表写锁</strong>：会阻塞其他用户对同一表的读和写操作。</li></ol><blockquote><p><strong>读读不阻塞、读写阻塞、写写阻塞。读写串行</strong></p></blockquote><ul><li><strong>读读不阻塞</strong>：当前用户在读数据，其他的用户也在读数据，<strong>不会阻塞</strong>；</li><li><strong>读写阻塞</strong>：当前用户在读数据，其他的用户要写数据，<strong>会阻塞</strong>；</li><li><strong>写写阻塞</strong>：当前用户在写数据，其他的用户要写数据，<strong>会阻塞</strong>；</li></ul><blockquote><p><strong>写锁优先于读锁</strong></p></blockquote><ul><li>当一个锁可用时，这个锁会<strong>优先给等待中的写锁</strong>。</li><li>MyISAM 不适合写多的情况，因为会造成读操作的阻塞，每次都把锁给写操作了。</li><li>可以使用 <code>SET LOW_PRIORITY_UPDATES</code> 改变优先级。</li></ul><blockquote><p><strong>读写并行</strong></p></blockquote><ul><li>MyISAM 支持读操作时，在表尾进行写操作。</li><li>当 <code>concurrent_insert</code> 设置为1时，如果 MyISAM 表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是 MySQL 的默认设置。 </li><li>InnoDB 不支持读写并行。</li></ul><hr><h3 id="3-行锁"><a href="#3-行锁" class="headerlink" title="3. 行锁"></a>3. 行锁</h3><p>行锁是 InnoDB 引擎才有的锁，<strong>MyISAM 不支持</strong>。</p><p>InnoDB 实现了两种类型的行锁：</p><ul><li><strong>共享锁</strong>（读锁，S锁）：允许一个事务读一行，阻止其他事务获得相同数据集的<strong>排它锁</strong>。读是共享的，<strong>允许多个事务同时读取同一个资源</strong>，但不允许修改。</li><li><strong>排他锁</strong>（写锁，X锁）：允许事务更新数据，阻止其他事务获得相同数据集的<strong>共享锁和排他锁</strong>。写是排他的，阻止其他的读和写。</li><li><strong>InnoDB 会根据隔离级别在需要的时候自动加锁</strong>，锁只有在 commit 或 rollback 时才会释放，并且所有锁会在同一时刻被释放。</li><li><strong>显式加锁</strong>：用户可以通过 SQL 语句显式加锁</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span> <span class="token comment" spellcheck="true">//共享锁 </span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span> <span class="token comment" spellcheck="true">//排他锁 </span></code></pre><p>为了实现行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：意向共享锁和意向排他锁。数据库隐式处理，不用程序员操心。</p><hr><h3 id="4-行锁与索引"><a href="#4-行锁与索引" class="headerlink" title="4. 行锁与索引"></a>4. 行锁与索引</h3><p><strong>InnoDB 行锁是通过给索引上的索引项加锁来实现的</strong>，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。 </p><ul><li>只有<strong>通过索引条件检索数据</strong>，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</li><li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。 </li><li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，<strong>如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁</strong>，而不是行锁 （可以通过 explain 检查 SQL 的执行计划）。 </li><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个事务是访问不同行的记录， 但是<strong>如果使用相同的索引键， 是会出现锁冲突的</strong>。</li></ul><hr><h3 id="5-间隙锁"><a href="#5-间隙锁" class="headerlink" title="5. 间隙锁"></a>5. 间隙锁</h3><p>当我们<strong>用范围条件检索数据</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给<strong>符合范围条件的已有数据记录的索引项加锁</strong>；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。 </p><blockquote><p><strong>间隙锁的作用</strong></p></blockquote><ol><li><strong>防止幻读</strong>。</li><li>满足回复和复制的需要：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。 </li></ol><ul><li><strong>间隙锁只会在可重复读隔离级别下使用，因此这个级别下已经可以避免幻读了</strong>。</li></ul><hr><h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6. 死锁"></a>6. 死锁</h3><p><strong>MyISAM</strong>：在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。 </p><p><strong>InnoDB</strong>：InnoDB 可能会出现死锁，因此需要采取一些方式避免死锁。</p><ul><li><strong>一次获得全部锁</strong>：在同一个事务中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概率。 </li><li>以<strong>固定的顺序</strong>访问表和行：如对两个事务批量更新的情形，应在每个事务中以相同的顺序使用加锁语句。简单方法是对id列表先排序，后执行，这样就<strong>避免了交叉等待锁的情形</strong>；将两个事务的 sql 顺序调整为一致，也能避免死锁。 </li><li><strong>降低隔离级别</strong>。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从可重复读调整为已提交，可以避免掉很多因为 gap 锁造成的死锁。</li><li><strong>为表添加合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。 </li><li><strong>大事务拆小</strong>。大事务更倾向于死锁，如果业务允许，将大事务拆小。 </li><li><strong>直接申请足够级别的锁</strong>：在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁。而不应先申请共享锁，更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</li></ul><hr><h3 id="7-MVCC"><a href="#7-MVCC" class="headerlink" title="7. MVCC"></a>7. MVCC</h3><p>MVCC（Multi-Version Concurrency Control）多版本并发控制，可以简单地认为：<strong>MVCC就是行级锁的一个变种(升级版)</strong>。在加锁时，读写是阻塞的。但基于并发的考虑，<strong>MVCC 一般读写是不阻塞的</strong>，只剩下写写阻塞。</p><p>MVCC 是通过保存数据在某个时间点的<strong>快照</strong>来实现的。InnoDB通过 undo log 保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，<strong>每个事务读到的数据版本可能是不一样的</strong>。</p><p><strong>在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改</strong>。</p><ol><li><p><strong>隐藏字段</strong>：InnoDB 存储引擎在每行数据的后面添加了三个隐藏字段，其中只有两个与 MVCC 相关。 </p><ul><li>DB_TRX_ID：<strong>记录上次对改行记录做修改的事务 ID</strong>。delete 操作会更新一个删除位，逻辑删除。</li><li>DB_ROLL_PTR：回滚指针，指向当前记录行的 undo log 信息，即<strong>指向上一个版本的行数据</strong>。</li></ul></li><li><p><strong>快照和Read View</strong>：事务执行普通的 select 语句，会创建一个快照，可以理解为当前数据的拷贝。同时也会产生一个 Read View，其中包括几个变量，主要作用是做可见性判断，也就是判断当前行的版本是否可以被读到。Read View 的重要变量：</p><ul><li>low_limit_id：目前出现过的<strong>最大事务 ID + 1</strong>。也就是下一个新事务的 ID。</li><li>trx_ids：<strong>Read View 创建时其他未提交的活跃事务 ID 列表</strong>，其排列是有序的。</li><li>up_limit_id：<strong>活跃事务列表中的最小 ID</strong>，如果列表为空，则等于 low_limit_id。</li></ul></li><li><p><strong>undo log</strong>：undo log 中存储的是老版本数据，当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着 <strong>undo log 链</strong>找到满足其可见性条件的记录行版本。 <strong>undo log 链的形成过程</strong>如下：</p><p><img src="MySQL.assets/20200701205716343.png" alt=""></p><ol><li>现在事务 A（事务ID为2）对该记录的Honor做出了修改，将Honor改为”fmvp”：<ol><li>事务 A 先对该行加排它锁。</li><li>然后把该行数据拷贝到 undo log 中，作为旧版本。</li><li>拷贝完毕后，修改该行的 Honor 为 “fmvp”，并且修改 DB_TRX_ID 为2（事务 A 的 ID）, 回滚指针指向拷贝到 undo log 的旧版本，还会将修改后的最新数据写入 redo log。</li><li>事务提交，释放排他锁。</li></ol></li></ol><p><img src="MySQL.assets/20200701210046670.png" alt=""></p><ol start="2"><li>接着事务 B（事务 ID 为 3）修改同一个记录行，将 Name 修改为 “iguodala”： </li></ol><p><img src="MySQL.assets/2020070121022442.png" alt=""></p><ul><li>可见，事务对同一行数据修改，会使该<strong>行记录的 undo log 形成一条链表，这个链表头部是最新的旧记录，尾部是最老的旧记录</strong>。</li></ul></li><li><p><strong>可见性判断</strong>：根据 Read View 中的变量和行隐藏列中保存的事务 ID（DB_TRX_ID），判断当前行的数据是否可见。</p><ol><li>如果 DB_TRX_ID &lt; up_limit_id（<strong>活跃的最小 ID</strong>），那么一定在当前事务之前就已提交，对当前事务可见。</li><li>如果 DB_TRX_ID &gt; low_limit_id（<strong>现有的最大 ID</strong>），那么一定在当前事务之后提交，对当前事务不可见。需进行回滚。</li><li>如果 up_limit_id &lt;= DB_TRX_ID &lt; low_limit_id（<strong>在活跃事务 ID 范围内</strong>），那么查找活跃事务 ID 列表 trx_ids。<ul><li>如果找到：说明快照创建前该事务还未提交，对当前事务不可见，需进行回滚。</li><li>如果未找到：说明快照创建前已提交，只是事务 ID 在范围内，对当前事务可见。</li></ul></li><li><strong>回滚</strong>：在当前行的隐藏列中获得<strong>回滚指针 DB_ROLL_PTR</strong>，该指针指向 undo log 中的旧版本数据。取得最新的旧事务号，赋值给 DB_TRX_ID，回到步骤一重新判断。</li></ol></li><li><p><strong>可重复度和读取已提交的区别</strong>：主要在于 Read View 的创建。</p><ul><li>在可重复读级别，一个事务只会在第一次 select 时创建一个快照，即<strong>一个 Read View</strong>。不论事务中有多少 select，都使用同一个 Read View，直到事务结束。</li><li>在读取已提交级别，事务中每条 select 都会创建一个快照，即会产生<strong>多个 Read View</strong>，这就会导致幻读。</li></ul></li></ol><hr><h3 id="8-防止幻读"><a href="#8-防止幻读" class="headerlink" title="8. 防止幻读"></a>8. 防止幻读</h3><p>MySQL 默认事务隔离级别为可重复读，这个隔离级别默认是不可防止幻读的，但 <strong>MySQL 中的可重复读可以防止幻读</strong>。</p><ol><li><strong>MVCC</strong>：MVCC 作为快照读时的处理方案，可以避免不加锁时的幻读。</li><li><strong>间隙锁</strong>：间隙锁作为当前读时的处理方案，可以避免加锁时的幻读。</li><li><strong>注意</strong>：MySQL 防止幻读是两者共同作用的结果，MVCC 并不能保证在加锁时防止幻读。</li></ol><hr><h2 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h2><h3 id="1-bin-log"><a href="#1-bin-log" class="headerlink" title="1. bin log"></a>1. bin log</h3><ul><li>binlog 中记录了数据库<strong>表结构和表数据的变更</strong>，如 <code>UPDATE/DELETE/INSERT/TRUNCATE/CREAT</code>，但不会记录 <code>SELECT</code>。</li><li>可以简单理解为 <strong>bin log 中存储着每条变更的 SQL 语句</strong>，类似 Redis 持久化中的 AOF。实际上还有事务 ID，时间等。</li></ul><blockquote><p><strong>bin log 的作用</strong></p></blockquote><ol><li><strong>主从复制</strong>：实际使用时，MySQL 往往是一主多从结构，从服务器数据要和主服务器保持一致，这就是通过 bin log 实现的。</li><li><strong>恢复数据</strong>：如果数据库宕机或数据丢失，可以通过 bin log 进行恢复。</li></ol><hr><h3 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2. redo log"></a>2. redo log</h3><ol><li>数据库中的数据储存在磁盘里，在对数据修改时，需要先找到数据，将数据读入内存，修改后再写入磁盘（落盘）。</li><li>当内存中已修改成功，但还没有落盘，此时数据库宕机，修改就无法写入，这次更新就会丢失。</li></ol><blockquote><p>如何保证修改不丢失？</p></blockquote><ul><li>MySQL使用了 <strong>redo log 记录修改</strong>，内存修改成功后，会写一份 redo log，记录在某个数据页上做了什么修改。</li><li>redo log 也是要保存在磁盘中的，所以中间会有个 buffer，类似 Redis 的持久化策略。但 redo log 在写磁盘时是<strong>顺序 IO</strong>，速度快。</li></ul><hr><h3 id="3-bin-log-和-redo-log"><a href="#3-bin-log-和-redo-log" class="headerlink" title="3. bin log 和 redo log"></a>3. bin log 和 redo log</h3><p>bin log 和 redo log 都有恢复数据的功能，但在其他方面也有区别和联系：</p><ol><li><strong>内容不同</strong>（类似 Redis 的两种持久化策略）：<ul><li>bin log 中记录的是 <strong>SQL 语句</strong>。</li><li>redo log 中记录的是物理<strong>修改的内容</strong>。</li><li>有说法是 bin log 记录的是数据的<strong>逻辑变化</strong>，redo log 记录的是数据的<strong>物理变化</strong>。</li></ul></li><li><strong>功能不同</strong>：<ul><li>bin log 用于<strong>主从复制和恢复数据，记录着所有的变更</strong>，如果整个数据库被删除了，也可以根据 bin log 恢复。</li><li>redo log 用于<strong>持久化</strong>，为了保证数据的修改会被写进磁盘，也是<strong>事务的持久性的保证</strong>。<strong>redo log 储存的变更在被刷新到磁盘后就会失效</strong>，也就是说 redo log 不会存储所有的历史变更，其内容是会被覆盖的。</li></ul></li><li><strong>写入顺序</strong>：<ul><li>bin log 在事务提交时，才记录数据的变更。</li><li>redo log 在事务开始后，就会记录每次的变更信息。</li><li><strong>问题</strong>：<ul><li>如果在事务提交前，数据库宕机，写了 redo log 但没写 bin log，会造成主数据库更新了数据，但从数据库拿不到，导致主从不一致。</li><li>如果 bin log 写成功了，redo log 还没从 buffer 里落盘，数据库宕机了，如果此时修改的数据也没落盘，主服务器无法恢复数据，但从数据库会从 bin log 同步数据，导致主从不一致。</li></ul></li><li><strong>bin log 和 redo log 必须同时成功或失败</strong>：<ol><li>redo log 写盘，事务进入 prepare 状态；</li><li>bin log写盘，事务进入 commit 状态；</li><li>都写成功，事务才提交成功。有一个不成功，都会回滚事务。</li></ol></li></ul></li></ol><p><img src="MySQL.assets/202001271019055.png" alt=""></p><hr><h3 id="4-undo-log"><a href="#4-undo-log" class="headerlink" title="4. undo log"></a>4. undo log</h3><ul><li>在数据修改时，不仅会记录 redo log，也会记录 undo log，目的是记录旧的数据。</li><li>undo log 中记录的是与修改操作相反的操作，如使用 <code>INSERT</code> 操作，undo log 中会记录对应的 <code>DELETE</code> 日志。</li></ul><blockquote><p><strong>undo log 的作用</strong></p></blockquote><ol><li>回滚：事务需要回滚时，通过 undo log 中的记录，将数据恢复成事务开始前的状态。</li><li>MVCC：通过 undo log 中的版本链，寻找可见的数据。</li></ol><hr><h3 id="5-slow-query-log"><a href="#5-slow-query-log" class="headerlink" title="5.  slow query log"></a>5.  slow query log</h3><ul><li>慢查询日志默认不开启，需要手动开启。</li><li>可设置慢查询时间，long_query_time，默认 10s。</li><li>慢查询不只包括 <code>SELECT</code> 语句，还有 <code>INSERT/UPDATE/DELETE</code> 等，只要超过了指定时间，都会被记录到慢查询日志中。 </li></ul><hr><h3 id="6-relay-log"><a href="#6-relay-log" class="headerlink" title="6. relay log"></a>6. relay log</h3><ul><li>这是<strong>主从复制中从库开启的日志</strong>。</li><li>从库从主库的 bin log 中读取内容，会储存在从库的 relay log 中，然后从 relay log 读取 SQL 语句，更新从库，和主库保持一致。</li></ul><hr><h3 id="7-主从复制"><a href="#7-主从复制" class="headerlink" title="7. 主从复制"></a>7. 主从复制</h3><p>主从复制是指建立一个和主数据库完全一样的数据库，称为从数据库，从数据库的数据要从主数据库中复制过来。</p><blockquote><p><strong>为什么要做主从复制</strong></p></blockquote><ol><li><strong>做数据的热备</strong>：从数据库作为备份数据库，如果主数据库宕机，可切换到从数据库工作。</li><li><strong>架构扩展</strong>：当数据量很大时，访问量过高，一个机器无法满足，这时使用多个数据库储存，可以分散请求。</li><li><strong>读写分离</strong>：可以令主写从读，提高并发量。</li></ol><blockquote><p><strong>主从复制的形式</strong></p></blockquote><ol><li>一主一从：一个主数据库，一个从数据库。</li><li><strong>一主多从</strong>：一个主数据库，多个从数据库，这是最常见的主从架构，简单高效，可以实现读写分离。</li><li>多主一从：多个主数据库把数据备份到一台性能较好的服务器上。</li><li>双主复制：两个数据库互为主从。</li><li><strong>级联复制</strong>：当从库较多时，主库用于同步的消耗较大，可以让 3-5 个从库连接到主库，剩下的从库作为二级或三级节点连接到从节点。</li></ol><blockquote><p><strong>主从复制的原理</strong></p></blockquote><ol><li>master 提交完事务后，写入 bin log。</li><li>slave 连接到 master，获取 bin log。</li><li><strong>master 创建 dump 线程</strong>，推送 bing log 到 slave。</li><li><strong>slave 启动一个 IO 线程</strong>读取同步过来的 master 的 bin log，记录到 relay log 中继日志中。</li><li><strong>slave 再开启一个 SQL 线程</strong>读取 relay log 事件并在 slave 执行，完成同步。</li><li>slave 记录自己的 bin log。</li></ol><p><img src="MySQL.assets/640.webp" alt=""></p><blockquote><p><strong>主库是否确认从库同步成功</strong></p></blockquote><p>MySQL 默认的复制方式是<strong>异步</strong>的，主库把日志发送给从库后不确认从库是否已经处理。这样会产生一个问题就是假设主库宕机，从库处理失败了，这时候从库升为主库后，日志就丢失了。</p><ol><li><strong>全同步复制</strong>：主库确认<strong>所有从库</strong>都同步完成，才认为此次操作完成。</li><li><strong>半同步复制</strong>：从库同步完成后返回 ACK 给主库，主库收到<strong>一个从库</strong>的确认就认为操作完成。</li></ol><hr><h2 id="6-SQL-优化"><a href="#6-SQL-优化" class="headerlink" title="6. SQL 优化"></a>6. SQL 优化</h2><h3 id="1-数据库字段设计规范"><a href="#1-数据库字段设计规范" class="headerlink" title="1. 数据库字段设计规范"></a>1. 数据库字段设计规范</h3><ol><li>优先选择符合存储需要的最小数据类型；</li><li>尽可能把所有列都定义为 NOT NULL，因为 <strong>NULL 值需要额外空间保存且比较和计算时要进行特别的处理</strong>；</li><li>用 TIMESTAMP 或 DATETIME 存储时间，不要使用字符串；</li><li>同财务相关的数据必须使用 DECIMAL 类型，计算时不会丢失精度。</li></ol><hr><h3 id="2-索引设计规范"><a href="#2-索引设计规范" class="headerlink" title="2. 索引设计规范"></a>2. 索引设计规范</h3><ol><li>每张表的索引不要过多；</li><li>每个表都定义一个主键；</li><li>避免冗余索引和重复索引；</li><li><strong>频繁查询的列考虑使用覆盖索引</strong>；</li><li>尽量避免使用外键。</li></ol><hr><h3 id="3-开发规范"><a href="#3-开发规范" class="headerlink" title="3. 开发规范"></a>3. 开发规范</h3><ol><li><strong>避免会导致索引失效的操作语句</strong>；</li><li>禁止使用 * ；</li><li>避免使用子查询。由于子查询的结果集无法使用索引，所以子查询为简单语句时，可以优化为 join 操作；</li><li>在明显不会有重复值时，使用 UNION ALL 而不是 UNION。因为 UNION 会对结果集进行去重操作，UNION ALL 不会；</li><li>查询不要拿全表，可以用 LIMIT 分页，每页的数量也不要太大。</li></ol><hr><h3 id="4-大表优化"><a href="#4-大表优化" class="headerlink" title="4. 大表优化"></a>4. 大表优化</h3><ol><li><strong>优化字段</strong>：如使用 TINYINT、SMALLINT、MEDIUM_INT 作为整数类型而非INT，如果<strong>非负则加上 UNSIGNED</strong>，用整数代替字符串，用整形存 IP 等；</li><li><strong>优化索引</strong>：<ol><li>根据查询有针对性的创建，查询多分布广的列适合建立索引，而如性别这种分布稀疏的列（只有男女两种）不适合建立索引。</li><li>索引也要控制数量，不是越多越好，删除不必要的单利索引。</li><li>多列索引注意顺序，将区分度高的（分布广的）列或使用最频繁的列放在左侧。</li><li>查询频繁的列使用覆盖索引。</li><li>不用外键和 UNIQUE 等，用程序保证约束。</li></ol></li><li><strong>引擎</strong>：MyISAM 适合读操作频繁的情况，InnoDB 适合增删改频繁的情况。</li><li><strong>SQL 优化</strong>：通过日志查找较慢的 SQL，<strong>避免会导致索引失效的操作语句</strong>，使用 LIMIT 分页等。</li><li><strong>缓存</strong>：使用 Redis 等；</li><li><strong>读写分离</strong>：主从复制，主库写从库读，尽量不要采用双主；</li><li><strong>表分区</strong>：物理上将表分为多个区域，但逻辑上还是一张表。</li><li><strong>垂直拆分</strong>：按列分为多张表，但会造成主键冗余，引起 JOIN 操作，事务处理复杂等问题。</li><li><strong>水平拆分</strong>：按行拆分成多张表。若在库内分表，只是解决了单一表数据量过大的问题，对于减轻数据库压力来说没有什么作用。这就要通过分库解决。</li></ol><hr><h3 id="5-分库分表"><a href="#5-分库分表" class="headerlink" title="5. 分库分表"></a>5. 分库分表</h3><p>分库分表分为两种方式，水平和垂直。一般拆分的顺序是<strong>先垂直后水平</strong>。</p><ul><li>垂直分库：把不同服务的数据拆分出多个数据库。</li></ul><p><img src="MySQL.assets/640-1599556975508.webp" alt=""></p><ul><li>垂直分表：如果表里字段很多，将不常用的，数据较大的等等做拆分。</li></ul><p><img src="MySQL.assets/640-1599557020579.webp" alt=""></p><ul><li>水平分表：表中数据量过大，查询变慢，将表水平拆分成多个表。使用场景包括：订单表数据量过大，按照<strong>年、月</strong>水平切分。</li></ul><hr><h3 id="6-分表后-ID-唯一性"><a href="#6-分表后-ID-唯一性" class="headerlink" title="6. 分表后 ID 唯一性"></a>6. 分表后 ID 唯一性</h3><ol><li><strong>设定步长</strong>：如 3 张表就分别为 1 4 7…，2 5 8…，3 6 9…。</li><li><strong>ID 生成算法</strong>：如雪花算法。ID 在单机上是递增的，但可能出现不是全局递增的情况。</li><li><strong>UUID</strong>：确保唯一性，但不建议使用。</li><li><strong>新增主键</strong>：分表后从每张表新增一个字段作为唯一主键使用。比如订单表中订单号是唯一的，在分表后以订单号作为查询依据。</li></ol><hr><h3 id="7-非分表字段（sharding-key）查询"><a href="#7-非分表字段（sharding-key）查询" class="headerlink" title="7. 非分表字段（sharding_key）查询"></a>7. 非分表字段（sharding_key）查询</h3><ol><li>做一个<strong>映射表（mapping）</strong>，把分表字段和非分表字段构成映射，查询分分表字段时先从映射表中查询到分表字段，再通过分表字段查询。</li><li>打宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。</li><li>数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。</li></ol><hr><h3 id="8-为什么不建议使用-UUID-作为主键"><a href="#8-为什么不建议使用-UUID-作为主键" class="headerlink" title="8. 为什么不建议使用 UUID 作为主键"></a>8. 为什么不建议使用 UUID 作为主键</h3><ol><li>UUID虽然能够保证ID的唯一性，但是无法满足业务系统需要的很多其他特性，例如：时间粗略有序性、可反解和可制造性；</li><li>UUID产生时使用完全的时间数据，性能比较差；</li><li>UUID比较长，会占用空间大，间接导致数据库性能下降；</li><li>UUID并不具有有序性，会导致B+树索引在写的时候有过多的随机写操作(连续的ID会产生部分顺序写)；</li><li>在写的时候不能产生有序的append操作，而需要进行insert操作，将读取整个B+树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能会明显下降；</li><li>UUID目前不是顺序增长，做为主键写入导致，随机IO严重。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/08/25/redis/"/>
      <url>/2020/08/25/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><strong><em>Redis</em></strong>（Remote Dictionary Server )，即远程字典服务。是一个开源的使用 C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。</p><p>由于 Redis 基于内存，所以读写速度快，常被用作缓存。另外也经常用来做分布式锁，或消息队列。</p><hr><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h3><ol><li><strong>String 数据结构是简单的 key-value 类型</strong>。Redis 的 String 不光可以保存文本数据，还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)。</li><li><strong>底层实现</strong>：简单动态字符串 SDS。</li><li><strong>常用命令</strong>：<code>set,get,strlen,exists,dect,incr,setex</code> 等等。 </li><li><strong>应用场景</strong>：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> key value <span class="token comment" spellcheck="true">#设置 key-value 类型的值</span>OK127.0.0.1:6379<span class="token operator">></span> get key <span class="token comment" spellcheck="true"># 根据 key 获得对应的 value</span><span class="token string">"value"</span>127.0.0.1:6379<span class="token operator">></span> exists key  <span class="token comment" spellcheck="true"># 判断某个 key 是否存在</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> strlen key <span class="token comment" spellcheck="true"># 返回 key 所储存的字符串值的长度。</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5127.0.0.1:6379<span class="token operator">></span> del key <span class="token comment" spellcheck="true"># 删除某个 key 对应的值</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> get key<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> number 1OK127.0.0.1:6379<span class="token operator">></span> incr number <span class="token comment" spellcheck="true"># 将 key 中储存的数字值增一</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> get number<span class="token string">"2"</span>127.0.0.1:6379<span class="token operator">></span> decr number <span class="token comment" spellcheck="true"># 将 key 中储存的数字值减一</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> get number<span class="token string">"1"</span></code></pre><hr><h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ol><li>Redis 中 List 的实现为一个 <strong>双向链表</strong>，可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li><li><strong>底层实现</strong>：数据量小的时候用 ziplist，一个类似 Python 里 list 的结构，用一段连续的内存储存。数据量大的时候用 linkedlist 双向链表。</li><li><strong>常用命令</strong>： <code>rpush,lpop,lpush,rpop,lrange、llen</code> 等。</li><li><strong>应用场景</strong>：发布与订阅或者说消息队列、慢查询。 </li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 右进左取（左进右取）是队列</span>127.0.0.1:6379<span class="token operator">></span> rpush myList value1 <span class="token comment" spellcheck="true"># 向 list 的头部（右边）添加元素</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> rpush myList value2 value3 <span class="token comment" spellcheck="true"># 向list的头部（最右边）添加多个元素</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3127.0.0.1:6379<span class="token operator">></span> lpop myList <span class="token comment" spellcheck="true"># 将 list的尾部(最左边)元素取出</span><span class="token string">"value1"</span>127.0.0.1:6379<span class="token operator">></span> lrange myList 0 1 <span class="token comment" spellcheck="true"># 查看对应下标的list列表， 0 为 start,1为 end</span>1<span class="token punctuation">)</span> <span class="token string">"value2"</span>2<span class="token punctuation">)</span> <span class="token string">"value3"</span>127.0.0.1:6379<span class="token operator">></span> lrange myList 0 -1 <span class="token comment" spellcheck="true"># 查看列表中的所有元素，-1表示倒数第一</span>1<span class="token punctuation">)</span> <span class="token string">"value2"</span>2<span class="token punctuation">)</span> <span class="token string">"value3"</span><span class="token comment" spellcheck="true"># 右进右取（左进左取）是栈</span>127.0.0.1:6379<span class="token operator">></span> rpush myList2 value1 value2 value3<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3127.0.0.1:6379<span class="token operator">></span> rpop myList2 <span class="token comment" spellcheck="true"># 将 list的头部(最右边)元素取出</span><span class="token string">"value3"</span><span class="token comment" spellcheck="true"># 查看链表长度</span>127.0.0.1:6379<span class="token operator">></span> llen myList<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre><hr><h3 id="3-Hash"><a href="#3-Hash" class="headerlink" title="3. Hash"></a>3. Hash</h3><ol><li>Hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。Hash 是一个 String 类型的 field 和 value 的映射表，其中 field 可以有多个，<strong>特别适合用于存储对象</strong>。比如可以用 Hash 数据结构来存储用户信息，商品信息等等。</li><li><strong>底层实现</strong>：数据量小的时候用 ziplist，数据量大的时候用 hashtable。</li><li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。 </li><li><strong>应用场景:</strong> 系统中对象数据的存储。 </li></ol><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> hset userInfoKey name <span class="token string">"jrk"</span> description <span class="token string">"dev"</span> age <span class="token string">"23"</span>OK127.0.0.1:6379<span class="token operator">></span> hexists userInfoKey name <span class="token comment" spellcheck="true"># 查看 key 对应的 value中指定的字段是否存在。</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> hget userInfoKey name <span class="token comment" spellcheck="true"># 获取存储在哈希表中指定字段的值。</span><span class="token string">"jrk"</span>127.0.0.1:6379<span class="token operator">></span> hget userInfoKey age<span class="token string">"23"</span>127.0.0.1:6379<span class="token operator">></span> hgetall userInfoKey <span class="token comment" spellcheck="true"># 获取在哈希表中指定 key 的所有字段和值</span>1<span class="token punctuation">)</span> <span class="token string">"name"</span>2<span class="token punctuation">)</span> <span class="token string">"jrk"</span>3<span class="token punctuation">)</span> <span class="token string">"description"</span>4<span class="token punctuation">)</span> <span class="token string">"dev"</span>5<span class="token punctuation">)</span> <span class="token string">"age"</span>6<span class="token punctuation">)</span> <span class="token string">"23"</span>127.0.0.1:6379<span class="token operator">></span> hkeys userInfoKey <span class="token comment" spellcheck="true"># 获取 key 列表</span>1<span class="token punctuation">)</span> <span class="token string">"name"</span>2<span class="token punctuation">)</span> <span class="token string">"description"</span>3<span class="token punctuation">)</span> <span class="token string">"age"</span>127.0.0.1:6379<span class="token operator">></span> hvals userInfoKey <span class="token comment" spellcheck="true"># 获取 value 列表</span>1<span class="token punctuation">)</span> <span class="token string">"jrk"</span>2<span class="token punctuation">)</span> <span class="token string">"dev"</span>3<span class="token punctuation">)</span> <span class="token string">"23"</span>127.0.0.1:6379<span class="token operator">></span> hset userInfoKey name <span class="token string">"x1a0kang"</span> <span class="token comment" spellcheck="true"># 修改某个字段对应的值</span>127.0.0.1:6379<span class="token operator">></span> hget userInfoKey name<span class="token string">"x1a0kang"</span></code></pre><hr><h3 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h3><ol><li>Set 类似于 Java 中的 HashSet。Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序。Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，<strong>可以基于 Set 轻易实现交集、并集、差集的操作</strong>。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li><li><strong>底层实现</strong>：数据量小的时候用整数集合，数据量大的时候用 hashtable。</li><li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。 </li><li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景 </li></ol><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> sadd mySet value1 value2 <span class="token comment" spellcheck="true"># 添加元素进去</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> sadd mySet value1 <span class="token comment" spellcheck="true"># 不允许有重复元素</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0127.0.0.1:6379<span class="token operator">></span> smembers mySet <span class="token comment" spellcheck="true"># 查看 set 中所有的元素</span>1<span class="token punctuation">)</span> <span class="token string">"value1"</span>2<span class="token punctuation">)</span> <span class="token string">"value2"</span>127.0.0.1:6379<span class="token operator">></span> scard mySet <span class="token comment" spellcheck="true"># 查看 set 的长度</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> sismember mySet value1 <span class="token comment" spellcheck="true"># 检查某个元素是否存在set 中，只能接收单个元素</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> sadd mySet2 value2 value3<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> sinterstore mySet3 mySet mySet2 <span class="token comment" spellcheck="true"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> smembers mySet31<span class="token punctuation">)</span> <span class="token string">"value2"</span></code></pre><hr><h3 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5. Sorted Set"></a>5. Sorted Set</h3><ol><li>和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</li><li><strong>底层实现</strong>：数据量小的时候用 ziplist，数据量大的时候用跳表，zskiplist 和 zskiplistnode。</li><li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。 </li><li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜。</li></ol><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> zadd myZset 3.0 value1 <span class="token comment" spellcheck="true"># 添加元素到 sorted set 中 3.0 为权重</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> zadd myZset 2.0 value2 1.0 value3 <span class="token comment" spellcheck="true"># 一次添加多个元素</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2127.0.0.1:6379<span class="token operator">></span> zcard myZset <span class="token comment" spellcheck="true"># 查看 sorted set 中的元素数量</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3127.0.0.1:6379<span class="token operator">></span> zscore myZset value1 <span class="token comment" spellcheck="true"># 查看某个 value 的权重</span><span class="token string">"3"</span>127.0.0.1:6379<span class="token operator">></span> zrange  myZset 0 -1 <span class="token comment" spellcheck="true"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span>1<span class="token punctuation">)</span> <span class="token string">"value3"</span>2<span class="token punctuation">)</span> <span class="token string">"value2"</span>3<span class="token punctuation">)</span> <span class="token string">"value1"</span>127.0.0.1:6379<span class="token operator">></span> zrange  myZset 0 1 <span class="token comment" spellcheck="true"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span>1<span class="token punctuation">)</span> <span class="token string">"value3"</span>2<span class="token punctuation">)</span> <span class="token string">"value2"</span>127.0.0.1:6379<span class="token operator">></span> zrevrange  myZset 0 1 <span class="token comment" spellcheck="true"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span>1<span class="token punctuation">)</span> <span class="token string">"value1"</span>2<span class="token punctuation">)</span> <span class="token string">"value2"</span></code></pre><hr><h2 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2. 缓存"></a>2. 缓存</h2><h3 id="1-缓存的作用"><a href="#1-缓存的作用" class="headerlink" title="1. 缓存的作用"></a>1. 缓存的作用</h3><ol><li>数据库的数据存在硬盘上，Redis 则是在内存上，读取速度比数据库快很多，因此高频数据放在缓存中可以提高读取效率。</li><li>数据库能承受的请求数量较小，QPS（Query Per Second）大概都在 1w 左右（4 核 8g），使用 Redis 可以提高 QPS。</li></ol><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt=""></p><hr><h3 id="2-缓存过期"><a href="#2-缓存过期" class="headerlink" title="2. 缓存过期"></a>2. 缓存过期</h3><p>一般情况下，设置保存的缓存数据的时候都会设置一个<strong>过期时间</strong>。</p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> expire key  60 <span class="token comment" spellcheck="true"># 数据在 60s 后过期</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token operator">></span> setex key 60 value <span class="token comment" spellcheck="true"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>OK127.0.0.1:6379<span class="token operator">></span> ttl key <span class="token comment" spellcheck="true"># 查看数据还有多久过期</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 56</code></pre><ul><li>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间 </li></ul><p><strong>过期时间的作用</strong>：</p><ol><li>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，会导致内存不够。</li><li>有些业务就是需要某个数据只在某一时间段内存在，比如短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</li></ol><hr><h3 id="3-过期删除"><a href="#3-过期删除" class="headerlink" title="3. 过期删除"></a>3. 过期删除</h3><p>Redis 通过一个叫做<strong>过期字典（可以看作是 Hash 表）</strong>来保存数据过期的时间。过期字典的键指向Redis 数据库中的某个 key (键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间。</p><p> Redis 采用删除策略是<strong>定期删除+惰性删除</strong>：</p><ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会限制删除操作执行的时长和频率，来减少删除操作对 CPU 时间的影响。</li></ol><hr><h3 id="4-内存淘汰机制"><a href="#4-内存淘汰机制" class="headerlink" title="4. 内存淘汰机制"></a>4. 内存淘汰机制</h3><p>仅仅通过给 key 设置过期时间还是有问题的，因为定期删除和惰性删除可能会漏掉很多过期 key。这样就导致大量过期 key 堆积在内存里。</p><p>为了解决上述问题，Redis 还采用了内存淘汰机制，共有 8 种<strong>内存淘汰策略</strong>：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。常用。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，移除最近最少使用的 数据，<strong>这个是最常用的</strong>。</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。不常用。</li></ol><p>4.0 版本后增加以下两种：</p><ol start="7"><li><p><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。</p></li><li><p><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，移除最不经常使用的数据。</p></li></ol><ul><li>注意新增的两种和之前策略的区别，新增的两种策略都是取<strong>最不经常使用（least frequently used）</strong>的数据，而之前的策略是取<strong>最近最少使用（least recently used）</strong>的数据，有个<strong>时间段的区别</strong>。</li></ul><hr><h3 id="5-缓存穿透"><a href="#5-缓存穿透" class="headerlink" title="5. 缓存穿透"></a>5. 缓存穿透</h3><ol><li><strong>缓存穿透</strong>是指用户请求<strong>缓存和数据库中都没有的数据</strong>。如 id 为 -1 的数据。<ul><li>由于数据库中不存在请求的数据，那么访问数据库后，这个数据也不会被加入缓存。这就导致每次这种请求都要穿透缓存，到达数据库进行查询，给数据库带来巨大的压力。</li></ul></li><li>解决方法：<ol><li><strong>参数校验</strong>：把不合法的请求直接抛出异常信息返回。如 id 不能小于 0，传入手机号长度不对等。</li><li><strong>缓存无效数据</strong>：就算是数据库中没有的数据，也添加一个到缓存中，可以解决该数据请求频繁的情况。但如果无效数据变化频繁，缓存中就会添加大量无效数据，因此最好给无效数据设置较短的过期时间。</li><li><strong>布隆过滤器</strong>：将所有可能的请求值放在布隆过滤器中，当收到用户请求时，判断请求的数据是否在布隆过滤器中，如果不存在直接返回错误信息，存在则继续请求流程。</li></ol></li></ol><hr><h3 id="6-缓存击穿"><a href="#6-缓存击穿" class="headerlink" title="6. 缓存击穿"></a>6. 缓存击穿</h3><ol><li><strong>缓存击穿</strong>是指用户请求<strong>缓存中没有，而数据库中有的数据</strong>。<ul><li>如<strong>某个数据</strong>并发请求大，但在缓存中被过期删除，这时大并发请求就穿过缓存，直接访问数据库，就像在特定的点击穿了一个洞。</li></ul></li><li>解决方法：<strong>给热点数据设置永不过期</strong>。</li></ol><hr><h3 id="7-缓存雪崩"><a href="#7-缓存雪崩" class="headerlink" title="7. 缓存雪崩"></a>7. 缓存雪崩</h3><ol><li><strong>缓存雪崩</strong>是指大量查询<strong>不同数据</strong>的请求，穿过缓存，直接访问数据库。<ul><li>如缓存中<strong>大量数据</strong>过期删除，而查询这些数据的并发请求巨大，全都直接访问数据库，给数据库带来巨大的压力。</li><li>或如缓存出现错误，<strong>宕机或断网</strong>而不能运行，这时所有的请求都会到达数据库，给数据库带来巨大的压力。</li><li>雪崩和击穿不同的是，<strong>击穿是单点击穿，只是某一个数据，而雪崩是大量数据</strong>。</li></ul></li><li>解决方法：<ol><li><strong>过期时间随机</strong>：加入缓存中的数据，过期时间随机设置，防止同一时间大量数据过期。</li><li><strong>热点数据设置永不过期</strong>。</li><li><strong>Redis 集群</strong>：使用多台 Redis，避免单机出现问题整个缓存服务都没办法使用。</li><li><strong>限流</strong>：避免同时处理大量请求。在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li></ol></li></ol><hr><h2 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h2><h3 id="1-Redis-的单线程"><a href="#1-Redis-的单线程" class="headerlink" title="1. Redis 的单线程"></a>1. Redis 的单线程</h3><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> ，这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。 </p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket）。<strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>。</p><hr><h3 id="2-Redis-为什么不使用多线程"><a href="#2-Redis-为什么不使用多线程" class="headerlink" title="2. Redis 为什么不使用多线程"></a>2. Redis 为什么不使用多线程</h3><p>使用多线程的问题：</p><ol><li>单线程编程相比于多线程容易并且<strong>更容易维护</strong>；</li><li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在<strong>死锁</strong>、线程<strong>上下文切换</strong>等问题，甚至会影响性能。</li></ol><p>实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。Redis 6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。 </p><p>Redis 的多线程只是在<strong>网络数据的读写</strong>这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。并且<strong>多线程默认是禁用的</strong>，只使用主线程。如需开启需要修改 redis 配置文件。</p><hr><h2 id="4-事务和持久化"><a href="#4-事务和持久化" class="headerlink" title="4. 事务和持久化"></a>4. 事务和持久化</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><ol><li><strong>MULTI</strong>：使用 MULTI 命令后可以输入多个命令，Redis不会立即执行这些命令，而是将它们放到队列 。</li><li><strong>EXEC</strong>：使用 EXEC 命令后，将执行队列中的所有命令。</li><li><strong>DISCARD</strong>：清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</li><li><strong>WATCH</strong>：当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的状态。注意：使用该命令可以实现 Redis 的乐观锁。 </li></ol><blockquote><p><strong>Redis 事务不支持回滚</strong>，因此若某条命令运行时出错，后面的命令还是会执行。</p></blockquote><ol><li><strong>编译时错误</strong>：如命令格式/语法错误，会在入队后检查出来，使用 EXEC 命令后，会报错停止，<strong>所有语句都不会被执行</strong>。</li><li><strong>运行时错误</strong>：语句语法没有错误，可以正常编译通过，但执行期间出错，如 1 / 0，或对非数字进行加一操作等。使用 EXEC 命令后，<strong>所有命令都会执行，只会在出错的命令行报错，不影响其他命令</strong>。</li></ol><p>为什么不支持回滚：</p><ol><li>大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以避免的。</li><li>Redis 为了<strong>性能方面</strong>就忽略了事务回滚。 </li></ol><hr><h3 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h3><blockquote><p>因为 Redis 数据是保存在内存上的，如果使用 Redis 保存数据，就必须要进行持久化。</p></blockquote><ol><li><p><strong>RDB（Redis DataBase）</strong>：使用快照进行持久化，保存的文件为 dump.rdb。有两种方式：</p><ol><li><code>save</code> 方式，使用主进程进行持久化，把 Redis 中的数据都写入一个临时文件中，全部写完之后，再将临时文件覆盖掉上一次的持久化文件。这种方式进行持久化操作时，<strong>会暂停其他的操作，直到持久化结束</strong>。</li><li><code>bgsave</code> 方式：主进程创建 fork 出一个子进程，由子进程进行持久化操作，方式和上述相同。但这种方式是异步操作，<strong>持久化过程中不会影响其他操作，只会在 fork 过程中暂停其他操作，但时间很短</strong>。 </li></ol></li><li><p><strong>AoF（Append only File）</strong>：将 Redis 中的操作命令记录在一个文件中，每次操作会将命令追加进持久化文件中，文件为 appendonly.aof。</p><ol><li><strong>AoF 方式有一个 AoF 缓冲区</strong>，和 RDB 方式类似，如果每次有一个命令需要写入 AoF 文件，都去硬盘上写入，非常消耗性能，因此命令都会先被写入缓冲区，再写入硬盘。</li><li><strong>重写</strong>：由于 AoF 会一直向文件中追加信息，文件的体积会越来越大，达到一定程度后，就要对持久化文件进行重写。重写时，主进程会 fork 出一个子进程进行重写，<strong>重写与旧文件无关，会直接根据 Redis 中的数据写入命令</strong>，写入一个临时文件，全部重写完成后覆盖旧文件。</li><li><strong>重写为何会缩小文件体积</strong>：原文件中可能有很多冗余操作，如添加后又删除，重写时 Redis 中并没有这个数据，也就不会再写相关的命令。还有一些命令可以合并为一条命令，也可以缩小空间。</li></ol></li></ol><ul><li>AoF 方式默认不开启，如果两种方式都开启，则会产生两个持久化文件，<strong>Redis 在启动时，会优先读取 AoF 方式的持久化文件</strong>，因此这里的数据相对更完整。</li></ul><hr><h3 id="3-两种持久化方式的对比"><a href="#3-两种持久化方式的对比" class="headerlink" title="3. 两种持久化方式的对比"></a>3. 两种持久化方式的对比</h3><blockquote><p><strong>RDB 方式</strong>：</p></blockquote><p><strong>优点</strong>：</p><ol><li>写入的是紧凑的数据，文件占用空间小，全量复制，适合用作备份和灾难恢复。</li><li>恢复数据速度快，在大数据量时，比 AoF 快很多。</li><li><code>bgsave</code> 不会影响其他命令，异步处理。</li></ol><p><strong>缺点</strong></p><ol><li>触发持久化的规则不频繁，若 Redis 宕机，上次持久化之后的数据都会丢失。</li><li>子进程进行持久化时，父进程同时可以进行写入命令，期间的命令不会被子进程持久化，可能造成数据丢失。</li></ol><blockquote><p><strong>AoF 方式</strong>：</p></blockquote><p><strong>优点</strong>：</p><ul><li>持久化操作更频繁，可以每次操作都写入，可以每秒写入一次，最多丢失一秒数据，保存数据更完整。</li></ul><p><strong>缺点</strong>：</p><ol><li>由于持续写入，且写入的是命令，占用空间更大。</li><li>文件多大时会触发重写操作，会 fork 出一个子进程进行重写，同时还要多维护一个缓冲区，消耗较大。</li><li>大数据量情况下，恢复数据速度较 RDB 慢很多。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2020/08/25/spring/"/>
      <url>/2020/08/25/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-IoC-控制反转"><a href="#1-IoC-控制反转" class="headerlink" title="1. IoC 控制反转"></a>1. IoC 控制反转</h2><h3 id="1-什么是-IoC"><a href="#1-什么是-IoC" class="headerlink" title="1. 什么是 IoC"></a>1. 什么是 IoC</h3><p>IoC（Inversion of control ）控制反转/反转控制。<strong>它是一种思想而不是一个技术实现</strong>。描述的是：Java 开发领域对象的创建以及管理的问题。 </p><ul><li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来。</li><li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器（Spring 框架）来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面取出即可。</li></ul><p>使用 IoC 思想开发，<strong>程序（上述中的类 A）不再控制对象（上述中的类 B）的创建和管理，而是由 IoC 容器控制</strong>。相对于传统的开发方式，这里的<strong>控制权由程序转移给了 IoC 容器，这种控制权的转移就是控制反转</strong>。</p><p><strong>IoC 容器实际上就是一个 Map</strong>，其中存放的是各种对象；</p><hr><h3 id="2-IoC-再理解"><a href="#2-IoC-再理解" class="headerlink" title="2. IoC 再理解"></a>2. IoC 再理解</h3><ol><li>传统方法中，两个类直接发生关系（在类 A 中 new 一个 B 的对象），耦合度高；使用 IoC 思想开发，两个类不产生直接关系，对象的控制权由第三方 IoC 托管，<strong>降低了耦合性</strong>；</li><li>当代码的需求产生改变时，新的需求实现类变成了 C，这时需要将 A 类中 new 的对象由 B 改为 C，如果还有其他很多地方也需要新的实现类，代码的修改非常繁琐。<strong>使用 IoC 思想开发后，对象集中管理，便于修改和配置。修改一处配置（配置文件），即可完成修改</strong>。<ul><li>小例子：类似<strong>自动售货机</strong>，其中已经存放了各种货物（实例对象），选择要什么就会给你方法什么。</li></ul></li></ol><hr><h3 id="3-DI-依赖注入"><a href="#3-DI-依赖注入" class="headerlink" title="3. DI 依赖注入"></a>3. DI 依赖注入</h3><p>DI（Dependency Injection）是 IoC 最常见以及最合理的<strong>实现方式</strong>。</p><ul><li><strong>IoC 是思想，DI 是实现方式</strong>。</li></ul><p>A 类需要使用 B 类，即 A 依赖于 B。但在 IoC 思想下，A 不直接创建 B，而是<strong>由 IoC 容器负责创建，然后把 B 注入 A 中，这就是依赖注入</strong>。</p><ol><li><strong>基于 setter 注入</strong>：通过 A 类中为 B 类设置的 setter 方法注入被调用者的实例。</li><li><strong>基于构造器注入</strong>：通过 A 类中的构造器注入被调用者的实例。</li></ol><hr><h3 id="4-容器"><a href="#4-容器" class="headerlink" title="4. 容器"></a>4. 容器</h3><ul><li>BeanFactory 是一个接口，提供了 IoC 容器的简单实现，其下有许多接口和子类实现了更多的功能。</li><li>ApplicationContext 功能更加强大，其子类分别有 <ul><li><strong>ClassPathXmlApplicationContext</strong></li><li><strong>FileSystemXmlApplicationContext</strong></li><li><strong>基于注解的 AnnotationConfigApplicationContext</strong></li><li><strong>专门为 web 应用准备的 WebApplicationContext</strong> 等等</li></ul></li><li><strong>Spring 装配 Bean</strong> 的方式常用的有三种：<ol><li>XML 配置：在 XML 文件中通过 <code>&lt;bean&gt; id class等属性 &lt;/bean&gt;</code> 的方式配置 bean，在程序中通过 ClassPathXmlApplicationContext 读取配置文件，获取实例对象即可。</li><li>注解配置</li><li>Java config 配置。</li></ol></li></ul><hr><h3 id="5-注解方式装配-Bean"><a href="#5-注解方式装配-Bean" class="headerlink" title="5. 注解方式装配 Bean"></a>5. 注解方式装配 Bean</h3><p>使用注解方式的前提条件。</p><ol><li>引入 context 名称空间；</li><li>开启注解扫描器。</li></ol><blockquote><p><strong>常用注解</strong></p></blockquote><ol><li>@Component：加在类上，指定把该类对象加入 IoC 容器。</li><li>@Repository：作用同 @Component，在持久层使用。</li><li>@Service：作用同 @Component，在业务层使用。</li><li>@Controller：作用同 @Component，在控制层使用。</li><li>@Resource：加载类中的变量上，表示依赖关系。<strong>如果不指定值，根据类型查找</strong>，相同类型在 IoC 容器中不能有两个。<strong>如果指定了值，那么根据名字查找</strong>。</li><li>@Configuration：加在类上，表明该类是配置类，<strong>在 Java config 方式中会用到</strong>。</li></ol><blockquote><p><strong>代码示例</strong></p></blockquote><ul><li>持久层</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Repository<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把对象添加到容器中,首字母会小写</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DB:保存用户"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>业务层</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Resource<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把UserService对象添加到IOC容器中,首字母会小写</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果@Resource不指定值，那么就根据类型来找--->UserDao....当然了，IOC容器不能有两个UserDao类型的对象</span>    <span class="token comment" spellcheck="true">//如果指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。</span>    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"userDao"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用持久层方法</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>控制层</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Resource<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把对象添加到IOC容器中,首字母会小写</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAction</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"userService"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用业务层方法</span>        userService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>测试</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ClassPathXmlApplicationContext<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建容器对象，不管是否是XML配置，都要读取XML文件</span>        ApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"aa/applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获得bean实例</span>        UserAction userAction <span class="token operator">=</span> <span class="token punctuation">(</span>UserAction<span class="token punctuation">)</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userAction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用方法</span>        userAction<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>DB:保存用户</code></pre><hr><h3 id="6-Java-config-方式装配-Bean"><a href="#6-Java-config-方式装配-Bean" class="headerlink" title="6. Java config 方式装配 Bean"></a>6. Java config 方式装配 Bean</h3><ul><li>Spring In Action 作者首推使用自动装配的功能，而后是通过 Java 代码配置 bean，最后才用 XML 文件配置的方式。</li></ul><blockquote><p><strong>配置方式</strong></p></blockquote><ol><li>编写一个 Java 类用于显式配置，<strong>用 @Configuration 注解修饰该类</strong>，即表明该类是配置类。</li><li><strong>使用 @Bean 来修饰类中的方法</strong>，该方法返回一个对象，spring 会获得这个方法返回的对象，并加入 IoC 容器中。容器中该对象的 ID 默认为方法名。</li></ol><blockquote><p><strong>代码示例</strong></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@org</span><span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token comment" spellcheck="true">//这一行就是@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Configuration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> UserDao <span class="token function">userDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserDao userDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是在configuration中的userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> userDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>测试代码：要使用 @ContextConfiguration 加载配置类的信息【引入test包】 </li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ClassPathXmlApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ContextConfiguration<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加载配置类的信息</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> Configuration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test33</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ApplicationContext ac <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"bb/bean.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UserDao userDao <span class="token operator">=</span> <span class="token punctuation">(</span>UserDao<span class="token punctuation">)</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>我是在configuration中的userDao</code></pre><hr><h3 id="7-三种方式的混合使用"><a href="#7-三种方式的混合使用" class="headerlink" title="7. 三种方式的混合使用"></a>7. 三种方式的混合使用</h3><ul><li><strong>注解和 XML 配置是可以混合使用的，Java Config和 XML 也是可以混合使用的</strong> </li></ul><ol><li>如果 Java Config 的配置类是分散的，我们一般再创建一个更高级的配置类（root），然后<strong>使用 @Import 来将配置类进行组合</strong>。</li><li>如果XML的配置文件是分散的，我们也是创建一个更高级的配置文件（root），然后<strong>使用 @Import 来将配置类进行组合</strong>。</li><li><strong>在 JavaConfig 引用 XML，使用 @ImportResource()</strong>。</li><li><strong>在 XML 引用 Java Config，在文件中使用 <code>&lt;bean&gt;</code> 节点即可</strong> 。</li></ol><hr><h2 id="2-AOP-面向切面编程"><a href="#2-AOP-面向切面编程" class="headerlink" title="2. AOP 面向切面编程"></a>2. AOP 面向切面编程</h2><h3 id="1-什么是-AOP"><a href="#1-什么是-AOP" class="headerlink" title="1. 什么是 AOP"></a>1. 什么是 AOP</h3><p>AOP（Aspect-Oriented Programming）：面向切面编程。能够将那些<strong>不影响业务逻辑，却为业务模块所调用的逻辑或功能（例如事务处理、日志管理、权限控制等）抽取并封装起来，形成切面，再根据业务流程的要求，把切面切入流程的特定位置</strong>。</p><p>这样做可以<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><hr><h3 id="2-与继承的区别"><a href="#2-与继承的区别" class="headerlink" title="2. 与继承的区别"></a>2. 与继承的区别</h3><ol><li><strong>继承</strong>：从多个类中提取出相同的属性，封装为一个类。这个类作为父类，其他类继承这个父类就都可以获得这些属性。<strong>这些属性是子类一定且全都需要的</strong>。<strong>继承可以看做是自上而下的</strong>，减少重复代码，有利于扩展。</li><li><strong>AOP</strong>：从多个业务模块中抽取出通用的逻辑或功能，封装为一个类。<ul><li><strong>这些逻辑和功能并不一定在每一个业务模块中都出现</strong>。如业务一需要事务处理，业务二需要日志管理，业务三需要权限控制，业务四需要……<strong>业务可能需要这些功能，但不是一定要，也不一定全都要</strong>。</li><li>这些与业务无关，但是业务间通用的功能，可以提取封装在一个类中，<strong>既有事务处理，也有日志管理等功能</strong>。</li><li>当业务流程中需要这些功能时，将其在特定的位置切入。</li></ul></li></ol><hr><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3. 代理模式"></a>3. 代理模式</h3><ul><li><strong>Spring AOP 基于动态代理实现</strong>。</li></ul><p>代理模式就是给某个被代理对象提供一个代理对象，<strong>通过代理对象控制对被代理对象的访问，屏蔽外界对被代理对象的访问</strong>。</p><p>例如：中介。房东将房子交给中介，由中介带租客看房，签合同，房东与租客不需要产生关系。</p><p>代理模式的实现可以分为<strong>静态代理</strong>和<strong>动态代理</strong>。</p><ol><li><strong>静态代理</strong>：由程序员创建或特定工具自动生成源代码，再对其进行编译。<strong>在程序运行之前，代理类.class文件就已经被创建</strong>，代理类和委托类的关系在运行前就确定。</li><li><strong>动态代理</strong>：动态代理类的源码是<strong>在程序运行期间由 JVM 根据反射等机制动态的生成</strong>，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</li></ol><p>具体参考：<a href="https://www.jianshu.com/p/9cdcf4e5c27d" target="_blank" rel="noopener">设计模式之——代理模式</a></p><hr><h3 id="4-常用注解"><a href="#4-常用注解" class="headerlink" title="4. 常用注解"></a>4. 常用注解</h3><ol><li><strong>@Aspect</strong>：指定当前类为切面类，加在类上。</li><li><strong>@Before(“pointCut()”)</strong>：指定当前方法为前置方法，加在 @Aspect 指定类中的方法上。</li><li><strong>@After(“pointCut()”)</strong>：指定当前方法为后置方法，加在 @Aspect 指定类中的方法上。<strong>目标方法之后执行（始终执行）</strong>。</li><li><strong>@Pointcut(“execution(表达式)”)</strong>：指定切入点表达式，即要拦截什么方法。</li><li><strong>@AfterReturning(“pointCut()”)</strong>：返回后通知，<strong>执行方法结束前执行（返回时，可以拿到返回值），异常不执行</strong>。</li><li><strong>@AfterThrowing(“pointCut()”)</strong>：异常通知，<strong>出现异常时执行</strong>。</li><li><strong>@Around(“pointCut()”)</strong>：环绕通知，环绕目标方法执行。</li></ol><blockquote><p><strong>代码示例</strong></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>   <span class="token comment" spellcheck="true">//加入容器</span><span class="token annotation punctuation">@Aspect</span>   <span class="token comment" spellcheck="true">//指定为切面类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AOP</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 指定切入点表达式，拦截哪个类的哪些方法</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* aa.*.*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置通知 : 在执行目标方法之前执行</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointCut_()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始事务/异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置/最终通知：在执行目标方法之后执行  【无论是否出现异常最终都会执行】</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pointCut_()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"提交事务/关闭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回后通知： 在调用目标方法结束后执行 【出现异常不执行】</span>    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"pointCut_()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterReturning()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 异常通知： 当目标方法执行异常时候执行此关注点代码</span>    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span><span class="token string">"pointCut_()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterThrowing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"afterThrowing()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 环绕通知：环绕目标方式执行</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pointCut_()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕前...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行目标方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕后...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h2 id="3-Bean"><a href="#3-Bean" class="headerlink" title="3. Bean"></a>3. Bean</h2><h3 id="1-什么是-Bean"><a href="#1-什么是-Bean" class="headerlink" title="1. 什么是 Bean"></a>1. 什么是 Bean</h3><p>Spring Bean 可复用的组件，由 Spring IoC 容器实例化、组装和管理。</p><p>配置方案：</p><ol><li>XML 文件中配置；</li><li>JAVA 代码显式配置；</li><li>隐式自动装配。</li></ol><hr><h3 id="2-Bean-的作用域"><a href="#2-Bean-的作用域" class="headerlink" title="2. Bean 的作用域"></a>2. Bean 的作用域</h3><ol><li><strong>singleton</strong> : 唯一 bean 实例，<strong>Spring 中的 bean 默认都是单例的</strong>。</li><li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。 </li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 </li><li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li>application：该 bean 仅在当前 ServletContext 内有效。</li><li>websocket：该 bean 仅在当前 WebSocket 内有效。</li></ol><hr><h3 id="3-Bean-的生命周期"><a href="#3-Bean-的生命周期" class="headerlink" title="3. Bean 的生命周期"></a>3. Bean 的生命周期</h3><p>主要是初始化的过程比较长，首先根据类来划分：</p><ul><li><strong>Bean自身的方法</strong>：如调用 Bean 构造函数实例化 Bean，调用 Setter 设置 Bean 的属性值以及 init-method 和 destroy-method 所指定的方法；</li><li><strong>Bean级生命周期接口方法</strong>：如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和 DisposableBean，这些接口方法由 Bean 类直接实现；</li><li><strong>容器级生命周期接口方法</strong>：由 <strong>InstantiationAwareBean PostProcessor</strong> 和 <strong>BeanPostProcessor(BPP)</strong> 这两个接口实现，一般称它们的实现类为“ <strong>后处理器</strong>” 。 后处理器接口一般不由 Bean 本身实现，它们独立于 Bean，实现类以容器附加装置的形式注册到Spring容器中并通过接口反射为 Spring 容器预先识别。当 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。当然，用户可以通过合理地编写后处理器，让其仅对感兴趣 Bean 进行加工处理。</li></ul><p>步骤：</p><ol><li>ResouceLoader 加载配置信息</li><li>BeanDefintionReader 解析配置信息，生成一个一个的 BeanDefintion</li><li>BeanDefintion 由 BeanDefintionRegistry 管理起来</li><li>BeanFactoryPostProcessor 对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)</li><li><strong>实例化Bean</strong></li><li>如果该Bean<code>配置/实现</code>了 InstantiationAwareBean，则调用对应的方法</li><li><strong>使用 BeanWarpper 来完成对象之间的属性配置(依赖)</strong></li><li>如果该Bean<code>配置/实现了</code> Aware 接口，则调用对应的方法</li><li>如果该Bean配置了 <strong>BeanPostProcessor 的 before 方法</strong>，则调用</li><li>如果该Bean配置了 <strong><code>init-method</code></strong> 或者实现 InstantiationBean，则调用对应的方法</li><li>如果该Bean配置了 <strong>BeanPostProcessor 的 after 方法</strong>，则调用</li><li>将对象放入到 HashMap 中</li><li>最后如果配置了 destroy 或者 DisposableBean 的方法，则执行销毁操作</li></ol><p>简要总结：</p><ul><li>BeanDefinitionReader<strong>读取Resource所指向的配置文件资源</strong>，然后解析配置文件。配置文件中每一个``解析成一个<strong>BeanDefinition对象</strong>，并<strong>保存</strong>到BeanDefinitionRegistry中；</li><li>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy<strong>进行Bean实例化的工作</strong>；使用<strong>BeanWrapper完成Bean属性的设置</strong>工作；</li><li>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的<strong>缓存器</strong>，它是一个用HashMap实现的缓存器，单实例的Bean<strong>以beanName为键保存在这个HashMap</strong>中。</li></ul><p><img src="Spring.assets/640.webp" alt=""></p><hr><h2 id="4-Spring-事务"><a href="#4-Spring-事务" class="headerlink" title="4. Spring 事务"></a>4. Spring 事务</h2><h3 id="1-Spring-事务简介"><a href="#1-Spring-事务简介" class="headerlink" title="1. Spring 事务简介"></a>1. Spring 事务简介</h3><ul><li><strong>Spring 事务控制是属于 Spring  DAO 模块的</strong>，因为事务还是针对持久层也就是数据库的。</li><li>而一般的，<strong>Spring 的事务控制都是在 service 层做的</strong>。因为当 service 层调用了多个 DAO 层的方法，而事务控制在 DAO 层，会造成只会回滚出错的方法，其他方法不会回滚。而如果没有出错，会导致多次 commit，影响性能。</li><li>事务控制分为两种：<ul><li><strong>编程式事务控制</strong>：手动控制事务。</li><li><strong>声明式事务控制</strong>：Spring 提供的对事务的控制管理。</li></ul></li></ul><hr><h3 id="2-声明式事务控制"><a href="#2-声明式事务控制" class="headerlink" title="2. 声明式事务控制"></a>2. 声明式事务控制</h3><blockquote><p><strong>简介</strong></p></blockquote><ul><li>用户想要使用声明式事务控制，只需要<strong>配置</strong>即可。</li><li><strong>Spring 事务控制是基于 AOP 实现的</strong>。</li><li>Spring 事务控制的<strong>粒度</strong>可以是整个类，也可以是方法，但<strong>不可以是方法中的某几行</strong>。因为基于 AOP 实现，AOP 拦截的是方法。</li><li>Spring 声明式事务管理器类：<ul><li><strong>JDBC：DataSourceTransactionManager</strong></li><li>Hibernate：HibernateTransactionManager </li></ul></li></ul><blockquote><p><strong>XML 方式实现声明式事务控制</strong></p></blockquote><ol><li>配置事务管理器类：DataSourceTransactionManager</li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--1.配置事务的管理器类:JDBC--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txManage<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--引用数据库连接池--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>配置事务管理器类如何管理事务：</li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--2.配置如何管理事务--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txManage<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--配置事务的属性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--所有的方法，并不是只读--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>配置拦截哪些方法：基于 AOP，<strong>事务一般使用 advisor</strong>。</li></ol><pre class=" language-java"><code class="language-java">    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">3</span><span class="token punctuation">.</span>配置拦截哪些方法<span class="token operator">+</span>事务的属性<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>aop<span class="token operator">:</span>config<span class="token operator">></span>        <span class="token comment" spellcheck="true">//拦截UserService的所有方法</span>        <span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut id<span class="token operator">=</span><span class="token string">"pt"</span> expression<span class="token operator">=</span><span class="token string">"execution(* bb.UserService.*(..) )"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>aop<span class="token operator">:</span>advisor advice<span class="token operator">-</span>ref<span class="token operator">=</span><span class="token string">"txAdvice"</span> pointcut<span class="token operator">-</span>ref<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>aop<span class="token operator">:</span>advisor<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>aop<span class="token operator">:</span>config<span class="token operator">></span></code></pre><blockquote><p><strong>注解方式实现声明式事务控制</strong></p></blockquote><ol><li>配置事务管理器类：DataSourceTransactionManager</li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--1.配置事务的管理器类:JDBC--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txManage<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--引用数据库连接池--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>开启注解方法配置事务</li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--开启以注解的方式实现事务控制--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txManage<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><ol start="3"><li>使用 <strong>@Transactional</strong> 注解进行事务控制，如果需要控制整个类的事务，就加在类上。</li></ol><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//抛出异常，检测回滚</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="3-事务的属性"><a href="#3-事务的属性" class="headerlink" title="3. 事务的属性"></a>3. 事务的属性</h3><p>使用事务控制时，需要设置事务的属性：</p><ol><li>事务的传播行为：默认 Propagation.REQUIRED。</li><li>数据库的隔离级别：默认数据库的默认，加上 Spring 中自定义的四个级别（和数据库中一样）共 5 中隔离级别。</li><li>超时：默认 -1</li><li>只读：默认 false</li><li>遇到什么异常回滚</li><li>遇到什么异常不回滚</li></ol><hr><h3 id="4-事务的传播行为"><a href="#4-事务的传播行为" class="headerlink" title="4. 事务的传播行为"></a>4. 事务的传播行为</h3><p>简单的说，当一个事务方法被另一个方法调用（可以不是事务方法），这个事务方法应该如何进行。</p><blockquote><p><strong>事务的七种传播行为</strong></p></blockquote><ol><li><strong>Propagation_REQUIRED</strong>：默认的传播行为。<strong>如果当前没有事务，就新建一个事务；如果已经存在在一个事务中，就加入这个事务</strong>。外围方法和内部方法同属一个事务，不管哪个方法回滚，整个事务均回滚。</li><li>Propagation_SUPPORTS：如果当前有事务，则加入事务；如果当前没有事务，则以非事务的方式运行。</li><li>Propagation_MANDATORY：使用当前事务，如果没有当前事务，则抛出异常。</li><li><strong>Propagation_REQUIRES_NEW</strong>：新建事务，如果存在当前事务，则将当前事务挂起。<strong>内部方法之间，内部方法与外围方法之间事务均独立</strong>。</li><li>Propagation_NOT_SUPPORTED：以非事务的方式运行，如果存在当前事务，则将当前事务挂起。</li><li>Propagation_NEVER：以非事务的方式运行，如果存在当前事务，则抛出异常。</li><li><strong>Propagation_NESTED</strong>：如果当前没有事务，则新建事务；<strong>如果当前存在事务，新建事务属于外围事务的子事务，可以独立回滚，不影响外围事务，但外围事务回滚，子事务一定回滚</strong>。</li></ol><blockquote><p><strong>REQUIRED、REQUIRES_NEW 和 NESTED 对比</strong></p></blockquote><ul><li>当前不存在事务：<ul><li>REQUIRED：新建事务。</li><li>REQUIRES_NEW：新建事务。</li><li>NESTED：新建事务。</li></ul></li><li>当前存在事务，且内部事务异常：<ul><li>REQUIRED：加入当前事务，外部事务和内部事务一起回滚。</li><li>REQUIRES_NEW：新建事务，内部事务回滚，和外部事务独立，互补干扰。</li><li>NESTED：新建事务，作为外部事务的子事务。内部事务异常，内部事务回滚，不影响外部事务。</li></ul></li><li>当前存在事务，且外部事务异常：<ul><li>REQUIRED：加入当前事务，外部事务和内部事务一起回滚。</li><li>REQUIRES_NEW：新建事务，和外部事务独立，互补干扰，内部事务不回滚。</li><li>NESTED：新建事务，作为外部事务的子事务。外部事务异常，外部事务和内部事务一起回滚。</li></ul></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/2020/08/25/bing-fa/"/>
      <url>/2020/08/25/bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><p>进程：进程是资源分配的基本单位，是系统运行程序的基本单位。开启一个程序如QQ，就是开启了一个进程。</p><p>线程：线程是比进程更小的执行单位，是CPU调度的最小单位。一个进程中可以有多个线程，它们可以共享进程资源。同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><ul><li>通俗的理解为：进程是一个工厂，线程是其中的流水线。</li></ul><p><strong>区别</strong>：</p><ol><li>进程是资源分配的基本单位，一个进程在运行过程中可能产生多个线程；</li><li>进程是资源分配的基本单位，但线程不拥有资源，线程可以访问隶属的进程的资源；</li><li>进程之间是相互独立的，但同一个进程中的线程之间可能相互影响；</li><li>执行进程的开销大于执行线程的开销，但利于资源的管理和保护，因为在执行进程时，系统需要分配或回收资源。</li></ol><hr><h3 id="2-进程的状态"><a href="#2-进程的状态" class="headerlink" title="2. 进程的状态"></a>2. 进程的状态</h3><ol><li>创建状态(new)：进程正在被创建，还没有达到就绪的状态；</li><li>就绪状态(ready)：进程已处理准备运行状态，即进程已获得除处理器之外的一切所需资源，一旦获得处理器资源，即可运行；</li><li>运行状态(running)：进程正在处理器上运行（单核CPU任意时刻只有一个进程处于运行状态）；</li><li>阻塞状态(waiting)：进程等待某一事件而暂停运行的状态，即使处理器空闲，该进程也不能运行；</li><li>结束状态(terminated)：进程正在结束，从系统中消失。可能是进程正常结束，也可能是其他原因中断退出运行。</li></ol><hr><h3 id="3-线程的生命周期和状态"><a href="#3-线程的生命周期和状态" class="headerlink" title="3. 线程的生命周期和状态"></a>3. 线程的生命周期和状态</h3><ol><li>初始状态(new)：线程被创建，但还没有调用 <code>start()</code> 方法。</li><li>运行状态(runnable)：Java 线程将操作系统中的就绪和运行两种状态统称 “运行中” 状态。当线程调用 <code>start()</code> 方法后开始运行，这时处于 ready 状态。可运行状态的线程得到了 CPU 的时间片 (timeslice) 后就处于 running 状态。注：时间片就分配给线程的时间。</li><li>阻塞状态(blocked)：<strong>没有得到 CPU 的执行资格，但当 CPU 空闲时可以抢夺 CPU 资源</strong>。表示线程阻塞于<strong>锁</strong>。当线程调用同步方法时，在没有获取到锁的情况下，线程会进入 blocked 状态。</li><li>等待状态(waiting)：进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断），<strong>当 CPU 空闲时也不可以抢夺 CPU 资源</strong>。当线程执行 <code>wait()</code> 方法后，线程进入 waiting 状态。</li><li>超时等待状态(time_waiting)：不同于 waiting 状态，<strong>可以在指定时间自行返回，可以抢夺 CPU 资源</strong>。<code>wait(long millis)</code> 方法和 <code>sleep()</code> 方法可以将线程置于 time_waiting 状态。</li><li>终止状态(terminated)：表示当前线程已经执行完毕。线程在执行 runnable 的 <code>run()</code> 方法之后，将会进入 terminated 状态。</li></ol><hr><h3 id="4-进程间通信的方式"><a href="#4-进程间通信的方式" class="headerlink" title="4. 进程间通信的方式"></a>4. 进程间通信的方式</h3><ol><li>管道/匿名管道(pipes)：实际是内核中的一段缓存，效率低，只能父子进程间通信。</li><li>命名管道(name pipes)：实际是内核中的一段缓存，效率低，可以无关进程间通信。</li><li>信号(signal)</li><li>消息队列(message queuing)：不适合大数据传输，有用户态和内核态之间拷贝的开销。</li><li>信号量(semaphores)：实现进程间的互斥和同步。</li><li>共享内存(shared memory)：进程间共享，所有进程都能看到。</li><li>套接字(sockets)：不同主机间的进程通信。</li></ol><hr><h3 id="5-线程间的同步方式"><a href="#5-线程间的同步方式" class="headerlink" title="5. 线程间的同步方式"></a>5. 线程间的同步方式</h3><ol><li><p>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。 </p></li><li><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</p></li><li><p>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量； </p></li><li><p>事件：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>对比：</p><ul><li>临界区不是内核对象，互斥量、信号量和事件都是内核对象；</li><li>临界区只能用于进程内部的线程同步；</li><li>互斥量、信号量和事件可以用于不同进程间的线程同步；</li><li>临界区和互斥量都有“线程所有权”的概念，所以它们不能用来实现线程间的同步，只能实现线程间的互斥；</li><li>信号量和事件既可以实现线程间的同步，也可以实现线程间的互斥。</li></ul></li></ol><hr><h3 id="6-死锁产生的四个必要条件"><a href="#6-死锁产生的四个必要条件" class="headerlink" title="6. 死锁产生的四个必要条件"></a>6. 死锁产生的四个必要条件</h3><ul><li><strong>死锁</strong>： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 </li></ul><p>产生条件：</p><ol><li>互斥条件：进程对所分配到的资源进行排他性使用。一段时间内某个资源只能由一个进程使用，其他进程申请使用该资源只能等待，知道拥有者释放资源；</li><li>请求和保持条件：进程已经保持至少一个资源，又提出新的资源请求，该资源被其他进程占用，此请求进程进入阻塞状态，但不释放已保持的资源；</li><li>不剥夺条件：进程已获得的资源，在使用完成前，不能被剥夺，只能使用完成后由自己释放；</li><li>循环等待条件：进入死锁时，必然存在一个进程-资源环形链。</li></ol><hr><h3 id="7-如何避免死锁"><a href="#7-如何避免死锁" class="headerlink" title="7. 如何避免死锁"></a>7. 如何避免死锁</h3><ol><li>破坏互斥条件：做不到，因为用锁就是希望它们互斥；</li><li>破坏请求和保持条件：一次性申请所有资源；</li><li>破坏不剥夺条件：占用部分资源的线程在申请其他资源时，如果申请不到，可以主动释放已有资源；</li><li>破坏循环等待条件：按某一顺序申请资源，反序释放资源。</li></ol><hr><h3 id="8-上下文切换"><a href="#8-上下文切换" class="headerlink" title="8. 上下文切换"></a>8. 上下文切换</h3><ul><li>CPU 给线程分配时间片，执行完时间片后会切换线程；</li><li>切换前会保存当前线程的状态，下次时间片再给到这个线程时可以记得之前的状态；</li><li>从保存线程 A 的状态再切换到线程 B 时，重新加载线程 B 的这个过程叫做上下文切换。</li><li>上下文切换会消耗 CPU 大量时间。</li></ul><p><strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><hr><h3 id="9-sleep-方法和-wait-方法的对比"><a href="#9-sleep-方法和-wait-方法的对比" class="headerlink" title="9. sleep() 方法和 wait() 方法的对比"></a>9. sleep() 方法和 wait() 方法的对比</h3><ol><li><code>wait()</code> 方法是 Object 类中的方法，<code>sleep()</code> 方法是 Thread 类中的方法。</li><li><strong>最主要区别</strong>：<code>sleep()</code> 方法不会释放锁，而 <code>wait()</code> 方法会释放锁；</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code> 通常被用于暂停执行；</li><li><code>wait()</code> 方法被调用后，<strong>线程不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。<code>notify()</code> 方法唤醒的是等待时间最长的线程。<code>sleep()</code> 方法执行完成后，<strong>线程会自动苏醒</strong>。或使用<code>wait(long timeout)</code> 方法超时后，线程会自动苏醒。</li><li>两者都可以暂停线程的执行。</li></ol><hr><h3 id="10-start-方法和-run-方法"><a href="#10-start-方法和-run-方法" class="headerlink" title="10. start() 方法和 run() 方法"></a>10. start() 方法和 run() 方法</h3><p>new 一个 Thread，线程进入了新建状态; 调用 <code>start()</code> 方法，会启动一个线程并使线程进入就绪状态，<code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容。</p><p>而直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，而 <code>run()</code> 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong> </p><hr><h3 id="11-实现多线程-Thread-类和-Runnable-接口的对比"><a href="#11-实现多线程-Thread-类和-Runnable-接口的对比" class="headerlink" title="11. 实现多线程 Thread 类和 Runnable 接口的对比"></a>11. 实现多线程 Thread 类和 Runnable 接口的对比</h3><ul><li>继承 Thread 类和实现 Runnable 接口都可以实现多线程，相对来说更加推荐实现 Runnable 接口的方式。</li><li>由于 Java 中的类是单继承的，如果要继承 Thread 类就不能再继承其他类，这会造成<strong>继承的局限性</strong>。而接口可以多实现，实现接口的同时也可以继承其他类，不会受到影响。</li><li>继承 Thread 类后开启多线，程需要创建多个对象，这些对象是相互独立的，没有<strong>共享资源</strong>。而实现 Runnable 接口的类，只需要一个对象，分别传入三个线程中，这三个线程可以共享这个对象中的资源。</li></ul><hr><h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h2><h3 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h3><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。 </p><ul><li>synchronized 关键字主要有三种使用方式：<ol><li><strong>修饰实例方法</strong>：作用于当前<strong>对象实例</strong>加锁，锁对象就是当前对象实例，就是 <code>this</code>。</li><li><strong>修饰静态方法</strong>：作用于<strong>当前类</strong>加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是<strong>类成员</strong>。这时的锁对象就是当前类的 class 属性，也就是 <strong>class 文件对象（反射）</strong>。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。 </li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。比如创建一个 object 对象，作为锁对象。</li></ol></li></ul><hr><h3 id="2-双重校验锁实现对象单例（还不是很懂）"><a href="#2-双重校验锁实现对象单例（还不是很懂）" class="headerlink" title="2. 双重校验锁实现对象单例（还不是很懂）"></a>2. 双重校验锁实现对象单例（还不是很懂）</h3><p><strong>单例模式</strong>：这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a>。</p><p><strong>注意</strong>：</p><ul><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//uniqueInstance采用volatile 关键字修饰也是很有必要</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行： </p><ol><li>为 uniqueInstance 分配内存空间；</li><li>初始化 uniqueInstance；</li><li>将 uniqueInstance 指向分配的内存地址。</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><ul><li><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。 </li></ul><hr><h3 id="3-synchronized-关键字的底层原理"><a href="#3-synchronized-关键字的底层原理" class="headerlink" title="3. synchronized 关键字的底层原理"></a>3. synchronized 关键字的底层原理</h3><p>在使用 synchronized 来同步代码块的时候，经编译后，会在代码块的起始位置插入 <strong>monitorenter 指令</strong>，在结束或异常处插入 <strong>monitorexit 指令。</strong>当执行到 monitorenter 指令时，将会尝试获取对象所对应的 <strong>monitor</strong> 的所有权，即尝试获得对象的锁。而 synchronized 用的锁是存放在 <strong>Java对象头</strong> 中的。 </p><blockquote><p><strong>对象头和 monitor</strong></p></blockquote><ol><li><p>对象头：</p><p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息，<strong>会随着锁的变化而变化</strong>。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 </p></li></ol><p><img src="%E5%B9%B6%E5%8F%91.assets/2492081-09ff0d7367cc90d8.webp" alt=""></p><ol start="2"><li>monitor：</li></ol><ul><li><p>Monitor 可以理解为一个同步工具或一种同步机制，Monitor 监视器源码是 C++ 写的，通常被描述为一个对象。</p></li><li><p><strong>每一个被锁住的对象都会和一个 monitor 关联</strong>，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 </p></li></ul><p><img src="%E5%B9%B6%E5%8F%91.assets/640-1601257307080.webp" alt=""></p><p>Monitor 源码：</p><pre class=" language-java"><code class="language-java">  <span class="token function">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _header       <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    _count        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    _waiters      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 线程重入次数</span>    _object       <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 存储Monitor对象</span>    _owner        <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 持有当前线程的owner</span>    _WaitSet      <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// wait状态的线程列表</span>    _WaitSetLock  <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    _Responsible  <span class="token operator">=</span> NULL <span class="token punctuation">;</span>    _succ         <span class="token operator">=</span> NULL <span class="token punctuation">;</span>    _cxq          <span class="token operator">=</span> NULL <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 单向列表</span>    FreeNext      <span class="token operator">=</span> NULL <span class="token punctuation">;</span>    _EntryList    <span class="token operator">=</span> NULL <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 处于等待锁状态block状态的线程列表</span>    _SpinFreq     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    _SpinClock    <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    OwnerIsThread <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    _previous_owner_tid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><hr><blockquote><p><strong>锁升级</strong></p></blockquote><p>synchronized 锁在 1.6 之后有一个升级的过程，状态分别为<strong>无锁、偏向锁、轻量级锁和重量级锁</strong>。</p><ul><li><p>无锁：不需要加锁的情况，没有线程抢占资源。</p></li><li><p><strong>偏向锁</strong>：大多数情况下只有一个线程访问同步资源，这时采用偏向锁。当一个新线程要获得锁时，步骤如下：</p><ol><li>查看 Mark Word 中偏向锁标志位是否为 0，如果是 0，用 CAS 操作将线程 ID 改为自己的线程 ID。</li><li>如果标志位不是 0，查看线程 ID 是否和本线程 ID 相同，如果是，则本线程已经拿到了锁，不需要再进行额外操作。</li><li>如果线程 ID 和本线程 ID 不同，则说明偏向锁被其他线程占用，升级为轻量级锁。</li></ol><ul><li>偏向锁只有在获得锁的时候使用了一次 CAS 操作，消耗很小。</li></ul></li><li><p><strong>轻量级锁</strong>：如果参与竞争的线程数不多且占用时间短，<strong>当有一个线程占用资源，而有另一个线程来竞争时，让这个线程自旋等待一段时间</strong>，如果在这段时间内占用资源的线程释放了锁，自旋的线程即可获得锁，提高了效率。步骤如下：</p><ol><li>首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后将对象头中的 Mark Word 复制到锁记录中。</li><li>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。如果成功，则获得轻量级锁，标志位为 00。</li></ol><ul><li><strong>当等待线程自旋结束还没有获得锁时，轻量级锁就会升级为重量级锁，另外当一个线程占用资源，一个线程在自旋等待，这时又有第三个线程来竞争资源时，也会升级为重量级锁</strong>。</li></ul></li><li><p><strong>重量级锁</strong>：参与竞争的线程多，占用时间长。当资源被一个线程占用时，其他来参与竞争的线程进入阻塞状态。即控制权交给了操作系统，由操作系统控制线程的阻塞和唤醒，这个过程需要操作系统在用户态和内核态之间反复切换，会消耗大量系统资源，导致性能低下。步骤如下：</p><ul><li><strong>重量级锁的状态下，对象的 mark word 为指向一个 monitor 对象的指针</strong>。 </li><li>已知 monitor 中维护了三个列表，一个重入次数和一个 owner。</li></ul></li></ul><p><img src="%E5%B9%B6%E5%8F%91.assets/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306164346662653f773d3131303126683d34303026663d7765627026733d3135363832.png" alt=""></p><ol><li>参与竞争的队列会首先进入 ContentionList，这是一个先进后出的结构，每次加入是在队首。</li><li>当 owner 线程要释放锁时，把 ContentionList 中的等待线程加入 EntryList，并选择一个线程作为 onedeck，使其有竞争锁的权利。</li><li>但 onedeck 不是一定会获取锁，这时如果有新的线程来尝试获取锁，是会和其竞争的，所以 synchronized 是非公平锁。</li><li>如果 owner 线程调用了 wait 方法，则加入 waitset 中，直到调用 notify/notifyAll 被唤醒，再重新加入 EntryList。</li></ol><hr><h3 id="4-synchronized-和-ReentrantLock-的对比"><a href="#4-synchronized-和-ReentrantLock-的对比" class="headerlink" title="4. synchronized 和 ReentrantLock 的对比"></a>4. synchronized 和 ReentrantLock 的对比</h3><ol><li>两者都是<strong>可重入锁</strong>：“可重入锁”概念是：<strong>自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的<strong>计数器</strong>都自增1，所以要等到锁的计数器下降为0时才能释放锁。 </li><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong>：synchronized 是依赖于 JVM 实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li><li><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong>：<ul><li><strong>等待可中断</strong>：ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<strong>正在等待锁的线程可以选择放弃等待，改为处理其他事情</strong>。 </li><li><strong>可实现公平锁</strong>：<strong>ReentrantLock 可以指定是公平锁还是非公平锁，而 synchronized 只能是非公平锁</strong>。<strong>所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。 </li><li><strong>可实现选择性通知</strong>：synchronized 关键字与 <code>wait()</code> 和 <code>notify()</code>/<code>notifyAll()</code> 方法相结合可以实现等待/通知机制。ReentrantLock 类借助于 Condition 接口与 <code>newCondition()</code> 方法也可以实现。Condition 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用 <code>notify()</code>/<code>notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。 </li></ul></li></ol><hr><h3 id="5-volatile-关键字"><a href="#5-volatile-关键字" class="headerlink" title="5. volatile 关键字"></a>5. volatile 关键字</h3><blockquote><p><strong>JMM（ Java 内存模型）</strong></p></blockquote><p>描述 Java 中各种变量的访问规则。线程有自己的工作内存，<strong>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</strong>因此可能导致一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在工作内存中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><p><img src="%E5%B9%B6%E5%8F%91.assets/640.webp" alt=""></p><blockquote><p><strong>缓存一致性和嗅探</strong></p></blockquote><ul><li><strong>缓存一致性</strong>是指，当 CPU 写数据时，如果发现操作的变量是共享变量，会发出信号通知其他 CPU 将该变量的缓存置为无效状态，因此其他 CPU 需要读取这个变量时，就会从内存重新读取。 </li><li><strong>嗅探</strong>机制是指，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的数据被修改，就会将当前处理器的缓存行设置成无效状态。</li></ul><blockquote><p><strong>happens-before</strong></p></blockquote><p><strong>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系</strong>。 </p><ol><li><strong>程序次序规则</strong>：在<strong>一个线程内</strong>一段代码的<strong>执行结果是有序的。</strong>就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。</li><li><strong>锁定规则</strong>：就是无论是在单线程环境还是多线程环境，对于<strong>同一个锁</strong>来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。</li><li><strong>volatile变量规则</strong>：就是如果一个线程先去写一个 volatile 变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li><li><strong>线程启动规则</strong>：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。 </li><li><strong>线程终止规则</strong>：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。 </li><li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。 </li><li><strong>传递规则</strong>：这个简单的，就是 happens-before 原则具有传递性，即 A happens-before B ， B happens-before C，那么 A happens-before C。 </li></ol><blockquote><p><strong>内存屏障</strong></p></blockquote><p>volatile 满足 happens-before 规则，其实现是用<strong>内存屏障</strong>。分为读（load）和写（store），屏障的实现在不同的处理器中不一定一样，比如 Intel 就定义了 4 个内存屏障，效果并不和以下说的一样。</p><ul><li><strong>LoadLoad</strong>：对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 Load2 及后续所有读取操作被执行前，保证 Load1 要读取的数据被读取完毕。 </li><li><strong>LoadStore</strong>：对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 Store2 及后续写入操作被执行前，保证Load1 要读取的数据被读取完毕。 </li><li><strong>StoreStore</strong>：对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 Store2 及后续写入操作执行前，保证Store1 的写入操作对其它处理器可见。 </li><li><strong>StoreLoad</strong>：对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 Load2 及后续所有读取操作执行前，保证Store1 的写入对其他处理器可见。</li></ul><blockquote><p><strong>volatile 实现</strong></p></blockquote><p> volatile 写是在前面和后面<strong>分别插入内存屏障</strong>，而 volatile 读操作是在<strong>后面插入两个内存屏障</strong>。</p><ul><li>volatile 在写之前加入 StoreStore，在写之后加入 StoreLoad。</li><li>volatile 在读之后加入 LoadLoad 和 LoadStore。</li><li><strong>理解</strong>：这样可以保证<strong>不论读写是什么顺序，都不会重排序</strong>。</li></ul><p><img src="%E5%B9%B6%E5%8F%91.assets/640-1601218059639.webp" alt=""></p><p><img src="%E5%B9%B6%E5%8F%91.assets/640-1601218074021.webp" alt=""></p><hr><h3 id="6-并发编程的三个重要特性"><a href="#6-并发编程的三个重要特性" class="headerlink" title="6. 并发编程的三个重要特性"></a>6. 并发编程的三个重要特性</h3><ol><li><strong>原子性</strong>：表示一个操作或多次操作，是<strong>不可中断的</strong>，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。<code>synchronized</code> 可以保证代码片段的原子性。 </li><li><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。 </li><li><strong>有序性</strong>：并发时，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><hr><h3 id="7-synchronized-关键字和-volatile-关键字的关系"><a href="#7-synchronized-关键字和-volatile-关键字的关系" class="headerlink" title="7. synchronized 关键字和 volatile 关键字的关系"></a>7. synchronized 关键字和 volatile 关键字的关系</h3><ul><li><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在。</li></ul><ol><li><strong>volatile 关键字</strong>是线程同步的 <strong>轻量级实现</strong>，所以 <strong>volatile 性能肯定比 synchronized 关键字要好</strong>。但是 <strong>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</li><li><strong>多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞</strong>。</li><li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong> </li><li><strong>volatile</strong> 关键字主要用于解决<strong>变量</strong>在多个线程之间的<strong>可见性</strong>，而 <strong>synchronized</strong> 关键字解决的是多个线程之间访问资源的<strong>同步性</strong>。</li></ol><hr><h3 id="8-用户态和内核态"><a href="#8-用户态和内核态" class="headerlink" title="8. 用户态和内核态"></a>8. 用户态和内核态</h3><hr><h2 id="3-ThreadLocal-和-线程池"><a href="#3-ThreadLocal-和-线程池" class="headerlink" title="3. ThreadLocal 和 线程池"></a>3. ThreadLocal 和 线程池</h2><h3 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong>JDK 中提供的 <code>ThreadLocal</code> 类正是为了解决这样的问题。 </p><p><code>ThreadLocal</code> 类主要解决的就是让<strong>每个线程绑定自己的值</strong>。如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的<strong>本地副本</strong>。<strong>他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值</strong>，从而避免了线程安全问题。</p><hr><h3 id="2-ThreadLocal-原理"><a href="#2-ThreadLocal-原理" class="headerlink" title="2. ThreadLocal 原理"></a>2. ThreadLocal 原理</h3><ol><li><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类</strong>。 </li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * ThreadLocalMap is a customized hash map suitable only for     * maintaining thread local values. No operations are exported     * outside of the ThreadLocal class. The class is package private to     * allow declaration of fields in class Thread.  To help deal with     * very large and long-lived usages, the hash table entries use     * WeakReferences for keys. However, since reference queues are not     * used, stale entries are guaranteed to be removed only when     * the table starts running out of space.     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span></code></pre><ol start="2"><li><strong><code>Thread</code> 类中有两个 <code>ThreadLocalMap</code> 类型的变量</strong>，我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null。<strong>ThreadLocalMap 虽然是ThreadLocal 的内部类，但是作为变量由线程来维护的</strong>。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*...其他属性...*/</span>    <span class="token comment" spellcheck="true">/* ThreadLocal values pertaining to this thread. This map is maintained     * by the ThreadLocal class. */</span>    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * InheritableThreadLocal values pertaining to this thread. This map is     * maintained by the InheritableThreadLocal class.     */</span>    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap inheritableThreadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><ol start="3"><li>当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code> 或 <code>get</code> 方法来修改和获取 value 时，实际上调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code> 方法。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获得当前线程</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//得到当前线程中维护的ThreadLocalMap</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ThreadLocalMap的key值就是当前的ThreadLocal(this)，value就是要设置的value</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//调用的是ThreadLocalMap的set方法</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获得当前线程</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//得到当前线程中维护的ThreadLocalMap</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//传入的key值就是当前的ThreadLocal(this)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用的是ThreadLocalMap的get方法</span>        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值。</strong></li></ul><hr><h3 id="3-ThreadLocal-内存泄漏问题"><a href="#3-ThreadLocal-内存泄漏问题" class="headerlink" title="3. ThreadLocal 内存泄漏问题"></a>3. ThreadLocal 内存泄漏问题</h3><ul><li><p>观察源码可以发现，<code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。 </p></li><li><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后 最好手动调用 <code>remove()</code> 方法。</p></li></ul><hr><h3 id="4-使用线程池的好处"><a href="#4-使用线程池的好处" class="headerlink" title="4. 使用线程池的好处"></a>4. 使用线程池的好处</h3><ol><li><strong>降低资源消耗</strong>：重复利用已创建的线程来降低创建和销毁线程造成的消耗。</li><li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要的等到线程创建，只需要从线程池中取出空闲的线程，就能立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的<strong>分配，调优和监控</strong>。</li></ol><hr><h3 id="5-线程池的使用"><a href="#5-线程池的使用" class="headerlink" title="5. 线程池的使用"></a>5. 线程池的使用</h3><ol><li><strong>Executor</strong> 是一个顶层接口，在它里面只声明了一个方法 <code>execute(Runnable)</code>，返回值为void，参数为 Runnable 类型，从字面意思可以理解，就是用来执行传进去的任务的； </li><li><strong>ExecutorService</strong> 接口继承了 Executor 接口，并声明了一些方法：<code>submit()</code>、<code>invokeAll()</code> 以及 <code>shutdown()</code> 等；</li><li>抽象类 <strong>AbstractExecutorService</strong> 实现了 ExecutorService 接口，基本实现了ExecutorService 中声明的所有方法；</li><li><strong>ThreadPoolExecutor</strong> 继承了类 AbstractExecutorService。</li></ol><ul><li><p>在 <strong>ThreadPoolExecutor</strong> 类中有几个重要的方法：<code>execute(Runnable)</code>、<code>submit()</code> 和 <code>shutdown()</code>等。</p></li><li><p>《阿里巴巴Java开发手册》中强制线程池<strong>不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式</strong>。</p></li></ul><hr><h3 id="6-线程池的种类"><a href="#6-线程池的种类" class="headerlink" title="6. 线程池的种类"></a>6. 线程池的种类</h3><ul><li><strong>Executors</strong> 是 java.util.concurrent 包下的一个类，提供了若干个静态方法，用于生成不同类型的线程池。Executors一共可以创建下面这四类线程池： </li></ul><ol><li><strong>FixedThreadPool</strong> ： 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 该方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong>ScheduledThreadPool：</strong> 该方法返回一个<strong>可定期或者延时执行任务的定长线程池</strong>，支持定时及周期性任务执行。</li></ol><ul><li>ExecutorService 接口有两个实现类，分别是 AbstractExecutorService 和 <strong>ScheduledExecutorService</strong>，通过这个实现类也可以创建 ScheduledThreadPool。</li></ul><hr><h3 id="7-实现-Runnable-接口和-Callable-接口的区别"><a href="#7-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="7. 实现 Runnable 接口和 Callable 接口的区别"></a>7. 实现 Runnable 接口和 Callable 接口的区别</h3><p><code>Runnable</code> 自 Java 1.0以来一直存在，但 <code>Callable</code> 在 Java 1.5中引入，目的就是为了来处理 <code>Runnable</code> 不支持的用例。</p><p><strong><code>Runnable</code> 接口</strong>不会<strong>返回结果</strong>或<strong>抛出异常</strong>，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。 </p><ul><li><code>Runnable</code> 接口，只声明了一个 <code>run()</code> 方法，且<strong>无返回值</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * 被线程执行，没有返回值也无法抛出异常    */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><code>Callable</code> 接口，泛型接口，只声明了一个 <code>call()</code> 方法，<strong>返回值类型是传递进来的 V 类型，且会抛出异常</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 计算结果，或在无法这样做时抛出异常。     * @return 计算得出的结果     * @throws 如果无法计算结果，则抛出异常     */</span>    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。 </li></ul><hr><h3 id="8-execute-方法和-submit-方法的区别"><a href="#8-execute-方法和-submit-方法的区别" class="headerlink" title="8. execute() 方法和 submit() 方法的区别"></a>8. execute() 方法和 submit() 方法的区别</h3><ol><li><strong>返回值</strong>：<code>execute()</code>方法用于提交<strong>不需要返回值</strong>的任务，所以无法判断任务是否被线程池执行成功与否；<code>submit()</code> 方法用于提交<strong>需要返回值</strong>的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值。</li><li><strong>可接受的任务类型</strong>：<code>execute()</code>方法<strong>只能接受 Runnable 类型的任务</strong>；<code>submit()</code> 方法既可以接受 Runnable 类型的任务，<strong>也可以接受 Callable 类型的任务</strong>。</li><li><strong>异常处理</strong>：<code>execute()</code> 接受的是 Runnable 接口的任务，所以只能使用 try、catch 来捕获CheckedException，通过实现 UncaughtExceptionHandle 接口处理 UncheckedException，即和普通线程的处理方式完全一致；<code>submit()</code> 方法不管接受的是什么任务，都要通过返回值 <code>Future</code> 的 <code>get()</code> 方法来处理异常，否则都会吞掉异常。<code>submit()</code> 中的 <code>call()</code> 方法可以抛出异常，所以不管是 CheckedException 还是 UncheckedException，直接抛出即可。总结：<strong><code>submit()</code> 方法处理异常更方便</strong>。</li></ol><hr><h3 id="9-ThreadPoolExecutor-类分析"><a href="#9-ThreadPoolExecutor-类分析" class="headerlink" title="9.  ThreadPoolExecutor 类分析"></a>9.  ThreadPoolExecutor 类分析</h3><ol><li><p>重要参数（7大参数）分析</p><ol><li><strong>corePoolSize</strong>：核心线程数。定义了<strong>最小可以同时运行的线程数量</strong>。<ol><li>CPU 密集型：可以设置为 CPU 核数 + 1；</li><li>IO 密集型：可以设置为 CPU 核数 * 2；</li></ol></li><li><strong>maximumPoolSize</strong>：最大线程数。当队列中存放的任务达到队列容量时，当前可以运行的线程数变成最大线程数。</li><li><strong>workQueue</strong>：等待队列，一般使用 BlockingQueue，如 ArrayBlockingQueue，LinkedBlockingQueue。当前运行的线程数到达<strong>核心线程数</strong>时，新来的任务就会被存放在队列中。 </li><li><strong>keepAliveTime</strong>：当线程池中的线程数大于 <strong>corePoolSize</strong> 时，又没有新任务提交，<strong>核心线程外的线程</strong>会等待 keepAliveTime 后被回收销毁。</li><li><strong>unit</strong>：keepAliveTime 参数的时间单位。</li><li><strong>threadFactory</strong>：创建新线程时使用。</li><li><strong>handler</strong>：<strong>饱和策略</strong>。</li></ol></li><li><p>饱和策略</p><p><strong>定义</strong>：如果<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满</strong>了时，<code>ThreadPoolTaskExecutor</code> 定义一些策略: </p><ul><li><p><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code> 来拒绝新任务的处理。</p></li><li><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程（<strong>我理解为当前线程</strong>）运行任务，也就是直接在调用 <code>execute</code> 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</p></li><li><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</p></li><li><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。 </p></li><li><p><strong>总结</strong>：当不指定饱和策略时，默认使用 <strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。 </p></li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="10-线程池Demo：Runnable-TreadPoolExecutor"><a href="#10-线程池Demo：Runnable-TreadPoolExecutor" class="headerlink" title="10. 线程池Demo：Runnable + TreadPoolExecutor"></a>10. 线程池Demo：Runnable + TreadPoolExecutor</h3><ul><li>首先创建 Runnable 接口的实现类：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 * @author shuang.kou */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String command<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里写一个带参构造我没有看出作用，为此还重写了toString方法</span>    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Start. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" End. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CORE_POOL_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long KEEP_ALIVE_TIME <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用阿里巴巴推荐的创建线程池的方式</span>        <span class="token comment" spellcheck="true">//通过ThreadPoolExecutor构造函数自定义参数创建</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                CORE_POOL_SIZE<span class="token punctuation">,</span>                MAX_POOL_SIZE<span class="token punctuation">,</span>                KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//共创建了十个MyRunnable线程任务</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>            Runnable worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//执行Runnable</span>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//终止线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//自旋，等待线程池终止</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finished all threads"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>输出为：</li></ul><pre class=" language-java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span></code></pre><hr><h3 id="11-线程池原理-执行策略"><a href="#11-线程池原理-执行策略" class="headerlink" title="11. 线程池原理 / 执行策略"></a>11. 线程池原理 / 执行策略</h3><p><img src="02-%E5%B9%B6%E5%8F%91.assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p><hr><h2 id="4-Atomic原子类-和-AQS"><a href="#4-Atomic原子类-和-AQS" class="headerlink" title="4. Atomic原子类 和 AQS"></a>4. Atomic原子类 和 AQS</h2><h3 id="1-Atomic原子类和其4种类型"><a href="#1-Atomic原子类和其4种类型" class="headerlink" title="1. Atomic原子类和其4种类型"></a>1. Atomic原子类和其4种类型</h3><ul><li>原子类就是具有原子性/原子操作特征的类。</li><li>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下 。</li></ul><ol><li><strong>原子更新基本类型</strong>：使用原子的方式更新基本类型<ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔型原子类</li></ul></li><li><strong>原子更新数组类型</strong>：使用原子的方式更新数组里的某个元素<ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul></li><li><strong>原子更新引用类型</strong>：<ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul></li><li><strong>原子更新字段（修改对象的属性）</strong>：<ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul></li></ol><hr><h3 id="2-AtomicInteger-的使用"><a href="#2-AtomicInteger-的使用" class="headerlink" title="2. AtomicInteger 的使用"></a>2. AtomicInteger 的使用</h3><ul><li>AtomicInteger 类的常用方法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并设置新的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并自增</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并自减</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并加上预期的值</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></code></pre><ul><li>AtomicInteger 类的使用示例：使用 AtomicInteger 之后，<strong>不用对 <code>increment()</code> 方法加锁也可以保证线程安全</strong>。 </li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AtomicIntegerTest</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建一个AtomicInteger对象，通过对象调用方法</span>        <span class="token keyword">private</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="3-AtomicInteger-类的原理"><a href="#3-AtomicInteger-类的原理" class="headerlink" title="3. AtomicInteger 类的原理"></a>3. AtomicInteger 类的原理</h3><ul><li>AtomicInteger 类的部分源码：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span></code></pre><hr><h3 id="4-CAS"><a href="#4-CAS" class="headerlink" title="4. CAS"></a>4. CAS</h3><hr><h3 id="5-AQS-Abstract-Queued-Synchronizer"><a href="#5-AQS-Abstract-Queued-Synchronizer" class="headerlink" title="5. AQS(Abstract Queued Synchronizer)"></a>5. AQS(Abstract Queued Synchronizer)</h3><p>AQS核心思想是，如果被请求的共享资源<strong>空闲</strong>，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为<strong>锁定状态</strong>。如果被请求的共享资源被<strong>占用</strong>，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将<strong>暂时获取不到锁的线程加入到队列中</strong>。</p><ul><li>CLH(Craig,Landin,and Hagersten)队列是一个<strong>虚拟</strong>的双向队列（<strong>虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系</strong>）。AQS 是将每条请求共享资源的线程封装成一个CLH 锁队列的一个结点（Node）来实现锁的分配。 </li></ul><p>AQS使用一个 <strong>int volatile 成员变量 state</strong> 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS使用 CAS 对该同步状态进行原子操作实现对其值的修改。状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//共享变量，使用volatile修饰保证线程可见性</span><span class="token comment" spellcheck="true">//返回同步状态的当前值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 设置同步状态的值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>         state <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="6-AQS-对资源的共享方式"><a href="#6-AQS-对资源的共享方式" class="headerlink" title="6. AQS 对资源的共享方式"></a>6. AQS 对资源的共享方式</h3><p>AQS定义<strong>两种资源共享方式</strong>：</p><ol><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。这其中又可以分为<strong>公平锁</strong>和<strong>非公平锁</strong>。<ul><li><strong>公平锁</strong>：按照线程在队列中顺序，先到者先拿到锁。</li><li><strong>非公平锁</strong>：所有线程同时抢锁，与顺序无关。</li></ul></li><li><strong>Share</strong>（共享）：多个线程可以同时执行，如 Semaphore/CountDownLatch。</li></ol><hr><h3 id="7-AQS-组件"><a href="#7-AQS-组件" class="headerlink" title="7. AQS 组件"></a>7. AQS 组件</h3><ul><li><strong>Semaphore</strong>（信号量）：允许多个线程同时访问。synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch</strong>（倒计时器）：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以用 await 方法让某一个线程等待直到倒计时结束，再开始执行，倒计时方法为 countDown。</li><li><strong>CyclicBarrier</strong>（循环栅栏）：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，调用 await 方法让一组线程阻塞，直到线程数量达到设定的值时，屏障才会开门，所有被屏障拦截的线程才会继续工作。并且这个屏障是可以循环使用的。</li></ul><hr><p>AQS原理和相关源码分析的文章：</p><p><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></p><p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器</title>
      <link href="/2020/08/25/rong-qi/"/>
      <url>/2020/08/25/rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="1-容器总结"><a href="#1-容器总结" class="headerlink" title="1. 容器总结"></a>1. 容器总结</h2><h3 id="1-继承关系"><a href="#1-继承关系" class="headerlink" title="1. 继承关系"></a>1. 继承关系</h3><ul><li><p><strong>Collection</strong> 接口</p><ul><li><p><strong>List</strong> 接口</p><ol><li><strong>ArrayList</strong>：Object数组。线程不安全。</li><li><strong>Vector</strong>：Object数组。线程安全。<ol start="3"><li><strong>LinkedList</strong>：双向链表（JDK 1.6 前为循环链表，JDK 1.7取消了循环）。线程不安全。</li></ol></li></ol></li><li><p><strong>Set</strong> 接口</p><ol><li>*<em>HashSet *</em>：无序，唯一。基于 HashMap 实现，底层采用 HashMap 来保存元素。</li><li><strong>LinkedHashSet</strong>：LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。 <ol start="3"><li><strong>TreeSet</strong>：有序，唯一。红黑树实现。</li></ol></li></ol></li><li><p><strong>Queue</strong> / Dqueue 接口</p><ol><li><strong>LinkedList</strong>：双向链表（JDK 1.6 前为循环链表，JDK 1.7取消了循环）。线程不安全。<ol start="2"><li><strong>PriorityQueue</strong>：优先队列，元素必须是可比较的，是<strong>小根堆的实现</strong>。</li></ol></li></ol></li></ul></li><li><p><strong>Map</strong> 接口</p><ul><li><p><strong>HashMap</strong>：  JDK1.8之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）而小于 64时，那么会选择先进行数组扩容，当链表长度大于64时，将链表转化为红黑树，以减少搜索时间 。</p></li><li><p><strong>LinkedHashMap</strong>：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 </p></li><li><p><strong>Hashtable</strong>：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p></li><li><p><strong>TreeMap</strong>：有序哈希表，对加入的元素进行排序，红黑树实现。 </p></li></ul></li></ul><p><img src="03-%E5%AE%B9%E5%99%A8.assets/Java-Collections.jpeg" alt=""></p><hr><h3 id="2-如何选用集合"><a href="#2-如何选用集合" class="headerlink" title="2. 如何选用集合"></a>2. 如何选用集合</h3><ol><li>需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap。</li><li>只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。 </li></ol><hr><h3 id="3-List-Set-Map三者的区别"><a href="#3-List-Set-Map三者的区别" class="headerlink" title="3. List, Set, Map三者的区别"></a>3. List, Set, Map三者的区别</h3><ul><li>List：对付顺序的好帮手。List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象。</li><li>Set：注重独一无二的性质。不允许重复，不可以有多个元素引用相同的对象。</li><li>Map：用Key搜索。使用键值对存储。两个Key可以引用相同的对象，但Key不能重复。</li></ul><hr><h3 id="4-hashcode-和-equals-的区别和联系"><a href="#4-hashcode-和-equals-的区别和联系" class="headerlink" title="4. hashcode 和 equals 的区别和联系"></a>4. hashcode 和 equals 的区别和联系</h3><ul><li><strong><code>equals()</code> 是判断逻辑相等，通俗点说就是内容是否相等</strong>。而 hashcode 是用哈希函数计算出的 32 位 int 值，一般情况下用不到，只有在使用 HashSet 或 HashMap 的时候才会用到，<strong>目的是为了判断对象在列表中的位置</strong>。</li><li>两个<strong>不同对象</strong>的 hashcode 值可能相等，但 <code>equals()</code> 值不可能相等。</li><li>HashSet 在检查重复时，会先检查 hashcode，如果hashcode 值已存在，则调用 <code>equals()</code> 方法检查hashcode相等的对象是否真的相等。</li></ul><ol><li>两个对象 hashcode 相等，它们不一定相等，两个 <code>equals()</code>不一定返回true；</li><li>两个 <code>equals()</code> 返回true，hashcode 一定相等；</li><li>若重写了 <code>equals()</code> 方法，则有必要重写 <code>hashCode()</code> 方法，否则可能导致相同的对象有不同的hashcode；</li></ol><ul><li>举例：若String类重写了 <code>equals()</code> 方法，用来比较字符串的内容是否相等，但没有重写 <code>hashCode()</code> 方法。那么 s1 = juruikang，s2 = juruikang 在调用 <code>equals()</code> 方法时是true，但 <code>hashCode()</code> 方法返回的值不相等（默认返回地址值）。</li></ul><hr><h3 id="5-和-equals-的区别"><a href="#5-和-equals-的区别" class="headerlink" title="5. == 和 equals 的区别"></a>5. == 和 equals 的区别</h3><ol><li>== 如果作用于基本数据类型的变量，则直接比较其值是否相等；<strong>如果作用于引用类型的变量，则比较其指向对象的地址值是否相等</strong>。</li><li><code>equals()</code> 方法的目的是判断逻辑相等，通俗点说就是内容是否相等。<strong>不能作用于基本数据类型的变量，因为其是Object类中的方法</strong>。<strong>如果没有重写 <code>equals()</code> 方法，则比较其指向对象的地址值是否相等</strong>；如果重写了 <code>equals()</code> 方法，如String等类，则比较其所指向对象的内容是否相等。例如包装类 Integer 在缓存池外的数 256，两个等于 256 的 Integer 对象使用 “==” 判断是不相等的，因为这是两个不同的对象，地址值不同。但其实逻辑上来说，这两个值应该相等，于是就使用 <code>equals()</code> 方法进行判断，Integer 类重写了 <code>equals()</code> 方法，比较其内容是否相等，这是符合逻辑的判断。</li></ol><hr><h2 id="2-其他常用类"><a href="#2-其他常用类" class="headerlink" title="2. 其他常用类"></a>2. 其他常用类</h2><h3 id="1-String-的不变性"><a href="#1-String-的不变性" class="headerlink" title="1. String 的不变性"></a>1. String 的不变性</h3><ol><li><strong>String 类被 final 修饰</strong>，说明其不可能被继承了，也就是说任何对 String 的操作方法，都不会被覆盖重写； </li><li><strong>String 中实际保存数据的是一个 char 数组 value</strong>，而这个数组也是被 final 修饰的，且 value 的权限是 private，外部无法访问， String 类中也没有开放对 value 进行赋值的方法，因此 value 一旦被赋值，就无法被修改。</li></ol><ul><li>因为 String 具有不变性，所以 <strong>String 的大多数操作方法，都会返回新的 String</strong>。如<code>replace()</code> <code>substring()</code>等。</li></ul><blockquote><p><strong>String 为什么设置成不可改变的</strong></p></blockquote><ol><li>安全性：许多参数都是字符串的形式，比如通过反射传入全类名，数据库的用户名密码等都是字符串形式，如果可以改变，导致参数错误，会造成安全问题。</li><li>多线程：字符串不可改变因此也就不用担心多线程共享的问题，不需要为了线程安全进行同步。</li><li>用在 hashmap 或 hashset 中，由于不可改变，一个字符串的 hashcode 值是唯一不变的。如果可以改变，已放进 map 中的字符串需要重新调整位置，造成问题。</li><li>类加载器用到字符串，不可变性提供了安全保障。</li><li>使字符串常量池成为可能，如果可以改变，那当多个字符串指向常量池中的同一对象时，一个字符串进行了改变，其他字符串也会跟着改变，造成问题。</li></ol><hr><h3 id="2-String-判断相等"><a href="#2-String-判断相等" class="headerlink" title="2. String 判断相等"></a>2. String 判断相等</h3><ol><li>String 判断相等有两种方法，<code>equals()</code> 和 <code>equalsIgnoreCase()</code>，后者判断相等时，会忽略大小写。<strong>String 判断相等不可以用 <code>==</code></strong>，这只是比较地址是否相等。</li><li><code>equals()</code> 的判断逻辑：当判断两个 String 时，首先判断<strong>地址值</strong>是否相等，若相等再判断<strong>长度</strong>是否相等，若相等则逐一比较 <strong>value</strong> 数组中的字符是否相等，全部相等则返回<code>true</code>。</li></ol><ul><li><strong>== 会漏判虽然地址值不等，但内容相等的字符串</strong>。</li></ul><hr><h3 id="3-String-常量池"><a href="#3-String-常量池" class="headerlink" title="3. String 常量池"></a>3. String 常量池</h3><ul><li>之前位于方法区，方法区在堆中。现在方法区移到元空间，<strong>字符串常量池仍然留在堆中</strong>。</li><li>创建字符串的两种方式</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//直接用双引号创建</span>String s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//用new关键字新建一个字符串对象</span>String s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token operator">==</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><ul><li>两种方式的区别<ol><li>第一种方式创建字符串时， <strong>引用指向字符串常量区</strong>。<strong>JVM首先会去字符串池中查找是否存在”abc”这个对象，如果不存在，则在字符串常量池中创建”abc”这个对象，然后将池中”abc”这个对象的引用地址返回给”abc”对象的引用s1，这样s1会指向字符串常量池中”abc”这个字符串对象；如果存在，则不创建任何对象，直接将池中”abc”这个对象的地址返回，赋给引用s2。</strong> </li><li>第二种方式创建字符串时，<strong>引用指向堆</strong>。 <strong>JVM首先在字符串池中查找有没有”xyz”这个字符串对象，如果没有，则首先在字符串池中创建一个”xyz”字符串对象，然后再在堆中创建一个”xyz”字符串对象，然后将堆中这个”xyz”字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个”xyz”字符串对象。如果有，则不在池中再去创建”xyz”这个对象了，直接在堆中创建一个”xyz”字符串对象，然后将堆中的这个”xyz”对象的地址返回赋给引用s4，这样，s4就指向了堆中创建的这个新的”xyz”字符串对象</strong>。</li></ol></li><li>不管用哪种方式，都会先检查字符串常量池。如果字符串常量池中不存在待创建的字符串，<strong>两种方式都会在字符串常量池中创建这个对象</strong>。</li></ul><hr><h3 id="4-String-的拆分和合并"><a href="#4-String-的拆分和合并" class="headerlink" title="4. String 的拆分和合并"></a>4. String 的拆分和合并</h3><ol><li>拆分：<code>split()</code> 方法返回的是一个 String 数组，要注意的是，<strong>空值是拆分不掉的</strong>，得到的数组中会仍然保存空值。另一点是，<strong>两个相邻的分隔符间，会分离出一个空值</strong>，例如：</li></ol><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span><span class="token string">",a,,b,"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span></code></pre><ol start="2"><li>合并：<code>join()</code> 方法返回一个 String，参数分别是连接符和数据源（数组，可以是 String ，也可以是 list）。但注意的是 <code>join()</code> <strong>不可以链式使用</strong>，如<code>join().join()</code> ，因为第一次的值会被第二次覆盖掉。</li></ol><hr><h3 id="5-StringBuilder-和-StringBuffer"><a href="#5-StringBuilder-和-StringBuffer" class="headerlink" title="5. StringBuilder 和 StringBuffer"></a>5. StringBuilder 和 StringBuffer</h3><ol><li>二者和 String 的区别：<strong>String 中用 char 类型的数组来存储，并且这个数组被 final 修饰，不可修改。因此，想要增加 String 的长度，如 <code>str1 = str1 + "jrk";</code>，会产生多个冗余对象，造成浪费和消耗。</strong>上例中，”jrk” 会先检查常量池，若池中不存在，则现在池中创建一个 “jrk” 对象，再在堆中创建一个对象，与 str1 相加得到一个新的 String 对象，再将原 str1 的引用指向新对象。原地址内的内容和 “jrk” 对象不再被使用，成了冗余对象，等待垃圾回收。<strong>StringBuilder 和 StringBuffer 内部也是用 char 数组存储，但没有被 final 修饰，增加长度时，会复制一个新的 char 数组，加入元素，再把引用指向新的数组。</strong></li><li>StringBuilder 和 StringBuffer 的区别：<strong>StringBuffer 中使用了同步机制，内部方法用 synchronized 修饰，保证了线程安全，而 StringBuilder 不保证线程安全。</strong></li><li>使用建议：StringBuilder 效率最高，不需要保证线程安全时使用 StringBuilder；需要保证线程安全时使用 StringBuffer。</li></ol><hr><h3 id="6-Stack-栈"><a href="#6-Stack-栈" class="headerlink" title="6. Stack 栈"></a>6. Stack 栈</h3><ul><li>是 Vector 的一个子类，同属接口 Collection，List 之下，本质是 List。</li><li>由于继承了 Vector，<strong>线程安全</strong>。</li><li><strong>先进后出</strong>。</li></ul><hr><h2 id="3-各容器常用方法总结"><a href="#3-各容器常用方法总结" class="headerlink" title="3. 各容器常用方法总结"></a>3. 各容器常用方法总结</h2><h3 id="1-Collection-接口共性方法"><a href="#1-Collection-接口共性方法" class="headerlink" title="1. Collection 接口共性方法"></a>1. Collection 接口共性方法</h3><ol><li><code>add(E e)</code>：添加元素</li><li><code>remove(int index)</code>：删除元素</li><li><code>clear()</code>：清空元素</li><li><code>isEmpty()</code>：判断容器是否为空</li><li><code>contains()</code>：判断元素是否存在</li><li><code>size()</code>：返回元素个数</li><li><code>toArray()</code>：转为 Obejct 数组</li></ol><hr><h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2. ArrayList"></a>2. ArrayList</h3><ul><li>所属包：java.util.ArrayList</li><li>线程安全：<strong>CopyOnWriteArrayList</strong>、Vector 和 collections 工具类下的 <code>synchronizedList(List&lt;T&gt; list)</code>。</li><li><strong>常用方法</strong>：<code>add(E e)</code> <code>get()</code> <code>remove(int index)</code> <code>size()</code> 和 <code>toArray()</code> 等，多为 Collection 接口共性方法。</li></ul><hr><h3 id="3-LinkedList"><a href="#3-LinkedList" class="headerlink" title="3. LinkedList"></a>3. LinkedList</h3><ul><li>所属包：java.util.LinkedList</li><li>线程安全：队列接口的线程安全类有阻塞（ConcurrentLinkedQueue）和非阻塞队列（LinkedBlockingQueue），collections 工具类下的 <code>synchronizedList(List&lt;T&gt; list)</code> 也可以接收LinkedList（多态写法）。</li><li><strong>常用方法</strong>：<code>add(E e)</code> <code>addFirst()</code> <code>get(int index)</code> <code>getFirst()</code> <code>getLast()</code> <code>removeFirst()</code> <code>removeLast()</code> <code>size()</code> <code>contains()</code>等。</li></ul><hr><h3 id="4-HashMap"><a href="#4-HashMap" class="headerlink" title="4. HashMap"></a>4. HashMap</h3><ul><li>所属包：java.util.HashMap</li><li>线程安全：<strong>ConcurrentHashMap</strong> 和 ConcurrentSkipListMap，也可以通过  <code>Collections.synchronizedMap()</code> 方法来包装 HashMap。</li><li><strong>常用方法</strong>：<code>put(key value)</code> <code>get(key/value)</code>  <code>containsKey(key)</code> <code>containsValue()</code> <code>remove(key)</code> <code>size()</code> <code>entrySet()</code> <code>keySet()</code> 等。</li></ul><hr><h3 id="5-HashSet"><a href="#5-HashSet" class="headerlink" title="5. HashSet"></a>5. HashSet</h3><ul><li>所属包：java.util.HashSet</li><li>线程安全：<strong>CopyOnWriteArraySet</strong> 和 ConcurrentSkipListSet，<code>Collections.synchronizedSet()</code> 方法来包装 HashSet。</li><li><strong>常用方法</strong>：<code>add(E e)</code> <code>remove(Obj)</code> <code>contains(Obj)</code> <code>size()</code> 等。</li></ul><hr><h3 id="6-StringBuilder-和-StringBuffer"><a href="#6-StringBuilder-和-StringBuffer" class="headerlink" title="6. StringBuilder 和 StringBuffer"></a>6. StringBuilder 和 StringBuffer</h3><ul><li>所属包：java.lang，无需导包。</li><li>线程安全：StringBuilder 线程不安全，StringBuffer 线程安全。</li><li><strong>常用方法</strong>：<code>append(str)</code> <code>charAt()</code> <code>insert(index, str)</code> <code>delete(start, end)</code>（左闭右开） <code>length()</code> <code>reverse()</code> <code>replace(index, str)</code> <code>toString()</code> 等。</li></ul><hr><h3 id="7-Stack"><a href="#7-Stack" class="headerlink" title="7. Stack"></a>7. Stack</h3><ul><li>所属包：java.util.Stack</li><li>线程安全：安全</li><li><strong>常用方法</strong>：<code>push()</code> <code>pop()</code> <code>peek()</code> <code>isEmpty()/empty()</code> 等。</li></ul><hr><h3 id="8-方法对比表"><a href="#8-方法对比表" class="headerlink" title="8. 方法对比表"></a>8. 方法对比表</h3><table><thead><tr><th align="center"></th><th align="center">ArrayList</th><th align="center">LinkedList</th><th align="center">HashSet</th><th align="center">Stack</th><th align="center">HashMap</th><th align="center">StringBuilder / StringBuffer</th></tr></thead><tbody><tr><td align="center">加入元素</td><td align="center"><code>add()</code></td><td align="center"><code>add()</code> / <strong><code>addFirst()</code></strong></td><td align="center"><code>add()</code></td><td align="center"><strong><code>push()</code></strong></td><td align="center"><strong><code>put()</code></strong></td><td align="center"><strong><code>append()</code></strong></td></tr><tr><td align="center">获取元素</td><td align="center"><code>get()</code></td><td align="center"><code>get(index)</code> / <strong><code>getFirst()</code> / <code>getLast()</code></strong></td><td align="center">——</td><td align="center"><code>peek()</code></td><td align="center"><code>get(key)</code> / <code>get(value)</code></td><td align="center"><strong><code>charAt()</code></strong></td></tr><tr><td align="center">删除元素</td><td align="center"><code>remove()</code></td><td align="center"><strong><code>removeFirst()</code> / <code>removeLast()</code></strong></td><td align="center"><code>remove()</code></td><td align="center"><code>pop()</code></td><td align="center"><code>remove(key)</code></td><td align="center"><strong><code>delete(start, end)</code></strong></td></tr><tr><td align="center">容量 / 长度</td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><code>size()</code></td><td align="center"><strong><code>length()</code></strong></td></tr><tr><td align="center">通用方法</td><td align="center"><code>clear()</code> / <code>isEmpty()</code>/ <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code> / <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code>/ <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code>/ <code>contains()</code></td><td align="center"><code>clear()</code> / <code>isEmpty()</code> / <code>containsKey()</code></td><td align="center">——</td></tr><tr><td align="center">其他</td><td align="center">——</td><td align="center">——</td><td align="center">——</td><td align="center">——</td><td align="center"><code>entrySet()</code> / <code>keySet()</code></td><td align="center"><code>toString()</code></td></tr></tbody></table><hr><h2 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h2><h3 id="1-迭代器简介"><a href="#1-迭代器简介" class="headerlink" title="1. 迭代器简介"></a>1. 迭代器简介</h3><p>迭代器位于 java.util 包中。</p><p>迭代器，可以<strong>使得不同的容器使用相同方法进行遍历</strong>，而不管底层数据结构如何。如 ArrayList、LinkedList、HashMap 和 HashSet 等，都可以使用迭代器。</p><p><strong>迭代器（Iterator）是一个接口</strong>，继承了 Iterable 接口的容器，其<strong><code>iterator()</code> 方法返回一个标准的 Iterator 实现</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1. ArrayList、LinkedList和HashSet使用迭代器</span>ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2. 哈希表使用迭代器</span>Map map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可以使用keySet，也可以使用entrySet</span>Iterator iterMap <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Iterator iterMap = map.keySet().iterator();</span><span class="token comment" spellcheck="true">//entrySet中数据的类型是Map.Entry，keySet中key是什么类型就返回什么类型</span>Map<span class="token punctuation">.</span>Entry strMap <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span>iterMap<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//String key = iterator.next();</span></code></pre><hr><h3 id="2-迭代器的使用方法"><a href="#2-迭代器的使用方法" class="headerlink" title="2. 迭代器的使用方法"></a>2. 迭代器的使用方法</h3><p>迭代器中共有三种方法：</p><ol><li><code>next()</code>：返回迭代器的下一个元素；</li><li><code>hasNext()</code>：判断是否还有下一个元素，每次调用 <code>next()</code> 前都会先调用这个方法；</li><li><code>remove()</code>：删除元素。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Integer i <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 删除小于 10 的元素</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="3-迭代器的删除特点"><a href="#3-迭代器的删除特点" class="headerlink" title="3. 迭代器的删除特点"></a>3. 迭代器的删除特点</h3><ol><li>使用 <strong>for 循环</strong>删除 ArrayList 中的元素时，会出现<strong>漏删</strong>的现象。如：1 2 3 3 3 4，如果用 for 循环删除等于 3 的数，会得到 1 2 3 4 的结果。因为在删除第一个 3 后，后面的数发生了前移，第二个 3 来到了第一个 3 的位置，而指针已经指向下一个位置，导致第二个 3 被跳过了。</li><li>在使用 Iterator 遍历容器的同时又对容器进行<strong>增加或者删除</strong>操作的话，会抛出版本号不符的异常。由于容器增加或删除会更新版本号，但迭代器中的版本号和容器初始状态的版本号相同，中途不会更新，当容器和迭代器版本号不同时， <strong><code>next()</code> 方法会抛出异常</strong>。</li><li>迭代器中的 <code>remove()</code> 方法可以避免上述两种情况。<strong>在迭代器的 <code>remove()</code> 方法中，同步了容器和迭代器的版本号</strong>，因此删除时不会漏删，删除后使用 <code>next()</code> 方法也不会抛出异常。</li></ol><hr><h3 id="4-fail-fast-机制"><a href="#4-fail-fast-机制" class="headerlink" title="4. fail-fast 机制"></a>4. fail-fast 机制</h3><blockquote><p>fail-fast 原理</p></blockquote><ul><li>快速失败（fail-fast）是 Java 集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的<strong>结构</strong>进行了修改（增加、删除），<strong>修改内容不算结构修改</strong>。则会抛出 Concurrent Modification Exception。</li><li>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <strong>modCount</strong> 变量。集合在被遍历期间如果<strong>结构</strong>发生变化，就会改变 modCount 的值。每当迭代器使用 <code>hashNext()/next()</code> 遍历下一个元素之前，都会检测 <strong>modCount 变量是否为 expectedmodCount 值</strong>，是的话就返回遍历；否则抛出异常，终止遍历。</li></ul><blockquote><p><strong>解决方法</strong></p></blockquote><ol><li><strong>加锁</strong>：对迭代器和添加、删除等影响集合结构的操作加同一把锁，当迭代器迭代时，使这些操作阻塞。粒度更小的锁可以加在改变 modCount 的方法上，其他操作不能在迭代器运行时修改 modCount。</li><li><strong>使用 COW</strong>：首先 COW 没有 fail-fast 机制，就不可能抛出 Concurrent Modification Exception。其实现原理是 copy on write，<strong>迭代器拿到的只是快照</strong>，如果有其他线程修改集合结构，会拷贝一份数据出去修改，不会影响迭代器中的内容。但缺点也很明显：<ul><li><strong>开销大</strong>：每次修改都会拷贝数组，会创建很多数组，占用内存，给 GC 造成压力。</li><li><strong>实时性</strong>：由于迭代器拿到的只是快照，如果过程中其他线程修改了集合，迭代器无法获得最新的数据。</li></ul></li></ol><blockquote><p>fail-safe 机制</p></blockquote><ul><li>JUC 包下的集合采用的都是 fail-safe 机制，这种机制的原理就是<strong>复制-修改</strong>。集合的修改会首先复制出一个新的集合，在新的集合上修改，也就是 COW 采用的机制。</li></ul><hr><h2 id="5-比较器"><a href="#5-比较器" class="headerlink" title="5. 比较器"></a>5. 比较器</h2><h3 id="1-Comparable-接口"><a href="#1-Comparable-接口" class="headerlink" title="1. Comparable 接口"></a>1. Comparable 接口</h3><p>让目标类实现 Comparable 接口，覆盖重写 <code>compareTo()</code> 方法。这个类在 <code>sort()</code> 等方法比较时，会根据重写的比较规律进行比较。<strong>在 java.lang 包中，不需要导包</strong>。</p><ol><li>如果此对象大于指定对象，返回正整数；</li><li>如果此对象小于指定对象，返回负整数；</li><li>如果此对象大于指定对象，返回零；</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 员工编号  </span>    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 员工薪资  </span>    <span class="token comment" spellcheck="true">// 比较此对象与指定对象的顺序  </span>    <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Employee o<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 比较员工编号，如果此对象的编号大于、等于、小于指定对象，则返回1、0、-1  </span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">></span> o<span class="token punctuation">.</span>id <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">==</span> o<span class="token punctuation">.</span>id <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 如果编号相等，则比较薪资  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 比较员工薪资，如果此对象的薪资大于、等于、小于指定对象，则返回1、0、-1  </span>            result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">></span> o<span class="token punctuation">.</span>salary <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">==</span> o<span class="token punctuation">.</span>salary <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> result<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> </code></pre><hr><h3 id="2-Comparator-接口"><a href="#2-Comparator-接口" class="headerlink" title="2. Comparator 接口"></a>2. Comparator 接口</h3><p>单独定义一个对象比较器，继承 Comparator 接口，并覆盖重写 <code>compare(o1,o2)</code> 方法。<strong>在 java.util 包中，需要导包</strong>。</p><ol><li>如果 o1 大于 o2，返回正整数；</li><li>如果 o1 小于 o2，返回负整数；</li><li>如果 o1 等于 o2，返回零；</li></ol><ul><li><strong>返回 o1 - o2 是升序，返回 o2 - o1 是降序</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">EmployeeComparable</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Employee o1<span class="token punctuation">,</span> Employee o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 比较员工编号，如果此对象的编号大于、等于、小于指定对象，则返回1、0、-1  </span>        <span class="token keyword">int</span> result <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 如果编号相等，则比较薪资  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 比较员工薪资，如果此对象的薪资大于、等于、小于指定对象，则返回1、0、-1  </span>            result <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> result<span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//使用时作为参数传入sort方法中</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>employees2<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">EmployeeComparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><hr><h3 id="3-两种比较器的区别"><a href="#3-两种比较器的区别" class="headerlink" title="3. 两种比较器的区别"></a>3. 两种比较器的区别</h3><ol><li>实现 Comparable 接口要<strong>在类的内部进行修改</strong>，适合自定义类时使用；</li><li>实现 Comparator 接口的比较器不需要修改待比较类，适合<strong>对已有类进行排序</strong>时使用。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/2020/08/25/wang-luo/"/>
      <url>/2020/08/25/wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-OSI-和-TCP-IP-的分层结构"><a href="#1-OSI-和-TCP-IP-的分层结构" class="headerlink" title="1. OSI 和 TCP/IP 的分层结构"></a>1. OSI 和 TCP/IP 的分层结构</h2><h3 id="1-分层介绍"><a href="#1-分层介绍" class="headerlink" title="1. 分层介绍"></a>1. 分层介绍</h3><ul><li>OSI的体系结构分为七层，TCP/IP 的体系结构分为四层；</li><li>学习计算机网络使用的是一种折中的办法，分为五层的体系结构，<strong>从下到上分别为：物理层、数据链路层、网络层、运输层和应用层</strong>。</li></ul><hr><h3 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h3><p><strong>应用层（application layer）</strong>的任务是<strong>通过应用进程间的交互</strong>来完成特定的网络应用。应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。</p><ul><li>对于不同的网络应用需要不同的应用层协议，如<strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等。我们把<strong>应用层交互的数据单元称为报文</strong>。<ul><li><strong>域名系统（DNS，Domain Name System）</strong>是因特网的一项核心服务，它作为可以将<strong>域名和 IP 地址相互映射</strong>的分布式数据库，能够使人们方便的访问互联网，而不用记住 IP 数串。如 <a href="http://www.baidu.com等。" target="_blank" rel="noopener">www.baidu.com等。</a></li><li><strong>超文本传输协议（HTTP，HyperText Transfer Protocol）</strong>是互联网上最为广泛应用的网络协议之一，所有的 WWW 文件都必须遵守这个协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</li><li><strong>文件传输协议（FTP，File Transfer Protocol）</strong>：用于 Internet 上的控制文件的<strong>双向传输</strong>。在 FTP 的使用当中，用户经常遇到两个概念：<strong>下载（Download） 和上传（Upload）</strong>。在进进行文件传输时，FTP 的客户和服务器之间要先建立<strong>两个并行的 TCP 连接：控制连接和数据连接</strong>。实际用于传输文件的是数据连接。 </li><li><strong>简单文件传输协议（TFTP，Trivial File Transfer Protocol）</strong>：是 <strong>TCP/IP 协议族</strong>中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。</li><li><strong>简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）</strong>：它是一组用于<strong>将邮件由源地址传送到目的地址</strong>的规则，由它来控制信件的中转方式。SMTP 协议属于 <strong>TCP/IP 协议族</strong>，它帮助每台计算机在发送或中转信件时找到下一个目的地。</li><li><strong>邮局协议 3（Post Office Protocol 3）</strong>：是 <strong>TCP/IP 协议族</strong>中的一员，协议主要用于支持使用客户端远程管理在服务器上的电子邮件。</li><li><strong>网络邮件访问协议（Internet Mail Access Protocol）</strong>：主要作用是邮件客户端从服务端获取邮件信息，下载邮件等。对于阅读、标记、移动和删除等操作，<strong>IMAP 协议使客户端与邮箱更新同步，POP3 协议仅在客户端内</strong>。</li><li><strong>电子邮件系统</strong>：一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li></ul></li></ul><hr><h3 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h3><p><strong>运输层（transport layer）</strong>的任务是向<strong>两台主机进程之间的通信</strong>提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p><p><strong>运输层主要使用两种协议</strong>：</p><ul><li><strong>传输控制协议 TCP</strong>：提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>：提供<strong>无连接</strong>的，<strong>不保证可靠</strong>的数据传输服务。</li></ul><hr><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h3><p>计算机网络中进行通信的两个计算机之间可能会经过很多个<strong>数据链路</strong>，也可能还要经过很多<strong>通信子网</strong>。<strong>网络层</strong>的任务是，当<strong>两个计算机间进行通信</strong>时，<strong>选择合适的网间路由和交换结点</strong>，确保数据及时传送。</p><ul><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</li><li>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。 </li><li><strong>子网掩码</strong>：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。</li></ul><hr><h3 id="5-数据链路层"><a href="#5-数据链路层" class="headerlink" title="5. 数据链路层"></a>5. 数据链路层</h3><p><strong>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong></p><ul><li><p>在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p></li><li><p>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）。</p></li><li><p>数据链路层传输协议的数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong>。</p></li><li><p><strong>MAC 地址</strong>：意译为媒体访问控制，或称为<strong>物理地址、硬件地址，用来定义网络设备的位置</strong>。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此<strong>一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址</strong>。</p></li></ul><hr><h3 id="6-物理层"><a href="#6-物理层" class="headerlink" title="6. 物理层"></a>6. 物理层</h3><ul><li><strong>在物理层上所传送的数据单位是比特</strong>。</li><li><strong>物理层（physical layer）</strong>的作用是实现<strong>相邻计算机节点之间比特流的透明传送</strong>，尽可能屏蔽掉具体传输介质和物理设备的差异。</li><li>“透明传送比特流” 表示<strong>经实际电路传送后的比特流没有发生变化</strong>，对传送的比特流来说，这个电路好像是看不见的。</li></ul><hr><h3 id="7-子网，子网掩码，子网地址，广播地址"><a href="#7-子网，子网掩码，子网地址，广播地址" class="headerlink" title="7. 子网，子网掩码，子网地址，广播地址"></a>7. 子网，子网掩码，子网地址，广播地址</h3><p><img src="%E7%BD%91%E7%BB%9C.assets/20160712182446560" alt=""></p><h2 id="2-TCP-和-UDP"><a href="#2-TCP-和-UDP" class="headerlink" title="2. TCP 和 UDP"></a>2. TCP 和 UDP</h2><h3 id="1-TCP-三次握手"><a href="#1-TCP-三次握手" class="headerlink" title="1. TCP 三次握手"></a>1. TCP 三次握手</h3><p><img src="%E7%BD%91%E7%BB%9C.assets/640.png" alt=""></p><ol><li><strong>客户端</strong>发送带有 <strong>SYN 标志</strong>的数据包给服务端——一次握手；</li><li><strong>服务端</strong>发送带有 <strong>SYN/ACK 标志</strong>的数据包给客户端——二次握手；</li><li><strong>客户端</strong>发送带有 <strong>ACK 标志</strong>的数据包给服务端——三次握手；</li></ol><ul><li><strong>客户端先发送</strong>。</li></ul><hr><h3 id="2-为什么要三次握手"><a href="#2-为什么要三次握手" class="headerlink" title="2. 为什么要三次握手"></a>2. 为什么要三次握手</h3><blockquote><p><strong>三次握手的目的是建立可靠的通信信道</strong>。</p></blockquote><p>说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的。</strong> </p><ol><li>第一次握手：服务端确认<strong>客户端发送正常，自己接收正常</strong>；</li><li>第二次握手：<strong>客户端</strong>确认<strong>自己发送、接收正常，服务端发送、接收正常</strong>（客户端确认完成）；</li><li>第三次握手：<strong>服务端</strong>确认<strong>自己发送、接收正常，客户端发送、接收正常</strong>（服务端确认完成）。</li></ol><ul><li>因此三次握手就能使双方确认，自己和对方都收发正常。</li></ul><blockquote><p>是确认双方的<strong>初始序列号</strong>。</p></blockquote><p>序列号是保证 TCP 可靠的基础。</p><ul><li>建立连接时，序列号生成器会生成初始序列号，是一个和时钟相关的 32 位数据。</li><li>如果客户端请求迟迟收不到服务器端回应，会再次发送请求，这两次请求的序列号也是不同的。</li><li>因此如果只有两次握手，客户端不给服务器端发送确认，那么服务器端会开启两份资源，造成资源的浪费。而如果客户端给服务器端发送确认，则服务器端可以知道是哪个请求建立了连接，那么多余的资源可以释放。</li></ul><p>如果初始序列号从 0 开始写死，而发送过程中客户端宕机，此时已经发送了 10 个包，重新连接后序列号又从 0 开始，而服务器端的 ACK 是第 20 个包的，就会出现问题。</p><hr><h3 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4. 四次挥手"></a>4. 四次挥手</h3><ol><li><strong>客户端</strong>发送一个带有 <strong>FIN 标志</strong>的报文给服务端，进入 WAIT-1 状态，表示释放连接——一次挥手；</li><li><strong>服务端</strong>发送一个带有 <strong>ACK 标志</strong>的报文给客户端，表示确认收到，进入 CLOSE_WAIT 状态；客户端收到确认报文，进入 WAIT-2 状态——二次挥手；</li><li><strong>服务端</strong>发送完所有数据后，发送一个带有 <strong>FIN 标志</strong>的报文给客户端，进入 LAST-ACK 状态，表示释放连接——三次挥手；</li><li><strong>客户端</strong>发送一个带有 <strong>ACK 标志</strong>的报文给服务端，表示确认，进入 TIME_WAIT 状态——四次挥手。</li></ol><ul><li>注意：<strong>当客户端发送最后的确认后，并不会立刻释放连接，必须经过 2*MSL（最长报文段寿命）的时间后，客户端才会关闭 TCB（传输控制块）。而服务端接收到确认后，立即进入 CLOSED 状态。因此，服务端结束的时间要比客户端早一些</strong>。</li></ul><hr><h3 id="5-为什么客户端断开前需要等待-2MSL"><a href="#5-为什么客户端断开前需要等待-2MSL" class="headerlink" title="5. 为什么客户端断开前需要等待 2MSL"></a>5. 为什么客户端断开前需要等待 2MSL</h3><ol><li>客户端发送最后的确认报文后，这个报文可能丢失；</li><li>服务端迟迟接收不到确认报文，会重新发送请求断开连接 FIN 报文；</li><li>客户端在这 2MSL 时间内就会收到新的报文，再次发送确认报文，并重启 2MSL 计时器。</li></ol><hr><h3 id="6-为什么挥手比握手多了一次"><a href="#6-为什么挥手比握手多了一次" class="headerlink" title="6. 为什么挥手比握手多了一次"></a>6. 为什么挥手比握手多了一次</h3><ol><li>建立连接时，服务器接收到 SYN 报文后，<strong>将 SYN 和 ACK 放在一个报文中</strong>发送给客户端。</li><li>关闭连接时，服务器接收到 FIN 报文后，<strong>可能还有未发送完的数据，于是先发送 ACK 表示确认，待数据都发送完后，再发送 FIN 报文请求关闭连接</strong>。由于 <strong>ACK 和 FIN 报文分开发送</strong>，从而导致挥手比握手多了一次。</li></ol><hr><h3 id="7-TCP-和-UDP-的区别"><a href="#7-TCP-和-UDP-的区别" class="headerlink" title="7. TCP 和 UDP 的区别"></a>7. TCP 和 UDP 的区别</h3><ul><li><strong>UDP 在传输数据前不需要先建立连接</strong>，接收端主机收到 UDP 报文后，<strong>不需要给出任何确认</strong>。一般用于语音、视频和直播等即时通信。</li><li><strong>TCP 是面向连接的服务</strong>。TCP 在传输数据前必须先有<strong>三次握手</strong>建立连接，数据传送后要有<strong>四次挥手</strong>关闭连接，并且在数据传递时，有确认、窗口。重传和拥塞控制机制。也由于这些保证， TCP 的开销比 UDP 大，一般用于文件传输、发送和接收邮件、远程登录等场景。</li><li>TCP 是字节流传输的，UDP 是报文传输。</li><li>TCP 保证顺序，UDP 不保证。</li></ul><hr><h3 id="8-TCP-如何保证可靠传输"><a href="#8-TCP-如何保证可靠传输" class="headerlink" title="8. TCP 如何保证可靠传输"></a>8. TCP 如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为合适的<strong>数据块（分组）进行发送</strong>；</li><li>TCP 给发送的<strong>每一个包编号</strong>，接收方对数据包进行排序，把有序数据传到应用层；</li><li><strong>校验和</strong>：TCP 保持它首部和数据的检验和。这是一个端到端的检验和，目的是<strong>检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段；</li><li>TCP 的接收端会<strong>丢弃重复的数据</strong>；</li><li><strong>流量控制（滑动窗口）</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议，<strong>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小</strong>，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据；</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送；</li><li><strong>ARQ 协议（确认收到）</strong>：每发完一个分组就<strong>停止发送</strong>，等待对方确认，收到确认后再发送下一个分组。也有<strong>连续 ARQ 协议，特点是 Go-Back-N</strong>。<ol><li>如发送了 1 2 3 4 5 个包，发送方会等待确认，如果接收方的确认是 ACK 6，说明 5 个包都收到了，接下来从第 6 个包开始发。</li><li>但如果过程中只有 4 包没有收到，那么接收方的确认是 ACK 4，说明 4 没有收到。这时发送方会从 4 开始从新发送，也就是说 5 包也会被重新发送。</li><li>在这个过程中发送方有个<strong>超时重传机制</strong>。这里可能是 4 包丢了，也可能是速度慢还没有到，如果接到 ACK 确认就重传，可能这时 4 包已经到了，服务器端新的 ACK 也在路上了，这就会造成资源的浪费。</li></ol></li><li><strong>超时重传</strong>：当 TCP 发出一个分组后，它启动一个定时器，等待接收端确认收到。<strong>如果不能及时收到一个确认，将重发这个分组</strong>。</li><li><strong>SACK 重传</strong>：为了解决重传哪些数据的问题。上述描述中，Go-Back-N 机制可能会导致发送的重复，这是一种资源的浪费。SACK 就是接受端回传已经接受到数据，如上一条 ACK 5001，说明接受从 5001 开始的数据。接收时一直更新 SACK，如 5501-6000，6001-6500，发送方就可以明确知道是 5001-5500 这一段丢了，于是重传这一段的数据即可。</li></ol><hr><h3 id="9-拥塞控制"><a href="#9-拥塞控制" class="headerlink" title="9. 拥塞控制"></a>9. 拥塞控制</h3><p>拥塞控制中的算法 Reno 十分著名，以此作为说明对象。</p><p>拥塞控制中用到了一个拥塞窗口，这和滑动窗口是有区别的。<strong>滑动窗口是接收端确定的</strong>，可以接收的数据数量。<strong>拥塞窗口是发送端维护的</strong>，根据网络的拥塞程度动态调节。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 </p><ol><li><strong>慢启动</strong>：刚开始发送时不发送大量的数据，先探测一下网络的拥塞程度，由小到大扩大拥塞窗口。如果没有出现丢包，每收到一个 ACK 窗口大小加一，整个轮次下来，窗口会扩大一倍，这时窗口大小是呈指数增长的。</li><li><strong>拥塞避免</strong>：如果发生丢包，则进入拥塞避免阶段，窗口每轮次加一，呈线性增长。</li><li><strong>快重传</strong>：如果发送端连续收到三个重复的 ACK，认为产生丢失，并且此时网络通畅，不会进行超时重传，而是立刻重传，这样可以提高效率。</li><li><strong>快恢复</strong>：快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口的一半，同时拥塞窗口值等于阈值，进入拥塞避免阶段。</li></ol><p><img src="https://pic1.zhimg.com/80/v2-86c12ed3ddb2391c057f7d3598372880_720w.jpg" alt=""></p><hr><h2 id="3-HTTP-协议"><a href="#3-HTTP-协议" class="headerlink" title="3. HTTP 协议"></a>3. HTTP 协议</h2><h3 id="1-HTTP-简介"><a href="#1-HTTP-简介" class="headerlink" title="1. HTTP 简介"></a>1. HTTP 简介</h3><ul><li>工作原理：HTTP 协议工作在客户端 / 服务器架构上（C / S）。<strong>浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即WEB服务器发送所有请求</strong>。</li><li><strong>HTTP 默认端口号为 80</strong>，可以修改。</li><li><strong>注意事项</strong>：<ol><li>HTTP 是<strong>无连接</strong>的（短连接）：<strong>每次连接只处理一个请求</strong>。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 </li><li>HTTP 是<strong>无状态</strong>的：无状态指协议<strong>对事物处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。这个可以引出 cookie。</li><li>HTTP 是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。 </li></ol></li></ul><hr><h3 id="2-HTTP-消息结构"><a href="#2-HTTP-消息结构" class="headerlink" title="2. HTTP 消息结构"></a>2. HTTP 消息结构</h3><ul><li>客户端：客户端发送一个 HTTP 请求到服务器，请求消息包括以下格式：<strong>请求行（request line）、请求头部（header）</strong>、空行和请求数据。<ul><li><strong>请求行</strong>中包括：<strong>请求方法</strong>（最常用的方法为 GET 和 POST）、<strong>URL</strong> 和<strong>协议版本</strong>，用空格隔开。</li><li><strong>请求头部</strong>内格式为：<strong>头部字段名 ：值</strong>（可以有多个）。</li></ul></li></ul><p><img src="%E7%BD%91%E7%BB%9C.assets/640.webp" alt=""></p><ul><li>服务器端：服务器端响应消息包括以下格式：<strong>状态行</strong>、消息报头、空行和响应正文。<ul><li><strong>状态行</strong>中包括：协议版本和<strong>状态码</strong>。常用状态码有：<strong>200（OK）</strong>、301（资源被永久转移到其他 URL）、<strong>404（请求的资源不存在）</strong>和 500（内部服务器错误）等。</li></ul></li></ul><p><img src="%E7%BD%91%E7%BB%9C.assets/640-1601175112868.webp" alt=""></p><ul><li><strong>200：请求被正常处理</strong></li><li><strong>204：请求被受理但没有资源可以返回</strong></li><li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li><li><strong>301：永久性重定向</strong></li><li><strong>302：临时重定向</strong></li><li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li><li><strong>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</strong></li><li>307：临时重定向，与302类似，只是强制要求使用POST方法</li><li><strong>400：请求报文语法有误，服务器无法识别</strong></li><li>401：请求需要认证</li><li><strong>403：请求的对应资源禁止被访问</strong></li><li><strong>404：服务器无法找到对应资源</strong></li><li><strong>500：服务器内部错误</strong></li><li><strong>503：服务器正忙</strong></li></ul><hr><h3 id="3-HTTP-方法"><a href="#3-HTTP-方法" class="headerlink" title="3. HTTP 方法"></a>3. HTTP 方法</h3><ol><li><strong>GET：请求指定的页面信息，并返回实体主体。</strong>GET 方法的请求参数会拼在 URL 后，容易被窃取，且 URL 的长度有限制。</li><li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</li><li><strong>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新资源的建立和/或已有资源的修改。</strong>POST 请求会把参数和值放在消息体中，对外界不可见，且长度不受限制。</li><li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE：请求服务器删除指定的页面。</li><li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS：允许客户端查看服务器的性能。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新。</li></ol><ul><li><strong>其中最常用的方法为 GET 和 POST。</strong></li></ul><hr><h3 id="4-HTTP-长连接和短连接"><a href="#4-HTTP-长连接和短连接" class="headerlink" title="4. HTTP 长连接和短连接"></a>4. HTTP 长连接和短连接</h3><ul><li><strong>HTTP/1.0 中默认使用短连接</strong>。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。 </li><li><strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。在使用长连接的情况下，<strong>当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接</strong>。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li><li><strong>优缺点</strong>：请求频繁时，长连接省去较多 TCP 建立和关闭连接的操作，减少浪费，节约时间。请求不频繁时，短连接便于管理，不像长连接需要保活等，存在的连接都是有用的连接。</li><li><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</strong>。</li></ul><hr><h3 id="5-URI-和-URL-的区别"><a href="#5-URI-和-URL-的区别" class="headerlink" title="5. URI 和 URL 的区别"></a>5. URI 和 URL 的区别</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，<strong>可以唯一标识一个资源</strong>。</li><li>URL(Uniform Resource Location) 是统一资源定位符，<strong>可以提供该资源的路径</strong>。它是一种具体的 URI，即 <strong>URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源</strong>。 </li></ul><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><hr><h3 id="6-HTTPS"><a href="#6-HTTPS" class="headerlink" title="6. HTTPS"></a>6. HTTPS</h3><blockquote><p><strong>概念解释</strong></p></blockquote><ul><li>密码：密码学中的密码指的是一种<strong>加密/解密的算法</strong>。</li><li>密钥（key）：<strong>密钥是一种参数</strong>，是在使用密码算法时输入的参数。<strong>同一个明文在相同密码算法和不同密钥下会生成不同的密文</strong>。</li><li>对称密钥：明文在加密和解密过程中使用的密钥是相同的，常见的算法有 AES、DES 等。</li><li>非对称密钥：明文在加密和解密过程中使用的密钥是不同的，常见的算法有 <strong>RSA</strong> 等。</li><li>数字签名：服务端把报文经过哈希处理生成摘要，再用私钥对摘要进行加密，就生成了数字签名，常见的算法有 MD5 等。</li><li>CA（Certificate Authority）：引进的目的是为了保证公钥的真实性。服务端把公钥发送给 CA，CA 会颁发一个数字证书，包含服务端的公钥，并用自己的私钥生成数字签名。之后服务端会将证书发送给客户端，客户端有 CA 的公钥，解签名确认公钥的真实性。</li></ul><blockquote><p><strong>握手流程</strong></p></blockquote><ul><li><strong>加密握手流程在三次握手之后</strong>。</li></ul><p><img src="%E7%BD%91%E7%BB%9C.assets/640-1601178364186.webp" alt=""></p><ol><li>用户在浏览器发起HTTPS请求（client hello），默认使用服务端的 443 端口进行连接；</li><li>HTTPS需要使用一套 <strong>CA 数字证书</strong>，证书内会附带一个<strong>公钥 Pub</strong>，而与之对应的<strong>私钥 Private</strong> 保留在服务端不公开；</li><li>服务端收到请求，返回配置好的包含<strong>公钥 Pub</strong> 的证书给客户端；</li><li>客户端收到<strong>证书</strong>，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续；</li><li>客户端生成一个用于对称加密的<strong>随机 Key</strong>，并用证书内的<strong>公钥 Pub</strong> 进行加密，发送给服务端；</li><li>服务端收到<strong>随机 Key</strong> 的密文，使用与<strong>公钥 Pub</strong> 配对的<strong>私钥 Private</strong> 进行解密，得到客户端真正想发送的<strong>随机 Key</strong>；</li><li>服务端使用客户端发送过来的<strong>随机 Key</strong> 对要传输的HTTP数据进行对称加密，将密文返回客户端；</li><li>客户端使用<strong>随机 Key</strong> 对称解密密文，得到 HTTP 数据明文；</li><li>后续HTTPS请求使用之前交换好的<strong>随机Key</strong>进行对称加解密。</li></ol><hr><h3 id="7-HTTP-和-HTTPS-的区别"><a href="#7-HTTP-和-HTTPS-的区别" class="headerlink" title="7. HTTP 和 HTTPS 的区别"></a>7. HTTP 和 HTTPS 的区别</h3><ol><li><strong>端口</strong>：HTTP 的 URL 由 “http://” 起始且默认使用端口 80，而 HTTPS 的 URL 由 “https://” 起始且默认使用端口 443。 </li><li><strong>安全性和资源消耗：</strong> <strong>HTTP 协议</strong>运行在 TCP 之上，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份。<strong>HTTPS 协议</strong>是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP之上。所有传输的内容都经过<strong>加密</strong>。所以，<strong>HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源</strong>。</li></ol><hr><h3 id="8-get-和-post-的区别"><a href="#8-get-和-post-的区别" class="headerlink" title="8. get 和 post 的区别"></a>8. get 和 post 的区别</h3><ol><li><strong>Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据</strong>。</li><li>Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用 “?” 连接，而各个变量之间使用 “&amp;” 连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。</li><li>Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求 URL 记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。</li><li>Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。</li><li>Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。</li><li>Get 是 Form 的默认方法。使用 Post 传输的数据，<strong>可以通过设置编码的方式正确转化中文</strong>；而 Get 传输的数据却没有变化。</li></ol><hr><h3 id="9-从输入-URL-到显示页面的过程"><a href="#9-从输入-URL-到显示页面的过程" class="headerlink" title="9. 从输入 URL 到显示页面的过程"></a>9. 从输入 URL 到显示页面的过程</h3><ol><li>DNS解析：通过 URL 找到服务器 IP 地址；</li><li>建立 TCP 连接；</li><li>发送 HTTP 请求；</li><li>服务器处理请求并返回 HTTP 报文；</li><li>浏览器解析并渲染页面；</li><li>关闭连接。</li></ol><hr><h3 id="10-DNS-解析过程"><a href="#10-DNS-解析过程" class="headerlink" title="10. DNS 解析过程"></a>10. DNS 解析过程</h3><ul><li>因特网在命名时采用的是<strong>层次树状结构</strong>的命名方法，任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名(domain name)。 如图所示：</li></ul><p><img src="%E7%BD%91%E7%BB%9C.assets/5679451-6d9d8a9de1453f9a.webp" alt=""></p><ol><li>在浏览器中输入<a href="http://www.baidu.com域名，操作系统会先检查自己**本地的hosts文件**是否有这个网址映射关系，如果有，就先调用这个ip地址映射，完成域名解析。" target="_blank" rel="noopener">www.baidu.com域名，操作系统会先检查自己**本地的hosts文件**是否有这个网址映射关系，如果有，就先调用这个ip地址映射，完成域名解析。</a></li><li>如果hosts里没有这个域名的映射，则会查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它<strong>本地DNS服务器</strong>，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析记过给客户端，完成域名解析，此解析具有权威性。</li><li>如果要查询域名，不由本地DNS服务器区域解析，但该服务器已<strong>缓存</strong>了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，<strong>本地DNS就把请求发至13台根DNS</strong>，根DNS服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址（baidu.com）给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.baidu.com主机。" target="_blank" rel="noopener">www.baidu.com主机。</a></li></ol><blockquote><p><strong>递归查询和迭代查询</strong></p></blockquote><ul><li>递归查询是 A 向 B 查询，B 再向 C 查询，最终返回的是 IP 地址。</li><li>迭代查询是 A 向 B 查询，B 返回一个地址 C，A 再向 C 查询，依次类推，直到找到 IP 地址。</li></ul><hr><h2 id="4-Session-和-Cookie"><a href="#4-Session-和-Cookie" class="headerlink" title="4. Session 和 Cookie"></a>4. Session 和 Cookie</h2><h3 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h3><ul><li>Cookie 实际是一段文本数据，用于记录用户状态，保存在客户端：<ul><li>客户端请求服务器，如果服务器需要记录该用户的状态，就会使用 response 客户端发送一个 Cookie（相当于身份证号码），客户端会把 Cookie 保存起来；</li><li>当客户端再次请求服务器时，会把请求和 Cookie 一同提交给服务器，服务器检查 Cookie 以确认用户状态。服务器还可以根据需要修改 Cookie 的内容。</li></ul></li><li><strong>Cookie 的有效期</strong>：Cookie 的 maxAge 决定 Cookie 的有效期。<strong>maxAge 为正数时</strong>，浏览器会将maxAge为正数的 Cookie 持久化，即<strong>写到对应的 Cookie 文件中</strong>。无论客户关闭了浏览器还是电脑，只要还在 maxAge 秒之前，登录网站时该 Cookie 仍然有效。<strong>maxAge 为负数时</strong>，表示该 Cookie 仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。这种 Cookie <strong>不会被写入文件中， Cookie 信息保存在浏览器内存中</strong>，因此关闭浏览器该 Cookie 就消失了。<strong>Cookie 默认的 maxAge 值为 –1</strong>，也就是说 Cookie 默认是会话 Cookie。<strong>maxAge 为0时</strong>，表示<strong>删除</strong>该 Cookie。</li><li><strong>Cookie 的修改和删除</strong>：response 对象提供的 Cookie 操作方法只有一个添加操作 <code>add(Cookie cookie)</code>。要想修改 Cookie 只能使<strong>用一个同名的 Cookie 来覆盖原来的 Cookie</strong>，达到修改的目的。删除时用一个 maxAge 为 0 的同名 Cookie 覆盖原来的 Cookie。</li></ul><hr><h3 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h3><ul><li>Session 另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而 <strong>Session 保存在服务器上</strong>。<ul><li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。</li><li>客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态。 </li></ul></li><li>每个来访者对应一个 Session 对象，<strong>所有该客户的状态信息都保存在这个 Session 对象里。Session 对象是在客户端第一次请求服务器的时候自动创建的</strong>。Session 也是一种 key-value 的属性对。</li><li><strong>Session 有效期</strong>：Session 保存在服务器端。<strong>为了获得更高的存取速度，服务器一般把Session放在内存里</strong>。每个用户都会有一个独立的 Session。<strong>为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是 Session 的超时时间</strong>。如果超过了超时时间没访问过服务器，Session就自动失效了。</li><li>Session 中提供了很多方法，使用起来比 Cookie 方便。</li></ul><hr><h3 id="3-Session-和-Cookie-的联系"><a href="#3-Session-和-Cookie-的联系" class="headerlink" title="3. Session 和 Cookie 的联系"></a>3. Session 和 Cookie 的联系</h3><ul><li><strong>Session需要使用Cookie作为识别标志</strong>：HTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个<strong>名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id</strong>（也就是 <code>HttpSession.getId()</code> 的返回值）。Session依据该Cookie来识别是否为同一用户。</li><li><strong>URL 地址重写</strong>：当某些客户端不支持 Cookie，而想要使用 Session 来记录用户状态时，就需要使用 URL 地址重写。URL 地址重写的原理是，<strong>将该用户 Session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 Session 的 id</strong>。这样即使客户端不支持 Cookie，也可以使用 Session 来记录用户状态。 </li></ul><hr><h3 id="4-Session-和-Cookie-的区别"><a href="#4-Session-和-Cookie-的区别" class="headerlink" title="4. Session 和 Cookie 的区别"></a>4. Session 和 Cookie 的区别</h3><ol><li>Cookie 数据保存在客户端（浏览器端），Session 数据保存在服务器端。</li><li>Cookie 不是很安全，<strong>考虑到安全性应当使用 Session</strong>。但 Cookie 可以加密，使用时再到服务器端解密。</li><li>Session 会在一定时间内保存在服务器上。当访问增多时，会比较占用服务器的性能，<strong>考虑到减轻服务器性能方面，应当使用 Cookie</strong>。</li><li>单个 Cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 Cookie。<strong>Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型</strong>。</li></ol><hr><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ul><li><strong>登录网站</strong>，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是 Cookie。</li><li>Session 一个应用场景是<strong>购物车</strong>，添加了商品之后，服务器端储存这些添加的商品就用到了 Session。下一次同一个用户登录时，就可以从 Session 读取到之前添加的商品。<strong>Cookie只是一个身份信息</strong>，且容量有限，无法储存购物车这种较多的数据。</li></ul><hr><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p>socket servlet 等</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2020/08/05/hashmap-yuan-ma-jie-xi/"/>
      <url>/2020/08/05/hashmap-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h1><h2 id="1-JDK-1-8-前后的区别"><a href="#1-JDK-1-8-前后的区别" class="headerlink" title="1. JDK 1.8 前后的区别"></a>1. JDK 1.8 前后的区别</h2><h3 id="1-HashMap-简介"><a href="#1-HashMap-简介" class="headerlink" title="1. HashMap 简介"></a>1. HashMap 简介</h3><p>HashMap 继承了 AbstractMap ，实现了 Map、cloneable 和java.io.serializable 接口。</p><ul><li>继承了 AbstractMap ，实现了 Map，表明它是一个 Map ，作用是用来存放<strong>键值对</strong>。</li><li>实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</li><li>实现了 <strong>java.io.serializable</strong> 接口，这表示 ArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</li><li><strong>HashMap 是线程不安全的</strong>。线程安全的 Map 容器为 <strong>ConcurrentHashMap</strong>，也可以通过  <code>Collections.synchronizedMap()</code> 方法来包装 HashMap。</li></ul><hr><h3 id="2-JDK-1-8-前后-hash-方法的区别（哈希冲突）"><a href="#2-JDK-1-8-前后-hash-方法的区别（哈希冲突）" class="headerlink" title="2. JDK 1.8 前后 hash 方法的区别（哈希冲突）"></a>2. JDK 1.8 前后 hash 方法的区别（哈希冲突）</h3><ul><li>JDK 1.8 之前，HashMap 底层是<strong>数组和链表</strong>结合的结构。HashMap 通过 <code>hash()</code> 方法处理后得到 <strong>hash 值</strong>，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里 n 是数组的长度）。</li><li>如果当前位置存在元素，则<strong>判断两个元素的 hash 值和 key 是否相同</strong>。如果相同，直接覆盖已有元素；如果不相同，则加入链表（拉链法）。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>这里 <code>hash()</code> 方法接收的参数 h，是 key 通过 <code>hashCode()</code> 方法得到的 hashcode</strong>。</p><ul><li>JDK 1.8 之后，HashMap 底层是<strong>数组和链表/红黑树</strong>结合的结构，当链表的长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>    <span class="token comment" spellcheck="true">// ^ ：按位异或</span>    <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里 <code>hash()</code> 方法接收的参数就是 key，计算 hashcode 在方法内部，计算方法也更加简化，但原理不变。</p><ul><li>其实 JDK 1.8 前后解决<strong>哈希冲突</strong>的方法类似，都是<strong>数组 + 链表</strong>的形式，只是 JDK 1.8 后增加了链表变红黑树的操作。</li></ul><hr><h3 id="3-JDK-1-8-之后-HashMap-类的属性"><a href="#3-JDK-1-8-之后-HashMap-类的属性" class="headerlink" title="3. JDK 1.8 之后 HashMap 类的属性"></a>3. JDK 1.8 之后 HashMap 类的属性</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量2^30</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>loadFactor</strong>（负载因子）：loadFactor加载因子是控制数组存放数据的疏密程度。<strong>影响着数组的利用率和查找元素的效率</strong>。</li><li><strong>threshold</strong>（扩充阈值）：<code>threshold = capacity * loadFactor</code> 。<strong>当 size 达到 threshold 时，哈希表就会进行扩容</strong>。</li><li>HashMap 的默认容量是 16，默认负载因子是 0.75，因此 threshold 默认是 12。也就是说，当 size 达到 12 时，HashMap 就会扩容。可以看出，<strong>HashMap 中的实际元素数量总会小于数组的长度，这是为了使元素分布稀疏，减少哈希冲突，使查找效率高</strong>。0.75f 是官方给出的比较折中的临界值。</li></ul><hr><h3 id="4-Node-节点类"><a href="#4-Node-节点类" class="headerlink" title="4. Node 节点类"></a>4. Node 节点类</h3><ul><li>Node 节点类继承自 Map.Entry&lt;K, V&gt;，key 和 value 共同存储在一个 Node 节点类中。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li>key 由 final 修饰，不可改变，value 没有 final 修饰，可以修改。</li><li>Node 中是有 next 节点的，因为有链表结构。</li><li><strong>重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</strong>。解决哈希冲突时必要的方法。定义为 key 的 hashcode 与 value 的 hashcode 的异或，<code>Objects.hashCode(key) ^ Objects.hashCode(value);</code>。</li></ul><hr><h2 id="2-HashMap-源码"><a href="#2-HashMap-源码" class="headerlink" title="2. HashMap 源码"></a>2. HashMap 源码</h2><h3 id="1-构造方法源码"><a href="#1-构造方法源码" class="headerlink" title="1. 构造方法源码"></a>1. 构造方法源码</h3><ul><li>HashMap 共有四个构造方法：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 默认构造方法，所有参数使用默认值</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 只指定“容量大小”的构造函数，其中又调用了两个参数的构造函数。</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 指定“容量大小”和“负载因子”的构造函数，容量若不是2的倍数，会在之后优化成2的倍数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//如果指定容量小于0，抛出异常</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果指定容量大于最大容量，则使用最大容量</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果指定负载因子不满足条件，抛出异常。注意：这里等于0也不可以。</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//这里的tableSizeFor()方法，是把不为2的整数幂的初始长度，优化为2的整数幂</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span></code></pre><hr><h3 id="2-put-方法源码"><a href="#2-put-方法源码" class="headerlink" title="2. put 方法源码"></a>2. put 方法源码</h3><p>HashMap 中添加元素的核心方法是 <code>putVal()</code> 方法，但不提供给用户使用，由 <code>put()</code> 方法调用，再开放 <code>put()</code> 方法给用户使用。</p><ul><li><strong><code>putVal()</code> 方法的添加流程</strong>：<ol><li>使用 <code>(n - 1) &amp; hash</code> 定位，其中 n 为数组长度。如果定位到的数组位置没有元素，直接加入；</li><li>如果定位到的数组位置已有元素，则<strong>比较 hash 值和 key</strong>，如果相同就覆盖，如果不同则要继续判断；</li><li>hash 值或 key 不同时，判断当前位置是否是一个树节点，如果是则调用添加树节点的方法，把元素加入红黑树。如果不是则遍历链表，加入链表尾部。<strong>在遍历链表的同时，也会比较每一个点的 hash 值和 key，如果有相等，就用新值覆盖</strong>。</li></ol></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；判断是否为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 以上都不是，则为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点，用新值覆盖</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><hr><h3 id="3-get-方法源码"><a href="#3-get-方法源码" class="headerlink" title="3. get 方法源码"></a>3. get 方法源码</h3><p>HashMap 中获取元素的核心方法是 <code>getNode()</code> 方法，但不提供给用户使用，由 <code>get()</code> 方法调用，再开放<code>get()</code> 方法给用户使用。</p><ul><li><strong><code>getNode()</code> 方法的获取流程</strong>：<ol><li>使用 <code>(n - 1) &amp; hash</code> 定位，其中 n 为数组长度。如果定位到的数组位置没有元素，直接返回 null；</li><li>如果当前位置有元素，判断当前位置元素和要找的元素是否相同，比较 hash 值和 key。如果相等则直接放回当前元素。</li><li>如果不相等则判断后续是否有节点，没有节点返回 null，有节点则判断是否是树。</li><li>如果是树，在树中 get 元素，如果不是树，那一定是链表，遍历链表比较 hash 值和 key，有则返回元素，无则返回 null。</li></ol></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="4-resize-方法源码"><a href="#4-resize-方法源码" class="headerlink" title="4. resize 方法源码"></a>4. resize 方法源码</h3><ul><li><strong>HashMap 每次扩容后，都会伴随着一次重新 hash 分配</strong>，这会遍历 HashMap 中的所有元素，是非常耗时的。因此，在使用 HashMap 时，要尽量避免 resize，也就是<strong>初始长度尽量设置为合适的长度</strong>。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>简单来说就是，<strong>HashMap 每次扩容，都是把数组长度扩大为原数组长度的两倍</strong>，<code>newCap = oldCap &lt;&lt; 1</code> 。</p></li><li><p>数组扩容之后，数据需要复制到新数组中，根据当前位置有无链表，可以分为不同情况。</p><ul><li><strong>若当前位置只有一个节点，后续没有链表结构，直接进行 rehash</strong>，<code>newTab[e.hash &amp; (newCap - 1)] = e;</code> </li><li><strong>若当前位置后有链表结构，则创建出两条链表</strong>，根据增加的高位是否为 1，<code>if ((e.hash &amp; oldCap) == 0)</code>，使用尾插法分别插入两条链表。高位为 1 的链表，在新数组中的位置就是<strong>原位置加原数组长度</strong>；高位为 0 的链表，在新数组中的位置就是<strong>原位置</strong>。</li><li>若当前位置后是树节点，调用了树的方法 <code>((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</code>。</li></ul></li></ul><hr><h2 id="3-HashMap-面试问题总结"><a href="#3-HashMap-面试问题总结" class="headerlink" title="3. HashMap 面试问题总结"></a>3. HashMap 面试问题总结</h2><h3 id="1-HashMap-的容量为什么一定是-2-的整数幂"><a href="#1-HashMap-的容量为什么一定是-2-的整数幂" class="headerlink" title="1. HashMap 的容量为什么一定是 2 的整数幂"></a>1. HashMap 的容量为什么一定是 2 的整数幂</h3><ol><li>当元素要添加进 HashMap 时，会先通过 <code>hash()</code> 方法计算出元素的 hash 值，再通过 hash 值计算元素应该放在数组中的位置。</li><li>但 hash 值的范围很大，很多情况下 hash 值是大于数组的长度的，因此使用 % 取余操作得到余数，作为元素存放在数组中的位置。</li><li>而<strong>取余（%）操作中，如果除数是 2 的整数幂，等价于与其除数减一的与（&amp;）操作</strong>，即 <code>hash % length == hash &amp; (length-1)</code> 。采用二进制操作相比取余操作效率更高。</li><li>因此 <code>put()</code> 方法中的计算方法是 <code>(n - 1) &amp; hash</code> ，是取余操作的二进制写法。</li></ol><hr><h3 id="2-HashMap-的容量为什么一定是-2-的整数幂（本末倒置版）"><a href="#2-HashMap-的容量为什么一定是-2-的整数幂（本末倒置版）" class="headerlink" title="2. HashMap 的容量为什么一定是 2 的整数幂（本末倒置版）"></a>2. HashMap 的容量为什么一定是 2 的整数幂（本末倒置版）</h3><ol><li>取 HashMap 的容量为 15 和 16，元素 hash 值为 8 和 9。</li><li>15 的二进制为 1111，16 的二进制为 10000。因此 <code>(n - 1)</code> 的二进制分别为 14—1110 和 15—1111。而 hash 值的二进制为 8—1000 和 9—1001。</li><li>当容量为 15 时，hash 值为 8 和 9，根据 <code>(n - 1) &amp; hash</code> 计算出的值相等；而容量为 16 时，计算出的值不等。</li><li>原因是 15 - 1 = 14 的<strong>二进制 1110 最后一位是 0</strong>，而 8 和 9 的二进制表示只差在最后一位，不管此位是 0 还是 1，和 1110 与（&amp;）之后都是 0。这就<strong>导致了最后位是 1 的位置不可能被放置元素</strong>，如第一位 0001、第三位 0011 和第七位 0111 等等，增加了哈希碰撞的概率，降低了查找效率。</li><li>而当容量为 2 的整数幂时，<strong><code>n-1</code> 的低位一定都是 1</strong>。如 16 - 1 = 15（1111）、8 - 1 = 7（0111）和 4 - 1 = 3（0011）等等。哈希碰撞的概率更低。</li></ol><ul><li><strong>这样分析看起来挺有道理，但是 HashMap 中使用 <code>(n - 1) &amp; hash</code> 计算位置是有前提的，就是容量为 2 的整数幂，否则应该使用取余运算 <code>hash % n</code>。而这种推论把前提和结果反过来分析，对于不是 2 的整数幂的数，<code>(n - 1) &amp; hash</code> 不等价于取余运算，也就没有意义了。</strong></li></ul><hr><h3 id="3-HashMap和HashTable的区别"><a href="#3-HashMap和HashTable的区别" class="headerlink" title="3. HashMap和HashTable的区别"></a>3. HashMap和HashTable的区别</h3><ol><li>线程安全：HashMap是非线程安全的；HashTable是线程安全的。如果需要线程安全建议使用ConcurrentHashMap。</li><li>效率：HashTable在线程安全上会花费时间，因此HashMap效率更高。</li><li><strong>对Null key 和Null value的支持</strong>：HashMap中，null可以作为键，键是唯一的，但可以有多个键对应的值是null；HashTable中，null既不可以作为键，也不可以作为值，否则抛出NullPointerException。</li><li>容量：<ol><li>创建时不指定容量值：HashMap默认初始化大小为16，每次扩充变为原来的2倍；HashTable默认初始化大小为11，每次扩充变为原来的2n + 1；</li><li>创建时指定容量值：HashMap会将其扩充为2的幂次方大小；HashTable直接使用给定的大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</li></ol></li><li>底层数据结构：HashMap在JDK1.8以后，当<strong>链表</strong>长度大于阈值（默认为8）而<strong>数组</strong>长度小于 64时，那么会选择先进行数组扩容，当<strong>数组</strong>长度大于64时，将链表转化为红黑树，以减少搜索时间；HashTable没有这样的机制。</li></ol><hr><h3 id="4-HashMap和HashSet的区别"><a href="#4-HashMap和HashSet的区别" class="headerlink" title="4. HashMap和HashSet的区别"></a>4. HashMap和HashSet的区别</h3><ul><li>HashSet底层是基于HashMap实现的，只有<code>clone()</code>，<code>writeObject()</code>，<code>readObject()</code>是HashSet自己实现的，其他方法都是调用HashMap中的方法。</li></ul><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现了Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向map中添加元素</td><td align="center">调用 <code>set()</code>方法向set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以要用<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2020/08/05/arraylist-yuan-ma-jie-xi/"/>
      <url>/2020/08/05/arraylist-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-源码解析"><a href="#ArrayList-源码解析" class="headerlink" title="ArrayList 源码解析"></a>ArrayList 源码解析</h1><h2 id="1-ArrayList-源码"><a href="#1-ArrayList-源码" class="headerlink" title="1. ArrayList 源码"></a>1. ArrayList 源码</h2><h3 id="1-ArrayList-简介"><a href="#1-ArrayList-简介" class="headerlink" title="1. ArrayList 简介"></a>1. ArrayList 简介</h3><p>ArrayList 继承了 AbstractList ，实现了 <strong>List、RandomAccess、Cloneable 和 java.io.serializable</strong> 接口。</p><ul><li>继承了 AbstractList ，实现了 List。表明它是一个数组，提供了相关的添加、删除、修改和遍历等功能。</li><li>实现了 <strong>RandomAccess 接口</strong>，实现这个接口表明集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，可以<strong>通过元素的序号快速获取元素</strong>，这就是快速随机访问。</li><li>实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</li><li>实现了 <strong>java.io.serializable</strong> 接口，这表示 ArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</li><li><strong>ArrayList 是线程不安全的</strong>。线程安全的数组容器有 <strong>Vector 和 CopyOnWriteArrayList</strong>。</li></ul><hr><h3 id="2-ArrayList-中构造部分源码"><a href="#2-ArrayList-中构造部分源码" class="headerlink" title="2. ArrayList 中构造部分源码"></a>2. ArrayList 中构造部分源码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 8683452581122892189L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 保存ArrayList数据的数组     */</span>    <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span>    <span class="token comment" spellcheck="true">/**     * ArrayList 所包含的元素个数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果传入的参数大于0，创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果传入的参数等于0，创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//其他情况，抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *默认无参构造函数     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>ArrayList 的<strong>内部数组是 Object 数组</strong>，基本类型也要用包装类型。</li><li>ArrayList 的<strong>初始容量设定为10</strong>；</li><li>ArrayList 的<strong>无参构造方法</strong>，会先创建一个空的数组，<strong>长度为 0</strong>，直到<strong>添加第一个元素时，数组长度扩充为 10</strong>。</li><li>ArrayList 的<strong>有参构造方法</strong>，指定数组长度。<strong>如果指定长度大于 0 ，创建长度为 10 的数组</strong>，如果指定长度等于 0 ，创建空数组，其他情况抛出异常。</li><li><strong>指定长度大于 10 时，数组初始长度仍然是 10</strong>，直到达到扩充条件，根据扩充机制进行扩充。</li></ul><hr><h3 id="3-ArrayList-中扩充部分源码"><a href="#3-ArrayList-中扩充部分源码" class="headerlink" title="3. ArrayList 中扩充部分源码"></a>3. ArrayList 中扩充部分源码</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>            <span class="token comment" spellcheck="true">// supposed to be at default size.</span>            <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果最小容量大于已有的最大容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 要分配的最大数组大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>        <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>        <span class="token comment" spellcheck="true">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>        <span class="token comment" spellcheck="true">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//比较minCapacity和 MAX_ARRAY_SIZE</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>            MAX_ARRAY_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>当数组需要扩容时，<strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></strong>，其中 oldCapacity 是原数组长度。因此，<strong>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右</strong>。奇偶不同，如果奇数得到小数，则舍弃小数得到整数。</li><li>新数组的最大容量是 <code>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</code> 。</li><li><strong>判断是否需要扩容还要再看文章理解</strong>。</li></ul><hr><h3 id="3-ArrayList-中方法部分源码"><a href="#3-ArrayList-中方法部分源码" class="headerlink" title="3. ArrayList 中方法部分源码"></a>3. ArrayList 中方法部分源码</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *返回此列表中的元素数。      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表不包含元素，则返回 true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//注意=和==的区别</span>        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表包含指定的元素，则返回true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//equals()方法比较</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）      */</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>            v<span class="token punctuation">.</span>elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            v<span class="token punctuation">.</span>modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这不应该发生，因为我们是可以克隆的</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。      *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 用指定的元素替换此列表中指定位置的元素。      */</span>    <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对index进行界限检查</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回原来在这个位置的元素</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将指定的元素追加到此列表的末尾。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。      */</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>      <span class="token comment" spellcheck="true">//从列表中删除的元素 </span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中删除所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把数组中所有的元素的值设为null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>ArrayList 中最常用的方法有 <code>add()</code>，<code>size()</code>，<code>remove()</code>，<code>get()</code>，<code>set()</code>，<code>isEmpty()</code>，<code>contains</code>。</li><li>其中 <code>add()</code> 方法可以有<strong>两个入参</strong>，第一个参数为插入数组的位置，第二个为插入的元素。这种插入方式，插入后后方元素要全部后移，操作方式是用 <code>System.arraycopy()</code> ，会产生新的数组，消耗较大。相比之下，<strong>LinkedList 中有相同的方法，效率更高</strong>。</li><li><strong><code>toArray()</code> 方法还要再看文章理解</strong>。</li></ul><hr><h2 id="2-ArrayList-面试问题总结"><a href="#2-ArrayList-面试问题总结" class="headerlink" title="2. ArrayList 面试问题总结"></a>2. ArrayList 面试问题总结</h2><h3 id="1-ArrayList的扩容机制"><a href="#1-ArrayList的扩容机制" class="headerlink" title="1. ArrayList的扩容机制"></a>1. ArrayList的扩容机制</h3><ol><li>ArrayList源码中有三个构造函数。其中<strong>无参构造，ArrayList的长度为0，直到添加第一个元素时进行扩容，大小为10</strong>。</li><li>当数组需要扩容时，<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</strong>，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</li><li>新数组的最大容量是Integer的最大值，<code>Integer.MAX_VALUE</code>。</li><li>扩容后 ArrayList 调用的是<code>Arrays.copyOf()</code>方法，默认返回一个新数组。</li><li>ArrayList 是允许空值（null）的。</li></ol><hr><h3 id="2-ArrayList-和-LinkedList-的对比"><a href="#2-ArrayList-和-LinkedList-的对比" class="headerlink" title="2. ArrayList 和 LinkedList 的对比"></a>2. ArrayList 和 LinkedList 的对比</h3><ol><li>线程安全：ArrayList 和 LinkedList 都是线程不同步的，不保证线程安全。</li><li>底层数据结构：ArrayList 的底层数据结构是 Object 数组；LinkedList 底层结构是双向链表。</li><li>插入和删除：ArrayList 插入和删除元素受元素位置的影响，时间复杂度较大；LinkedList 插入删除元素不受元素位置的影响，时间复杂度较小，但首先要移动到指定位置，这个过程时间复杂度较大。</li><li>快速随机访问（查找元素）：ArrayList 可以通过序号快速获取元素对象；LinkedList 不能，但也做了优化，先用二分法判断靠近哪一端，再从较近的一端开始查找。</li><li>内存空间占用：ArrayList 空间浪费体现在预留一定的容量空间；LinkedList 空间花费体现在，它的每一个元素都要多储存前驱和后继。</li></ol><hr><h3 id="3-ArrayList-和-Vector-的对比"><a href="#3-ArrayList-和-Vector-的对比" class="headerlink" title="3. ArrayList 和 Vector 的对比"></a>3. ArrayList 和 Vector 的对比</h3><ol><li>线程安全：Vector 是线程同步的，保证线程安全；ArrayList 是线程不同步的，不保证线程安全。</li><li>效率：Vector 在线程同步操作上会花费时间，因此访问比 ArrayList 慢。</li><li>扩容：Vector 扩容时增长率为100%；ArrayList 扩容时增长率为50%。</li></ol><ul><li><strong>总结</strong>：需要线程安全用 Vector，不需要线程安全用 ArrayList。</li></ul><hr><h3 id="4-ArrayList-和-CopyOnWriteArrayList-的对比"><a href="#4-ArrayList-和-CopyOnWriteArrayList-的对比" class="headerlink" title="4. ArrayList 和 CopyOnWriteArrayList 的对比"></a>4. ArrayList 和 CopyOnWriteArrayList 的对比</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2020/08/05/linkedlist-yuan-ma-jie-xi/"/>
      <url>/2020/08/05/linkedlist-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList-源码解析"><a href="#LinkedList-源码解析" class="headerlink" title="LinkedList 源码解析"></a>LinkedList 源码解析</h1><h2 id="1-定义及构造方法源码"><a href="#1-定义及构造方法源码" class="headerlink" title="1. 定义及构造方法源码"></a>1. 定义及构造方法源码</h2><h3 id="1-LinkedList-简介"><a href="#1-LinkedList-简介" class="headerlink" title="1. LinkedList 简介"></a>1. LinkedList 简介</h3><ul><li><p>LinkedList 实现了 <strong>List 接口</strong> 和 <strong>Deque 接口</strong>，是一个<strong>双端链表</strong>，同时也具有<strong>队列</strong>的性质。</p></li><li><p>LinkedList 实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</p></li><li><p>LinkedList 实现了 <strong>java.io.serializable</strong> 接口，这表示 ArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</p></li><li><p>LinkedList 的链表结构使其支持<strong>高效的插入和删除操作</strong>。需要注意的是：<strong>LinkedList 虽然是链表结构，但也有索引</strong>。</p></li><li><p>如果想要使 LinkedList 变成线程安全的，可以<strong>调用静态类 Collections 类中的 synchronizedList 方法</strong>：</p></li></ul><pre class=" language-java"><code class="language-java">List list <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h3><p>LinkedList 内部定义了三个变量：<strong>size、first 和 last</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Deque<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Pointer to first node.     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Pointer to last node.     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre><p>LinkedList 内部的链表节点有三个属性，分别是<strong>当前节点的值，前驱节点和后继节点</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后继节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前驱节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h3><p>LinkedList 的构造方法可以有参，也可以无参。</p><ol><li>无参构造方法</li></ol><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>有参构造方法（用已有的集合创建链表）</li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以看出，有参构造方法是调用了 <code>addAll()</code> 方法，后面会有介绍。</p><hr><h2 id="2-添加方法源码"><a href="#2-添加方法源码" class="headerlink" title="2. 添加方法源码"></a>2. 添加方法源码</h2><h3 id="1-linkLast-linkFirst-方法"><a href="#1-linkLast-linkFirst-方法" class="headerlink" title="1. linkLast / linkFirst 方法"></a>1. linkLast / linkFirst 方法</h3><ul><li>最核心的添加方法 <code>linkLast(E e)</code> ：</li></ul><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     * 链接使e作为最后一个元素。     * 其中last是链表中指向最后一个节点的指针     * 其中first是链表中指向第一个节点的指针     * l的作用是记录上一个节点     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向后继元素也就是指向下一个元素</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ol><li>先新建引用（l）<strong>记录上一个节点</strong>，也就是之前的最后一个节点（last）；</li><li><strong>新建节点</strong> newNode，前驱指向 l，后继为 null；</li><li><strong>令 last 指向新建节点</strong>，此时新建节点是链表的最后一个节点；</li><li>判断上一节点 l 是否为 null，是则说明新节点是第一个节点，first 也要指向新节点；不是则<strong>将上一节点的后继指向新节点</strong>。</li></ol><ul><li>从头部添加的方法<code>linkFirst(E e)</code> ：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**      * 操作方法步骤与上述linkLast方法相同      */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建节点，以头节点为后继节点</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果链表为空，last节点也指向该节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="2-add-方法"><a href="#2-add-方法" class="headerlink" title="2. add 方法"></a>2. add 方法</h3><ul><li><code>add(E e)</code> 方法：将元素添加到链表尾部。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里就只调用了这一个方法</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可见，<strong><code>add()</code> 就是调用了 <code>linkLast()</code> 方法</strong>，返回 true 则说明添加成功。</p><ul><li><code>add(int index, E e)</code> ：将元素添加到指定位置。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查索引是否处于[0-size]之间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加在链表尾部</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//添加在链表中间</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>linkBefore()</code> 方法又需其他条件。只需记住，<strong>LinkedList 的插入添加操作比 ArrayList 效率更高</strong>。</p><ul><li><code>addFirst(E e)</code> ：将元素添加到链表头部。</li></ul><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><code>addLast(E e)</code> ：将元素添加到链表尾部。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>向尾部添加元素一般使用 <code>add()</code> 方法</strong>。</p><hr><h3 id="3-addAll-方法"><a href="#3-addAll-方法" class="headerlink" title="3. addAll 方法"></a>3. addAll 方法</h3><ul><li><code>addAll(Collection c)</code> ：将<strong>集合</strong>添加到链表尾部。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">addAll</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>调用的是重载方法，也就是从链表的最后开始插入。</p><ul><li><code>addAll(int index, Collection c)</code> ：将<strong>集合</strong>添加到链表指定位置。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1:检查index范围是否在size之内</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2:toArray()方法把集合的数据存到对象数组中</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numNew <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3：得到插入位置的前驱节点和后继节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred<span class="token punctuation">,</span> succ<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果插入位置为尾部，前驱节点为last，后继节点为null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> null<span class="token punctuation">;</span>            pred <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，调用node()方法得到后继节点，再得到前驱节点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 4：遍历数据将数据插入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> E e <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> o<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//创建新节点</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果插入位置在链表头部</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>                first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            pred <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果插入位置在尾部，重置last节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，将插入的链表与先前链表连接起来</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span>            succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    </code></pre><ol><li>检查index范围是否在 size 之内；</li><li>调用 <code>toArray()</code> 方法把集合的数据存到对象数组中（Object 数组）；</li><li>调用 <code>node()</code> 方法得到插入位置的前驱和后继节点；</li><li>遍历数据，将数据插入到指定位置。</li></ol><hr><h2 id="3-根据索引获取对象的方法源码"><a href="#3-根据索引获取对象的方法源码" class="headerlink" title="3. 根据索引获取对象的方法源码"></a>3. 根据索引获取对象的方法源码</h2><h3 id="1-node-方法"><a href="#1-node-方法" class="headerlink" title="1. node 方法"></a>1. node 方法</h3><ul><li>最核心的根据索引获取数据的方法 <code>node(int index)</code> ：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 返回一个指定索引的非空节点.     */</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert isElementIndex(index);</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><code>node()</code> 方法的机制是：<strong>先判断指定位置是在链表的前半段还是后半段，然后从较近的一端开始遍历</strong>，直到找到指定元素。</p><hr><h3 id="2-get-方法"><a href="#2-get-方法" class="headerlink" title="2. get 方法"></a>2. get 方法</h3><ul><li><code>get(int index)</code> ：根据指定索引获取数据。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查index范围是否在size之内</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用Node(index)去找到index对应的node然后返回它的值</span>        <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可见，<code>get()</code> 方法是调用了 <code>node()</code> 方法实现的。</p><hr><h3 id="3-获取头节点的方法"><a href="#3-获取头节点的方法" class="headerlink" title="3. 获取头节点的方法"></a>3. 获取头节点的方法</h3><ul><li>获取<strong>头节点</strong>的方法：</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//element()就是getFirst()实现的，二者没有区别</span>    <span class="token keyword">public</span> E <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//与peek()没有区别</span>    <span class="token keyword">public</span> E <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p><strong>使用和区别</strong>：常用方法为 <code>getFirst()</code> 和 <code>peek()/peekFirst()</code> 。二者的区别在于，<strong>当链表为空时</strong>（头节点为空则链表为空），<code>getFirst()</code> 方法会<strong>抛出异常</strong>，<code>peek()</code> 方法会<strong>返回 null</strong>。</p><hr><h3 id="4-获取尾节点的方法"><a href="#4-获取尾节点的方法" class="headerlink" title="4. 获取尾节点的方法"></a>4. 获取尾节点的方法</h3><ul><li>获取<strong>尾节点</strong>的方法：</li></ul><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> E <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> E <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>区别</strong>：<strong>当链表为空时</strong>（尾节点为空则链表为空），<code>getLast()</code> 方法会<strong>抛出异常</strong>，<code>peekLast()</code> 方法会<strong>返回 null</strong>。</p><hr><h2 id="4-根据对象获得索引的方法源码"><a href="#4-根据对象获得索引的方法源码" class="headerlink" title="4. 根据对象获得索引的方法源码"></a>4. 根据对象获得索引的方法源码</h2><h3 id="1-indexOf-方法"><a href="#1-indexOf-方法" class="headerlink" title="1. indexOf 方法"></a>1. indexOf 方法</h3><ul><li><code>int indexOf(Object o)</code> ：从头遍历寻找。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="2-lastIndexOf-方法"><a href="#2-lastIndexOf-方法" class="headerlink" title="2. lastIndexOf 方法"></a>2. lastIndexOf 方法</h3><ul><li><code>int lastIndexOf(Object o)</code> ：从尾遍历寻找。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从尾遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从尾遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="3-contains-方法"><a href="#3-contains-方法" class="headerlink" title="3. contains 方法"></a>3. contains 方法</h3><ul><li><code>contains(Object o)</code> ：检查对象 o 是否存在于链表中。</li></ul><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可见，<code>contains()</code> 方法就是调用了 <code>indexOf()</code> 方法，判断返回值是否合理。</p><hr><h2 id="5-删除方法源码"><a href="#5-删除方法源码" class="headerlink" title="5. 删除方法源码"></a>5. 删除方法源码</h2><h3 id="1-unlink-方法"><a href="#1-unlink-方法" class="headerlink" title="1. unlink 方法"></a>1. unlink 方法</h3><ul><li>最核心的删除方法 <code>unlink(Node x)</code> ：</li></ul><pre class=" language-java"><code class="language-java">    E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert x != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到后继节点</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到前驱节点</span>        <span class="token comment" spellcheck="true">//删除前驱指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将前驱节点的后继节点指向后继节点</span>            x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//删除后继指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>unlink()</code> 方法的作用就是断开指定节点的前驱和后继，是删除方法中的核心。</p><hr><h3 id="2-remove-方法"><a href="#2-remove-方法" class="headerlink" title="2. remove 方法"></a>2. remove 方法</h3><p><strong>remove方法共有三种重载形式</strong>，每种形式的作用都不相同。</p><ol><li><code>remove()</code> ：空参形式，删除头节点，后面介绍。</li><li><code>remove(Object o)</code> ：删除<strong>指定元素</strong>。</li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果删除对象为null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头开始遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//找到元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//从链表中移除找到的元素</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头开始遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//找到元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//从链表中移除找到的元素</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>需要<strong>先遍历链表找到此元素</strong>，再调用 <code>unlink()</code> 方法删除。遍历方式为<strong>从头遍历</strong>。</li><li>此方法一次只会删除一个匹配的对象，成功返回 true。</li></ul><ol start="3"><li><code>remove(int index)</code> ：删除<strong>指定位置的元素</strong>。</li></ol><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查index范围</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将节点删除</span>        <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>先调用 <code>node()</code> 方法找到该元素，再调用 <code>unlink()</code> 方法删除。</li></ul><hr><h3 id="3-删除头节点的方法"><a href="#3-删除头节点的方法" class="headerlink" title="3. 删除头节点的方法"></a>3. 删除头节点的方法</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>三者实为同一种方法，其他方法都是调用 <strong><code>removeFirst()</code></strong> ，当链表为空时，会抛出异常。使用时也尽量使用此方法。</li></ul><hr><h3 id="4-删除尾节点的方法"><a href="#4-删除尾节点的方法" class="headerlink" title="4. 删除尾节点的方法"></a>4. 删除尾节点的方法</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>区别：当链表为空时，<code>removeLast()</code> 方法会抛出异常，而 <code>pollLast()</code> 方法会返回 null。</li></ul><hr><h2 id="6-LinkedList-面试问题总结"><a href="#6-LinkedList-面试问题总结" class="headerlink" title="6. LinkedList 面试问题总结"></a>6. LinkedList 面试问题总结</h2><h3 id="1-ArrayList-和-LinkedList-的对比"><a href="#1-ArrayList-和-LinkedList-的对比" class="headerlink" title="1. ArrayList 和 LinkedList 的对比"></a>1. ArrayList 和 LinkedList 的对比</h3><ol><li>线程安全：ArrayList 和 LinkedList 都是线程不同步的，不保证线程安全。</li><li>底层数据结构：ArrayList 的底层数据结构是 Object 数组；LinkedList 底层结构是双向链表。</li><li>插入和删除：ArrayList 插入和删除元素受元素位置的影响，时间复杂度较大；LinkedList 插入删除元素不受元素位置的影响，时间复杂度较小，但首先要移动到指定位置，这个过程时间复杂度较大。</li><li>快速随机访问（查找元素）：ArrayList 可以通过序号快速获取元素对象；LinkedList 不能，但也做了优化，先用二分法判断靠近哪一端，再从较近的一端开始查找。</li><li>内存空间占用：ArrayList 空间浪费体现在预留一定的容量空间；LinkedList 空间花费体现在，它的每一个元素都要多储存前驱和后继。</li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发容器总结</title>
      <link href="/2020/08/05/bing-fa-rong-qi-zong-jie/"/>
      <url>/2020/08/05/bing-fa-rong-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="并发容器总结"><a href="#并发容器总结" class="headerlink" title="并发容器总结"></a>并发容器总结</h1><h2 id="1-ArrayList-的并发容器-CopyOnWriteArrayList"><a href="#1-ArrayList-的并发容器-CopyOnWriteArrayList" class="headerlink" title="1. ArrayList 的并发容器 CopyOnWriteArrayList"></a>1. ArrayList 的并发容器 CopyOnWriteArrayList</h2><h3 id="1-CopyOnWriteArrayList-简介"><a href="#1-CopyOnWriteArrayList-简介" class="headerlink" title="1. CopyOnWriteArrayList 简介"></a>1. CopyOnWriteArrayList 简介</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Object</span>    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable</code></pre><ul><li>实现了 <strong>RandomAccess 接口</strong>，实现这个接口表明集合是支持<strong>快速随机访问</strong>的。在 CopyOnWriteArrayList 中，可以<strong>通过元素的序号快速获取元素</strong>，这就是快速随机访问。</li><li>实现了 Cloneable 接口，即覆盖了 <code>clone()</code> ，<strong>可以被克隆</strong>。</li><li>实现了 <strong>java.io.serializable</strong> 接口，这表示 CopyOnWriteArrayList <strong>支持序列化，可以通过序列化进行传输</strong>。</li><li><strong>CopyOnWriteArrayList 是线程安全的</strong>。同样线程安全的数组容器还有有 Vector 。</li></ul><hr><h3 id="2-CopyOnWriteArrayList-读取操作的实现"><a href="#2-CopyOnWriteArrayList-读取操作的实现" class="headerlink" title="2. CopyOnWriteArrayList 读取操作的实现"></a>2. CopyOnWriteArrayList 读取操作的实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** The array, accessed only via getArray/setArray. */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>可见，<strong>CopyOnWriteArrayList 读取操作没有任何同步和锁操作</strong>。</li><li>读取操作并不会改变数组，因此对读取操作加锁是一种浪费资源，<strong>读取操作允许多个线程同时访问</strong>。ReentrantReadWriteLock 读写锁的思想是，<strong>读读共享、写写互斥、读写互斥和写读互斥</strong>。而 <strong>CopyOnWriteArrayList 可以做到读写不互斥，只有写写之间需要同步等待</strong>。</li><li>CopyOnWriteArrayList 即使发生修改，<strong>原内部数组也不会改变，而是产生一个新数组，然后将引用指向新数组</strong>，因此可以保证数据安全，读写可以同时进行。</li></ul><hr><h3 id="3-CopyOnWriteArrayList-写入操作的实现"><a href="#3-CopyOnWriteArrayList-写入操作的实现" class="headerlink" title="3. CopyOnWriteArrayList 写入操作的实现"></a>3. CopyOnWriteArrayList 写入操作的实现</h3><p>CopyOnWriteArrayList 写入操作 <code>add()</code> 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list e是要加入数组的元素     * @return {@code true} (as specified by {@link Collection#add})     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加锁</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝新数组，长度+1</span>            <span class="token comment" spellcheck="true">//把新元素放在数组的末尾</span>            newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放锁</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ul><li>这里并发控制使用的是 <strong>ReentrantLock</strong>，没有使用 synchronized。</li></ul><hr><h3 id="4-CopyOnWriteArrayList-和-Vector-的对比"><a href="#4-CopyOnWriteArrayList-和-Vector-的对比" class="headerlink" title="4. CopyOnWriteArrayList 和 Vector 的对比"></a>4. CopyOnWriteArrayList 和 Vector 的对比</h3><ol><li>Vector 内增删改查所有的方法都加了 synchronized 关键字，但效率低，每次同步都要获取锁和释放锁。</li><li>CopyOnWriteArrayList 仅在增删改方法上加了锁，查方法没有加锁。可能会导致读取到的不是最新值。</li><li>CopyOnWriteArrayList 使用的是 ReentrantLock。并且在添加过程中复制出一个新数组，不影响原数组的读。</li></ol><hr><h3 id="5-CopyOnWriteArrayList-和-Collections-synchronizedList-的对比"><a href="#5-CopyOnWriteArrayList-和-Collections-synchronizedList-的对比" class="headerlink" title="5. CopyOnWriteArrayList 和 Collections.synchronizedList 的对比"></a>5. CopyOnWriteArrayList 和 Collections.synchronizedList 的对比</h3><ol><li>Collections.synchronizedList 对部分操作加了 synchronized 关键字，<strong>包括读操作</strong>，但遍历操作还是线程不安全的。CopyOnWriteArrayList 使用的是 ReentrantLock，仅在增删改方法上加了锁，<strong>读操作没有加锁</strong>。</li><li>在多线程高并发的条件下，CopyOnWriteArrayList 由于每次都要复制新数组出来，<strong>写操作的效率不如 Collections.synchronizedList</strong>。而由于 Collections.synchronizedList 在读操作上加了锁，<strong>读操作的效率不如 CopyOnWriteArrayList</strong>。</li><li>CopyOnWriteArrayList 适合以读为主的业务，如用作缓存。Collections.synchronizedList 适用于读写操作均衡的情况。</li></ol><hr><h2 id="2-队列的并发容器"><a href="#2-队列的并发容器" class="headerlink" title="2. 队列的并发容器"></a>2. 队列的并发容器</h2><h3 id="1-ConcurrentLinkedQueue-简介"><a href="#1-ConcurrentLinkedQueue-简介" class="headerlink" title="1. ConcurrentLinkedQueue 简介"></a>1. ConcurrentLinkedQueue 简介</h3><p>Java 提供的线程安全的 Queue 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中<strong>阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue</strong>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>ConcurrentLinkedQueue 使用链表作为其数据结构，<strong>ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了</strong>。它之所有能有很好的性能，是因为其内部复杂的实现。对于 ConcurrentLinkedQueue 知道<strong>主要使用 CAS 非阻塞算法来实现线程安全</strong>就好了。</p><p>ConcurrentLinkedQueue 适合在<strong>对性能要求相对较高，同时对队列的读写存在多个线程同时进行</strong>的场景。</p><hr><h3 id="2-BlockingQueue-简介"><a href="#2-BlockingQueue-简介" class="headerlink" title="2. BlockingQueue 简介"></a>2. BlockingQueue 简介</h3><ul><li><p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 <strong>BlockingQueue 提供了可阻塞的插入和移除的方法</strong>。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。 </p></li><li><p><strong>BlockingQueue 是一个接口</strong>，继承自 Queue，所以<strong>其实现类也可以作为 Queue 的实现来使用（多态）</strong>，而 Queue 又继承自 Collection 接口。 </p></li></ul><p>接下来主要介绍 BlockingQueue 的三个实现类：<strong>ArrayBlockingQueue、LinkedBlockingQueue 和 PriorityBlockingQueue</strong>。</p><hr><h3 id="3-ArrayBlockingQueue-简介"><a href="#3-ArrayBlockingQueue-简介" class="headerlink" title="3. ArrayBlockingQueue 简介"></a>3. ArrayBlockingQueue 简介</h3><ul><li><p><strong>ArrayBlockingQueue</strong> 是 BlockingQueue 接口的有界队列实现类，底层采用<strong>数组</strong>来实现。ArrayBlockingQueue 一旦创建，<strong>容量不能改变</strong>。其并发控制采用<strong>可重入锁</strong>来控制，<strong>不管是插入操作还是读取操作，都需要获取到锁才能进行操作</strong>。当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。</p></li><li><p>ArrayBlockingQueue 的锁是非公平锁，如果要保证公平性，通常会降低吞吐量。如果需要获得公平的 ArrayBlockingQueue，构造方法中提供了相关参数：</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> ArrayBlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="4-LinkedBlockingQueue-简介"><a href="#4-LinkedBlockingQueue-简介" class="headerlink" title="4. LinkedBlockingQueue 简介"></a>4. LinkedBlockingQueue 简介</h3><ul><li><strong>LinkedBlockingQueue</strong> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，<strong>与 ArrayBlockingQueue 相比起来具有更高的吞吐量</strong>，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，<strong>如果未指定，容量等于 Integer.MAX_VALUE</strong>。 </li></ul><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *某种意义上的无界队列，队列容量非常大     * Creates a {@code LinkedBlockingQueue} with a capacity of     * {@link Integer#MAX_VALUE}.     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *有界队列     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.     *     * @param capacity the capacity of this queue     * @throws IllegalArgumentException if {@code capacity} is not greater     *         than zero     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="5-PriorityBlockingQueue-简介"><a href="#5-PriorityBlockingQueue-简介" class="headerlink" title="5. PriorityBlockingQueue 简介"></a>5. PriorityBlockingQueue 简介</h3><ul><li><strong>PriorityBlockingQueue</strong> 是一个<strong>支持优先级的无界阻塞队列</strong>。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</li><li>PriorityBlockingQueue 队列为无界队列。ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 可以通过在构造函数中传入 capacity 指定队列最大的容量。但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>。</li><li>PriorityBlockingQueue 并发控制采用的是 <strong>ReentrantLock</strong>。</li><li>简单地说，它就是 <strong>PriorityQueue 的线程安全版本</strong>。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的<strong>插入操作 <code>put()</code> 方法不会阻塞，因为它是无界队列。<code>take()</code> 方法在队列为空的时候会阻塞</strong> 。</li></ul><hr><h2 id="3-HashMap-的并发容器-ConcurrenHashMap"><a href="#3-HashMap-的并发容器-ConcurrenHashMap" class="headerlink" title="3. HashMap 的并发容器 ConcurrenHashMap"></a>3. HashMap 的并发容器 ConcurrenHashMap</h2><h3 id="1-ConcurrenHashMap-简介"><a href="#1-ConcurrenHashMap-简介" class="headerlink" title="1. ConcurrenHashMap 简介"></a>1. ConcurrenHashMap 简介</h3><p>在 ConcurrentHashMap 中，<strong>无论是读操作还是写操作都能保证很高的性能</strong>：在进行读操作时(几乎)不需要加锁，而在写操作时，通过<strong>锁分段技术</strong>只对所操作的段加锁，而不影响客户端对其它段的访问。 </p><ul><li>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 </li><li>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</li></ul><hr><h3 id="2-Java-7-和-Java-8-中ConcurrenHashMap-的区别"><a href="#2-Java-7-和-Java-8-中ConcurrenHashMap-的区别" class="headerlink" title="2. Java 7 和 Java 8 中ConcurrenHashMap 的区别"></a>2. Java 7 和 Java 8 中ConcurrenHashMap 的区别</h3><ol><li><strong>Java 7</strong> 中，ConcurrnetHashMap 由很多个 <strong>Segment</strong> 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>。</li></ol><p><img src="%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93.assets/5220087-8c5b0cc951e61398.webp" alt=""></p><ul><li>整理：<ul><li><strong>Segment 的个数默认是 16</strong>，也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发；</li><li>Segment 的个数也会向上取得最近的 2 的整数幂；</li><li>Segment 中的 HashMap 默认容量是 2，负载因子 0.75f，扩容阈值 1.5，插入第二个值时才会扩容；</li><li>Segment 中的 HashMap 扩容机制和 HashMap 相同，容量扩容为原来的 2 倍。<strong>数据迁移后，只可能在原来的位置，或者（原来的位置 + 原来的容量）位置</strong>（HashMap 也是一样）；</li><li><strong>Segment 继承了 ReentrantLock</strong>，所以 Segment 内部可以很方便的获取锁。</li></ul></li></ul><ol start="2"><li><strong>Java 8</strong> 中，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>，非常类似于 Java 8 中的 HashMap</li></ol><p><img src="%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93.assets/5220087-63281d7b737f1109.webp" alt=""></p><ul><li>整理：<ul><li>使用 <strong>CAS 和 synchronized 锁</strong>来保证并发安全。不产生哈希冲突时，使用 CAS 进行加入等操作，有哈希冲突时，用 synchronized 锁住头节点保证线程安全；</li><li>关键数据如 value 用 volatile 修饰，保证可见性，但不能保证原子性。</li><li>原子性用锁来保证。<strong>synchronized 只锁定当前链表或红黑二叉树的首节点</strong>，这样只要 hash 不冲突，就不会产生并发，提高效率。</li><li><code>get()</code> 方法没有同步过程。</li></ul></li></ul><hr><h3 id="3-ConcurrentHashMap-的-put-方法"><a href="#3-ConcurrentHashMap-的-put-方法" class="headerlink" title="3. ConcurrentHashMap 的 put 方法"></a>3. ConcurrentHashMap 的 put 方法</h3><ol><li>检查 val 是否为 null，如果是，抛出空指针异常；</li><li>求 key 的哈希值，这里不想 hashmap 做了判读，如果 key 为 null，也会返回空指针异常；</li><li>判断哈希表是否初始化，如果没有，进行初始化；</li><li>定位当前位置，如果是空，CAS 写入；</li><li>如果是 MOVED == -1，表示正在扩容，帮助扩容；</li><li>如果当前节点有值，判断是链表还是红黑树，链表则遍历，红黑树则调用树的方法遍历；</li><li>调用 addCount 方法，修改 baseCount 值，这里又涉及到 <code>size()</code> 方法和一个 CounterCell 类。</li></ol><hr><h3 id="4-ConcurrentHashMap-键值均不能为空"><a href="#4-ConcurrentHashMap-键值均不能为空" class="headerlink" title="4. ConcurrentHashMap 键值均不能为空"></a>4. ConcurrentHashMap 键值均不能为空</h3><blockquote><p><strong>思想原因</strong></p></blockquote><ol><li>如果 key 和 val 可以等于 null，那无法判断是 <strong>get 不到返回的 null，还是就是 get 到了 null</strong>；</li><li>ConcurrentHashMap 应用于并发之下，不能再调用 contains 方法进行判断。因为可能出现的情况是：<strong>原本键值就是 null，想要判断是上述哪一种情况下的 null，但并发下被另一线程删除了，再调用 contains 发现并没有这个值返回 false，就会出现问题</strong>。</li><li>HashTable 同理，不能为 null 值。</li></ol><blockquote><p><strong>代码层面</strong></p></blockquote><ol><li>put 时对 value 判断，为 null 直接抛出空指针异常；</li><li>对 key 不判断，直接求哈希值，如果 key 为 null，也会返回空指针异常；</li></ol><blockquote><p><strong>HashMap 的处理</strong></p></blockquote><ol><li>put 时对 value 不判断，可以为 null；</li><li>对 key 判断，如果 key 为 null，哈希值直接设为 0；</li></ol><hr><h3 id="5-Forwarding-节点和-CounterCell-类"><a href="#5-Forwarding-节点和-CounterCell-类" class="headerlink" title="5. Forwarding 节点和 CounterCell 类"></a>5. Forwarding 节点和 CounterCell 类</h3><blockquote><p><strong>Forwarding 节点</strong></p></blockquote><ol><li>哈希表扩容时会在每个桶的首节点插入 Forwarding 节点，且设定其哈希值为 MOVED = -1；</li><li>当 put 时发现首节点哈希值是 -1，则说明哈希表正在扩容。</li></ol><blockquote><p><strong>CounterCell 类</strong></p></blockquote><ol><li><code>addCount()</code> 方法：修改 baseCount 值，每次 put 操作后都要调用。方法使用的是 CAS 操作进行更新，如果更新失败，就会将新加入的节点封装为 <strong>CounterCell 类</strong>（其实还调用了 fulladdcount() 方法），其方法内部维护了一个 CounterCell 类数组。</li><li>简单的例子就是一个线程添加了一个元素，调用了 addcount 方法，这时另一个线程的 addcount 方法刚结束，使 basecount 值和期望值不同，导致 CAS 操作失败。</li><li><code>size()</code> 方法其实是调用了 <code>sumCount()</code> 方法，并不是直接返回 basecount 值，而是 basecount + CounterCell 类数组长度。</li></ol><hr><h3 id="6-ConcurrentHashMap-的-fail-safe-机制"><a href="#6-ConcurrentHashMap-的-fail-safe-机制" class="headerlink" title="6. ConcurrentHashMap 的 fail-safe 机制"></a>6. ConcurrentHashMap 的 fail-safe 机制</h3><ol><li>ConcurrentHashMap 并不向 COWArrayList 那样每次都 COW。</li><li>只是在迭代器类中实现了 copy，其迭代器类中维护了一个成员变量 ConcurrentHashMap map，生成迭代器时会将 map 初始化为当前 map，就是生成了一份快照。</li></ol><hr><h3 id="7-为什么-get-方法不需要加锁"><a href="#7-为什么-get-方法不需要加锁" class="headerlink" title="7. 为什么 get 方法不需要加锁"></a>7. 为什么 get 方法不需要加锁</h3><ul><li>ConcurrentHashMap 的 Node 中，<strong>value 是 volatile 修饰的</strong>，保证了修改的可见性。</li></ul><blockquote><p>volatile</p></blockquote><p>JMM 中的 happens-before 原则：其中有 volatile，被 volatile 修饰的变量，写操作会保证在后续读写操作之前，防止指令重排序，保证有序性，也可以保证 get 到的是最新值。</p><hr><h3 id="8-ConcurrentHashMap-和-HashTable-的对比"><a href="#8-ConcurrentHashMap-和-HashTable-的对比" class="headerlink" title="8. ConcurrentHashMap 和 HashTable 的对比"></a>8. ConcurrentHashMap 和 HashTable 的对比</h3><ol><li>底层数据结构：JDK1.7之前ConcurrentHashMap由<strong>分段的数组+链表</strong>实现，JDK1.8采用的数据结构和HashMap一样，<strong>数组+链表/红黑树</strong>。HashTable和JDK1.8之前的HashMap采用<strong>数组+链表</strong>的形式。</li><li>实现线程安全的方式： <strong>ConcurrentHashMap **在JDK1.7时，对整个桶数组进行了分割分段（segment），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</strong>到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。** 整个看起来就像是优化过且线程安全的 HashMap 。<strong>HashTable</strong> 使用 synchronized 来保证线程安全，所有操作竞争一把锁，效率非常低下。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
