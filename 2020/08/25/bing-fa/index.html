<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="并发, 巨瑞康的个人博客">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>并发 | 巨瑞康的个人博客</title>
    <link rel="icon" type="image/png" href="/JRK.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="巨瑞康的个人博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">巨瑞康的个人博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">巨瑞康的个人博客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">并发</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" class="post-category">
                                Java学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-08-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-10-12
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    45 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><p>进程：进程是资源分配的基本单位，是系统运行程序的基本单位。开启一个程序如QQ，就是开启了一个进程。</p>
<p>线程：线程是比进程更小的执行单位，是CPU调度的最小单位。一个进程中可以有多个线程，它们可以共享进程资源。同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<ul>
<li>通俗的理解为：进程是一个工厂，线程是其中的流水线。</li>
</ul>
<p><strong>区别</strong>：</p>
<ol>
<li>进程是资源分配的基本单位，一个进程在运行过程中可能产生多个线程；</li>
<li>进程是资源分配的基本单位，但线程不拥有资源，线程可以访问隶属的进程的资源；</li>
<li>进程之间是相互独立的，但同一个进程中的线程之间可能相互影响；</li>
<li>执行进程的开销大于执行线程的开销，但利于资源的管理和保护，因为在执行进程时，系统需要分配或回收资源。</li>
</ol>
<hr>
<h3 id="2-进程的状态"><a href="#2-进程的状态" class="headerlink" title="2. 进程的状态"></a>2. 进程的状态</h3><ol>
<li>创建状态(new)：进程正在被创建，还没有达到就绪的状态；</li>
<li>就绪状态(ready)：进程已处理准备运行状态，即进程已获得除处理器之外的一切所需资源，一旦获得处理器资源，即可运行；</li>
<li>运行状态(running)：进程正在处理器上运行（单核CPU任意时刻只有一个进程处于运行状态）；</li>
<li>阻塞状态(waiting)：进程等待某一事件而暂停运行的状态，即使处理器空闲，该进程也不能运行；</li>
<li>结束状态(terminated)：进程正在结束，从系统中消失。可能是进程正常结束，也可能是其他原因中断退出运行。</li>
</ol>
<hr>
<h3 id="3-线程的生命周期和状态"><a href="#3-线程的生命周期和状态" class="headerlink" title="3. 线程的生命周期和状态"></a>3. 线程的生命周期和状态</h3><ol>
<li>初始状态(new)：线程被创建，但还没有调用 <code>start()</code> 方法。</li>
<li>运行状态(runnable)：Java 线程将操作系统中的就绪和运行两种状态统称 “运行中” 状态。当线程调用 <code>start()</code> 方法后开始运行，这时处于 ready 状态。可运行状态的线程得到了 CPU 的时间片 (timeslice) 后就处于 running 状态。注：时间片就分配给线程的时间。</li>
<li>阻塞状态(blocked)：<strong>没有得到 CPU 的执行资格，但当 CPU 空闲时可以抢夺 CPU 资源</strong>。表示线程阻塞于<strong>锁</strong>。当线程调用同步方法时，在没有获取到锁的情况下，线程会进入 blocked 状态。</li>
<li>等待状态(waiting)：进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断），<strong>当 CPU 空闲时也不可以抢夺 CPU 资源</strong>。当线程执行 <code>wait()</code> 方法后，线程进入 waiting 状态。</li>
<li>超时等待状态(time_waiting)：不同于 waiting 状态，<strong>可以在指定时间自行返回，可以抢夺 CPU 资源</strong>。<code>wait(long millis)</code> 方法和 <code>sleep()</code> 方法可以将线程置于 time_waiting 状态。</li>
<li>终止状态(terminated)：表示当前线程已经执行完毕。线程在执行 runnable 的 <code>run()</code> 方法之后，将会进入 terminated 状态。</li>
</ol>
<hr>
<h3 id="4-进程间通信的方式"><a href="#4-进程间通信的方式" class="headerlink" title="4. 进程间通信的方式"></a>4. 进程间通信的方式</h3><ol>
<li>管道/匿名管道(pipes)：实际是内核中的一段缓存，效率低，匿名管道是半双工的，有固定的流向，也就是说有固定的读端和写端。只能用于父子进程之间通信。</li>
<li>命名管道(name pipes)：实际是内核中的一段缓存，效率低，命名管道是全双工的，实际管道还是有固定流向的结构，但<strong>命名管道使用了两个管道来实现双向流通</strong>。可以用于任何进程。</li>
<li>信号(signal)：信号是 Linux 系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。常用的信号有：<ol>
<li>SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。</li>
<li>SIGINT：程序终止信号。程序运行过程中，按 <code>Ctrl+C</code> 键将产生该信号。</li>
<li>SIGQUIT：程序退出信号。程序运行过程中，按 <code>Ctrl+\</code> 键将产生该信号。</li>
<li>SIGBUS 和 SIGSEGV：进程访问非法地址。</li>
<li>SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。</li>
<li>SIGKILL：用户终止进程执行信号。shell下执行 <code>kill -9</code> 发送该信号。</li>
<li>SIGTERM：结束进程信号。shell下执行 <code>kill 进程pid</code> 发送该信号。</li>
</ol>
</li>
<li>消息队列(message queuing)：<strong>是一个消息的链表，保存在内核中</strong>。用户进程可以向队列中添加消息，也可以从队列中读取消息。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是<strong>可以根据自定义条件接收特定类型的消息</strong>。不适合大数据传输，有用户态和内核态之间拷贝的开销。</li>
<li>信号量(semaphores)：实现进程间的互斥和同步，是对资源数量的表示，基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>共享内存(shared memory)：进程间共享，所有进程都能看到。</li>
<li>套接字(sockets)：进程间的网络通信，socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用，从而实现进程在网络中通信。常用的函数有：<ol>
<li>socket() 函数：创建一个 socket 描述符，用于唯一标识一个 socket。参数有：domain 协议域，常用有 AF_INET，AF_INET6 等；type 类型，常用有 SOCK_STREAM，SOCK_PACKET 等；protocol 协议：常用有 IPPROTO_TCP，IPPROTO_UDP。</li>
<li>bind() 函数：把特定地址赋给 socket，绑定 IP 地址和端口号。通常服务器在启动的时候都会绑定一个众所周知的地址（如 IP 地址+端口号），用于提供服务，客户就可以通过它来连接服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的 IP 地址组合。 </li>
<li>listen() 函数：如果作为一个服务器，在绑定地址之后，需要调用 <code>listen()</code> 函数来监听这个 socket。</li>
<li>accept() 函数：服务器端收到客户端的请求后，使用这个函数接收请求。</li>
<li>connect() 函数：客户端想要与服务器建立连接，就要使用 <code>connect()</code> 函数发起请求。</li>
<li>read()/write() 函数：建立连接后，就可以进行读写操作了，使用 <code>read()/write()</code> 函数。</li>
<li>close() 函数：客户端想要断开连接，就要使用 <code>close()</code> 函数发起请求。</li>
</ol>
</li>
</ol>
<hr>
<h3 id="5-线程间的同步方式"><a href="#5-线程间的同步方式" class="headerlink" title="5. 线程间的同步方式"></a>5. 线程间的同步方式</h3><blockquote>
<p><strong>同步和互斥</strong></p>
</blockquote>
<p><strong>同步</strong>：线程间的同步是指<strong>多个线程按照一定的顺序执行任务</strong>，可以规定某一线程的顺序在另一个线程之前。</p>
<p><strong>互斥</strong>：线程间的互斥是指多个线程对资源的访问是互斥的，<strong>同一时刻只能有一个线程访问某一资源</strong>。</p>
<ol>
<li><p>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。 </p>
</li>
<li><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</p>
</li>
<li><p>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量； </p>
</li>
<li><p>事件：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p>
<p>对比：</p>
<ul>
<li>临界区不是内核对象，互斥量、信号量和事件都是内核对象；</li>
<li>临界区只能用于进程内部的线程同步；</li>
<li>互斥量、信号量和事件可以用于不同进程间的线程同步；</li>
<li>临界区和互斥量都有“线程所有权”的概念，所以它们不能用来实现线程间的同步，只能实现线程间的互斥；</li>
<li>信号量和事件既可以实现线程间的同步，也可以实现线程间的互斥。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>互斥量和信号量的区别</strong></p>
</blockquote>
<ol>
<li><strong>资源数量</strong>：互斥量是特殊的信号量，即信号量的值为一的情况。互斥量适用于资源唯一的情况，信号量用于资源为多个的情况。</li>
<li><strong>访问顺序</strong>：互斥量用于线程的互斥，锁定某一资源，但无法限制线程对资源的访问顺序。信号量可以实现互斥功能，同时也可以不锁定资源，而限制线程对资源的访问顺序（通过 PV 操作）。</li>
</ol>
<hr>
<h3 id="6-死锁产生的四个必要条件"><a href="#6-死锁产生的四个必要条件" class="headerlink" title="6. 死锁产生的四个必要条件"></a>6. 死锁产生的四个必要条件</h3><ul>
<li><strong>死锁</strong>： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 </li>
</ul>
<p>产生条件：</p>
<ol>
<li>互斥条件：进程对所分配到的资源进行排他性使用。一段时间内某个资源只能由一个进程使用，其他进程申请使用该资源只能等待，知道拥有者释放资源；</li>
<li>请求和保持条件：进程已经保持至少一个资源，又提出新的资源请求，该资源被其他进程占用，此请求进程进入阻塞状态，但不释放已保持的资源；</li>
<li>不剥夺条件：进程已获得的资源，在使用完成前，不能被剥夺，只能使用完成后由自己释放；</li>
<li>循环等待条件：进入死锁时，必然存在一个进程-资源环形链。</li>
</ol>
<hr>
<h3 id="7-如何避免死锁"><a href="#7-如何避免死锁" class="headerlink" title="7. 如何避免死锁"></a>7. 如何避免死锁</h3><ol>
<li>破坏互斥条件：做不到，因为用锁就是希望它们互斥；</li>
<li>破坏请求和保持条件：一次性申请所有资源；</li>
<li>破坏不剥夺条件：占用部分资源的线程在申请其他资源时，如果申请不到，可以主动释放已有资源；</li>
<li>破坏循环等待条件：按某一顺序申请资源，反序释放资源。</li>
</ol>
<hr>
<h3 id="8-上下文切换"><a href="#8-上下文切换" class="headerlink" title="8. 上下文切换"></a>8. 上下文切换</h3><ul>
<li>CPU 给线程分配时间片，执行完时间片后会切换线程；</li>
<li>切换前会保存当前线程的状态，下次时间片再给到这个线程时可以记得之前的状态；</li>
<li>从保存线程 A 的状态再切换到线程 B 时，重新加载线程 B 的这个过程叫做上下文切换。</li>
<li>上下文切换会消耗 CPU 大量时间。</li>
</ul>
<p><strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<hr>
<h3 id="9-sleep-方法和-wait-方法的对比"><a href="#9-sleep-方法和-wait-方法的对比" class="headerlink" title="9. sleep() 方法和 wait() 方法的对比"></a>9. sleep() 方法和 wait() 方法的对比</h3><ol>
<li><code>wait()</code> 方法是 Object 类中的方法，<code>sleep()</code> 方法是 Thread 类中的方法。</li>
<li><strong>最主要区别</strong>：<code>sleep()</code> 方法不会释放锁，而 <code>wait()</code> 方法会释放锁；</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code> 通常被用于暂停执行；</li>
<li><code>wait()</code> 方法被调用后，<strong>线程不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。<code>notify()</code> 方法唤醒的是等待时间最长的线程。<code>sleep()</code> 方法执行完成后，<strong>线程会自动苏醒</strong>。或使用<code>wait(long timeout)</code> 方法超时后，线程会自动苏醒。</li>
<li>两者都可以暂停线程的执行。</li>
</ol>
<hr>
<h3 id="10-start-方法和-run-方法"><a href="#10-start-方法和-run-方法" class="headerlink" title="10. start() 方法和 run() 方法"></a>10. start() 方法和 run() 方法</h3><p>new 一个 Thread，线程进入了新建状态; 调用 <code>start()</code> 方法，会启动一个线程并使线程进入就绪状态，<code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容。</p>
<p>而直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，而 <code>run()</code> 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong> </p>
<hr>
<h3 id="11-实现多线程-Thread-类和-Runnable-接口的对比"><a href="#11-实现多线程-Thread-类和-Runnable-接口的对比" class="headerlink" title="11. 实现多线程 Thread 类和 Runnable 接口的对比"></a>11. 实现多线程 Thread 类和 Runnable 接口的对比</h3><ul>
<li>继承 Thread 类和实现 Runnable 接口都可以实现多线程，相对来说更加推荐实现 Runnable 接口的方式。</li>
<li>由于 Java 中的类是单继承的，如果要继承 Thread 类就不能再继承其他类，这会造成<strong>继承的局限性</strong>。而接口可以多实现，实现接口的同时也可以继承其他类，不会受到影响。</li>
<li>继承 Thread 类后开启多线，程需要创建多个对象，这些对象是相互独立的，没有<strong>共享资源</strong>。而实现 Runnable 接口的类，只需要一个对象，分别传入三个线程中，这三个线程可以共享这个对象中的资源。</li>
</ul>
<hr>
<h3 id="12-协程"><a href="#12-协程" class="headerlink" title="12. 协程"></a>12. 协程</h3><blockquote>
<p>什么是协程</p>
</blockquote>
<p>协程是一种比线程更轻量级的存在，就如一个进程可以拥有多个线程一样，<strong>一个线程可以拥有多个协程</strong>。</p>
<ul>
<li>操作系统调度的最小单位是<strong>线程</strong>。</li>
<li><strong>协程并不受操作系统的管理</strong>，而是完全由用户控制（运行于用户态）。</li>
<li>协程在线程内<strong>完全串行执行</strong>。</li>
</ul>
<blockquote>
<p><strong>使用协程的好处</strong></p>
</blockquote>
<ol>
<li>避免了阻塞和可运行状态的切换。</li>
<li>避免了调度内核态和用户态的切换。</li>
<li>避免了上下文切换。</li>
<li>综上性能大大提高。</li>
</ol>
<p>Lua、Python、Go 和 Ruby 等语言都提供了原生实现，但 Java 没有，有框架提供了。</p>
<hr>
<h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h2><h3 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h3><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。 </p>
<ul>
<li>synchronized 关键字主要有三种使用方式：<ol>
<li><strong>修饰实例方法</strong>：作用于当前<strong>对象实例</strong>加锁，锁对象就是当前对象实例，就是 <code>this</code>。</li>
<li><strong>修饰静态方法</strong>：作用于<strong>当前类</strong>加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是<strong>类成员</strong>。这时的锁对象就是当前类的 class 属性，也就是 <strong>class 文件对象（反射）</strong>。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。 </li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。比如创建一个 object 对象，作为锁对象。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-双重校验锁实现对象单例（还不是很懂）"><a href="#2-双重校验锁实现对象单例（还不是很懂）" class="headerlink" title="2. 双重校验锁实现对象单例（还不是很懂）"></a>2. 双重校验锁实现对象单例（还不是很懂）</h3><p><strong>单例模式</strong>：这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">单例模式</a>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//uniqueInstance采用volatile 关键字修饰也是很有必要</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p> <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行： </p>
<ol>
<li>为 uniqueInstance 分配内存空间；</li>
<li>初始化 uniqueInstance；</li>
<li>将 uniqueInstance 指向分配的内存地址。</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<ul>
<li><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。 </li>
</ul>
<hr>
<h3 id="3-synchronized-关键字的底层原理"><a href="#3-synchronized-关键字的底层原理" class="headerlink" title="3. synchronized 关键字的底层原理"></a>3. synchronized 关键字的底层原理</h3><p>在使用 synchronized 来同步代码块的时候，经编译后，会在代码块的起始位置插入 <strong>monitorenter 指令</strong>，在结束或异常处插入 <strong>monitorexit 指令。</strong>当执行到 monitorenter 指令时，将会尝试获取对象所对应的 <strong>monitor</strong> 的所有权，即尝试获得对象的锁。而 synchronized 用的锁是存放在 <strong>Java对象头</strong> 中的。 </p>
<blockquote>
<p><strong>对象头和 monitor</strong></p>
</blockquote>
<ol>
<li><p>对象头：</p>
<p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息，<strong>会随着锁的变化而变化</strong>。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 </p>
</li>
</ol>
<p><img src="%E5%B9%B6%E5%8F%91.assets/2492081-09ff0d7367cc90d8.webp" alt=""></p>
<ol start="2">
<li>monitor：</li>
</ol>
<ul>
<li><p>Monitor 可以理解为一个同步工具或一种同步机制，Monitor 监视器源码是 C++ 写的，通常被描述为一个对象。</p>
</li>
<li><p><strong>每一个被锁住的对象都会和一个 monitor 关联</strong>，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 </p>
</li>
</ul>
<p><img src="%E5%B9%B6%E5%8F%91.assets/640-1601257307080.webp" alt=""></p>
<p>Monitor 源码：</p>
<pre class=" language-java"><code class="language-java">
  <span class="token function">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _header       <span class="token operator">=</span> NULL<span class="token punctuation">;</span>
    _count        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    _waiters      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 线程重入次数</span>
    _object       <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 存储Monitor对象</span>
    _owner        <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 持有当前线程的owner</span>
    _WaitSet      <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// wait状态的线程列表</span>
    _WaitSetLock  <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    _Responsible  <span class="token operator">=</span> NULL <span class="token punctuation">;</span>
    _succ         <span class="token operator">=</span> NULL <span class="token punctuation">;</span>
    _cxq          <span class="token operator">=</span> NULL <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 单向列表</span>
    FreeNext      <span class="token operator">=</span> NULL <span class="token punctuation">;</span>
    _EntryList    <span class="token operator">=</span> NULL <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 处于等待锁状态block状态的线程列表</span>
    _SpinFreq     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    _SpinClock    <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    OwnerIsThread <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    _previous_owner_tid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<hr>
<blockquote>
<p><strong>锁升级</strong></p>
</blockquote>
<p>synchronized 锁在 1.6 之后有一个升级的过程，状态分别为<strong>无锁、偏向锁、轻量级锁和重量级锁</strong>。</p>
<ul>
<li><p>无锁：不需要加锁的情况，没有线程抢占资源。</p>
</li>
<li><p><strong>偏向锁</strong>：大多数情况下只有一个线程访问同步资源，这时采用偏向锁。当一个新线程要获得锁时，步骤如下：</p>
<ol>
<li>查看 Mark Word 中偏向锁标志位是否为 0，如果是 0，用 CAS 操作将线程 ID 改为自己的线程 ID。</li>
<li>如果标志位不是 0，查看线程 ID 是否和本线程 ID 相同，如果是，则本线程已经拿到了锁，不需要再进行额外操作。</li>
<li>如果线程 ID 和本线程 ID 不同，则说明偏向锁被其他线程占用，升级为轻量级锁。</li>
</ol>
<ul>
<li>偏向锁只有在获得锁的时候使用了一次 CAS 操作，消耗很小。</li>
</ul>
</li>
<li><p><strong>轻量级锁</strong>：如果参与竞争的线程数不多且占用时间短，<strong>当有一个线程占用资源，而有另一个线程来竞争时，让这个线程自旋等待一段时间</strong>，如果在这段时间内占用资源的线程释放了锁，自旋的线程即可获得锁，提高了效率。步骤如下：</p>
<ol>
<li>首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后将对象头中的 Mark Word 复制到锁记录中。</li>
<li>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。如果成功，则获得轻量级锁，标志位为 00。</li>
</ol>
<ul>
<li><strong>当等待线程自旋结束还没有获得锁时，轻量级锁就会升级为重量级锁，另外当一个线程占用资源，一个线程在自旋等待，这时又有第三个线程来竞争资源时，也会升级为重量级锁</strong>。</li>
</ul>
</li>
<li><p><strong>重量级锁</strong>：参与竞争的线程多，占用时间长。当资源被一个线程占用时，其他来参与竞争的线程进入阻塞状态。即控制权交给了操作系统，由操作系统控制线程的阻塞和唤醒，这个过程需要操作系统在用户态和内核态之间反复切换，会消耗大量系统资源，导致性能低下。步骤如下：</p>
<ul>
<li><strong>重量级锁的状态下，对象的 mark word 为指向一个 monitor 对象的指针</strong>。 </li>
<li>已知 monitor 中维护了三个列表，一个重入次数和一个 owner。</li>
</ul>
</li>
</ul>
<p><img src="%E5%B9%B6%E5%8F%91.assets/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306164346662653f773d3131303126683d34303026663d7765627026733d3135363832.png" alt=""></p>
<ol>
<li>参与竞争的队列会首先进入 ContentionList，这是一个先进后出的结构，每次加入是在队首。</li>
<li>当 owner 线程要释放锁时，把 ContentionList 中的等待线程加入 EntryList，并选择一个线程作为 onedeck，使其有竞争锁的权利。</li>
<li>但 onedeck 不是一定会获取锁，这时如果有新的线程来尝试获取锁，是会和其竞争的，所以 synchronized 是非公平锁。</li>
<li>如果 owner 线程调用了 wait 方法，则加入 waitset 中，直到调用 notify/notifyAll 被唤醒，再重新加入 EntryList。</li>
</ol>
<hr>
<h3 id="4-synchronized-和-ReentrantLock-的对比"><a href="#4-synchronized-和-ReentrantLock-的对比" class="headerlink" title="4. synchronized 和 ReentrantLock 的对比"></a>4. synchronized 和 ReentrantLock 的对比</h3><ol>
<li>两者都是<strong>可重入锁</strong>：“可重入锁”概念是：<strong>自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的<strong>计数器</strong>都自增1，所以要等到锁的计数器下降为0时才能释放锁。 </li>
<li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong>：synchronized 是依赖于 JVM 实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
<li><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong>：<ul>
<li><strong>等待可中断</strong>：ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说<strong>正在等待锁的线程可以选择放弃等待，改为处理其他事情</strong>。 </li>
<li><strong>可实现公平锁</strong>：<strong>ReentrantLock 可以指定是公平锁还是非公平锁，而 synchronized 只能是非公平锁</strong>。<strong>所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。 </li>
<li><strong>可实现选择性通知</strong>：synchronized 关键字与 <code>wait()</code> 和 <code>notify()</code>/<code>notifyAll()</code> 方法相结合可以实现等待/通知机制。ReentrantLock 类借助于 Condition 接口与 <code>newCondition()</code> 方法也可以实现。Condition 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用 <code>notify()</code>/<code>notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。 </li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-volatile-关键字"><a href="#5-volatile-关键字" class="headerlink" title="5. volatile 关键字"></a>5. volatile 关键字</h3><blockquote>
<p><strong>JMM（ Java 内存模型）</strong></p>
</blockquote>
<p>描述 Java 中各种变量的访问规则。线程有自己的工作内存，<strong>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</strong>因此可能导致一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在工作内存中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p><img src="%E5%B9%B6%E5%8F%91.assets/640.webp" alt=""></p>
<blockquote>
<p><strong>缓存一致性和嗅探</strong></p>
</blockquote>
<ul>
<li><strong>缓存一致性</strong>是指，当 CPU 写数据时，如果发现操作的变量是共享变量，会发出信号通知其他 CPU 将该变量的缓存置为无效状态，因此其他 CPU 需要读取这个变量时，就会从内存重新读取。 </li>
<li><strong>嗅探</strong>机制是指，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的数据被修改，就会将当前处理器的缓存行设置成无效状态。</li>
</ul>
<blockquote>
<p><strong>happens-before</strong></p>
</blockquote>
<p><strong>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系</strong>。 </p>
<ol>
<li><strong>程序次序规则</strong>：在<strong>一个线程内</strong>一段代码的<strong>执行结果是有序的。</strong>就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。</li>
<li><strong>锁定规则</strong>：就是无论是在单线程环境还是多线程环境，对于<strong>同一个锁</strong>来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。</li>
<li><strong>volatile变量规则</strong>：就是如果一个线程先去写一个 volatile 变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li>
<li><strong>线程启动规则</strong>：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。 </li>
<li><strong>线程终止规则</strong>：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。 </li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。 </li>
<li><strong>传递规则</strong>：这个简单的，就是 happens-before 原则具有传递性，即 A happens-before B ， B happens-before C，那么 A happens-before C。 </li>
</ol>
<blockquote>
<p><strong>内存屏障</strong></p>
</blockquote>
<p>volatile 满足 happens-before 规则，其实现是用<strong>内存屏障</strong>。分为读（load）和写（store），屏障的实现在不同的处理器中不一定一样，比如 Intel 就定义了 4 个内存屏障，效果并不和以下说的一样。</p>
<ul>
<li><strong>LoadLoad</strong>：对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 Load2 及后续所有读取操作被执行前，保证 Load1 要读取的数据被读取完毕。 </li>
<li><strong>LoadStore</strong>：对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 Store2 及后续写入操作被执行前，保证Load1 要读取的数据被读取完毕。 </li>
<li><strong>StoreStore</strong>：对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 Store2 及后续写入操作执行前，保证Store1 的写入操作对其它处理器可见。 </li>
<li><strong>StoreLoad</strong>：对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 Load2 及后续所有读取操作执行前，保证Store1 的写入对其他处理器可见。</li>
</ul>
<blockquote>
<p><strong>volatile 实现</strong></p>
</blockquote>
<p> volatile 写是在前面和后面<strong>分别插入内存屏障</strong>，而 volatile 读操作是在<strong>后面插入两个内存屏障</strong>。</p>
<ul>
<li>volatile 在写之前加入 StoreStore，在写之后加入 StoreLoad。</li>
<li>volatile 在读之后加入 LoadLoad 和 LoadStore。</li>
<li><strong>理解</strong>：这样可以保证<strong>不论读写是什么顺序，都不会重排序</strong>。</li>
</ul>
<p><img src="%E5%B9%B6%E5%8F%91.assets/640-1601218059639.webp" alt=""></p>
<p><img src="%E5%B9%B6%E5%8F%91.assets/640-1601218074021.webp" alt=""></p>
<hr>
<h3 id="6-并发编程的三个重要特性"><a href="#6-并发编程的三个重要特性" class="headerlink" title="6. 并发编程的三个重要特性"></a>6. 并发编程的三个重要特性</h3><ol>
<li><strong>原子性</strong>：表示一个操作或多次操作，是<strong>不可中断的</strong>，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。<code>synchronized</code> 可以保证代码片段的原子性。 </li>
<li><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。 </li>
<li><strong>有序性</strong>：并发时，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li>
</ol>
<hr>
<h3 id="7-synchronized-关键字和-volatile-关键字的关系"><a href="#7-synchronized-关键字和-volatile-关键字的关系" class="headerlink" title="7. synchronized 关键字和 volatile 关键字的关系"></a>7. synchronized 关键字和 volatile 关键字的关系</h3><ul>
<li><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在。</li>
</ul>
<ol>
<li><strong>volatile 关键字</strong>是线程同步的 <strong>轻量级实现</strong>，所以 <strong>volatile 性能肯定比 synchronized 关键字要好</strong>。但是 <strong>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</li>
<li><strong>多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞</strong>。</li>
<li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong> </li>
<li><strong>volatile</strong> 关键字主要用于解决<strong>变量</strong>在多个线程之间的<strong>可见性</strong>，而 <strong>synchronized</strong> 关键字解决的是多个线程之间访问资源的<strong>同步性</strong>。</li>
</ol>
<hr>
<h2 id="3-ThreadLocal-和-线程池"><a href="#3-ThreadLocal-和-线程池" class="headerlink" title="3. ThreadLocal 和 线程池"></a>3. ThreadLocal 和 线程池</h2><h3 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong>JDK 中提供的 <code>ThreadLocal</code> 类正是为了解决这样的问题。 </p>
<p><code>ThreadLocal</code> 类主要解决的就是让<strong>每个线程绑定自己的值</strong>。如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的<strong>本地副本</strong>。<strong>他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值</strong>，从而避免了线程安全问题。</p>
<hr>
<h3 id="2-ThreadLocal-原理"><a href="#2-ThreadLocal-原理" class="headerlink" title="2. ThreadLocal 原理"></a>2. ThreadLocal 原理</h3><ol>
<li><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类</strong>。 </li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * ThreadLocalMap is a customized hash map suitable only for
     * maintaining thread local values. No operations are exported
     * outside of the ThreadLocal class. The class is package private to
     * allow declaration of fields in class Thread.  To help deal with
     * very large and long-lived usages, the hash table entries use
     * WeakReferences for keys. However, since reference queues are not
     * used, stale entries are guaranteed to be removed only when
     * the table starts running out of space.
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span></code></pre>
<ol start="2">
<li><strong><code>Thread</code> 类中有两个 <code>ThreadLocalMap</code> 类型的变量</strong>，我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null。<strong>ThreadLocalMap 虽然是ThreadLocal 的内部类，但是作为变量由线程来维护的</strong>。</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*...其他属性...*/</span>

    <span class="token comment" spellcheck="true">/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */</span>
    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/*
     * InheritableThreadLocal values pertaining to this thread. This map is
     * maintained by the InheritableThreadLocal class.
     */</span>
    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap inheritableThreadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre>
<ol start="3">
<li>当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code> 或 <code>get</code> 方法来修改和获取 value 时，实际上调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code> 方法。</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//获得当前线程</span>
    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//得到当前线程中维护的ThreadLocalMap</span>
    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//ThreadLocalMap的key值就是当前的ThreadLocal(this)，value就是要设置的value</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">//调用的是ThreadLocalMap的set方法</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//获得当前线程</span>
    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//得到当前线程中维护的ThreadLocalMap</span>
    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//传入的key值就是当前的ThreadLocal(this)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//调用的是ThreadLocalMap的get方法</span>
        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值。</strong></li>
</ul>
<hr>
<h3 id="3-ThreadLocal-内存泄漏问题"><a href="#3-ThreadLocal-内存泄漏问题" class="headerlink" title="3. ThreadLocal 内存泄漏问题"></a>3. ThreadLocal 内存泄漏问题</h3><ul>
<li><p>观察源码可以发现，<code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。 </p>
</li>
<li><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后 最好手动调用 <code>remove()</code> 方法。</p>
</li>
</ul>
<hr>
<h3 id="4-使用线程池的好处"><a href="#4-使用线程池的好处" class="headerlink" title="4. 使用线程池的好处"></a>4. 使用线程池的好处</h3><ol>
<li><strong>降低资源消耗</strong>：重复利用已创建的线程来降低创建和销毁线程造成的消耗。</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要的等到线程创建，只需要从线程池中取出空闲的线程，就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的<strong>分配，调优和监控</strong>。</li>
</ol>
<hr>
<h3 id="5-线程池的使用"><a href="#5-线程池的使用" class="headerlink" title="5. 线程池的使用"></a>5. 线程池的使用</h3><ol>
<li><strong>Executor</strong> 是一个顶层接口，在它里面只声明了一个方法 <code>execute(Runnable)</code>，返回值为void，参数为 Runnable 类型，从字面意思可以理解，就是用来执行传进去的任务的； </li>
<li><strong>ExecutorService</strong> 接口继承了 Executor 接口，并声明了一些方法：<code>submit()</code>、<code>invokeAll()</code> 以及 <code>shutdown()</code> 等；</li>
<li>抽象类 <strong>AbstractExecutorService</strong> 实现了 ExecutorService 接口，基本实现了ExecutorService 中声明的所有方法；</li>
<li><strong>ThreadPoolExecutor</strong> 继承了类 AbstractExecutorService。</li>
</ol>
<ul>
<li><p>在 <strong>ThreadPoolExecutor</strong> 类中有几个重要的方法：<code>execute(Runnable)</code>、<code>submit()</code> 和 <code>shutdown()</code>等。</p>
</li>
<li><p>《阿里巴巴Java开发手册》中强制线程池<strong>不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式</strong>。</p>
</li>
</ul>
<hr>
<h3 id="6-线程池的种类"><a href="#6-线程池的种类" class="headerlink" title="6. 线程池的种类"></a>6. 线程池的种类</h3><ul>
<li><strong>Executors</strong> 是 java.util.concurrent 包下的一个类，提供了若干个静态方法，用于生成不同类型的线程池。Executors一共可以创建下面这四类线程池： </li>
</ul>
<ol>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 该方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>ScheduledThreadPool：</strong> 该方法返回一个<strong>可定期或者延时执行任务的定长线程池</strong>，支持定时及周期性任务执行。</li>
</ol>
<ul>
<li>ExecutorService 接口有两个实现类，分别是 AbstractExecutorService 和 <strong>ScheduledExecutorService</strong>，通过这个实现类也可以创建 ScheduledThreadPool。</li>
</ul>
<hr>
<h3 id="7-实现-Runnable-接口和-Callable-接口的区别"><a href="#7-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="7. 实现 Runnable 接口和 Callable 接口的区别"></a>7. 实现 Runnable 接口和 Callable 接口的区别</h3><p><code>Runnable</code> 自 Java 1.0以来一直存在，但 <code>Callable</code> 在 Java 1.5中引入，目的就是为了来处理 <code>Runnable</code> 不支持的用例。</p>
<p><strong><code>Runnable</code> 接口</strong>不会<strong>返回结果</strong>或<strong>抛出异常</strong>，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。 </p>
<ul>
<li><code>Runnable</code> 接口，只声明了一个 <code>run()</code> 方法，且<strong>无返回值</strong>。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
    * 被线程执行，没有返回值也无法抛出异常
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li><code>Callable</code> 接口，泛型接口，只声明了一个 <code>call()</code> 方法，<strong>返回值类型是传递进来的 V 类型，且会抛出异常</strong>。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 计算结果，或在无法这样做时抛出异常。
     * @return 计算得出的结果
     * @throws 如果无法计算结果，则抛出异常
     */</span>
    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。 </li>
</ul>
<hr>
<h3 id="8-execute-方法和-submit-方法的区别"><a href="#8-execute-方法和-submit-方法的区别" class="headerlink" title="8. execute() 方法和 submit() 方法的区别"></a>8. execute() 方法和 submit() 方法的区别</h3><ol>
<li><strong>返回值</strong>：<code>execute()</code>方法用于提交<strong>不需要返回值</strong>的任务，所以无法判断任务是否被线程池执行成功与否；<code>submit()</code> 方法用于提交<strong>需要返回值</strong>的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值。</li>
<li><strong>可接受的任务类型</strong>：<code>execute()</code>方法<strong>只能接受 Runnable 类型的任务</strong>；<code>submit()</code> 方法既可以接受 Runnable 类型的任务，<strong>也可以接受 Callable 类型的任务</strong>。</li>
<li><strong>异常处理</strong>：<code>execute()</code> 接受的是 Runnable 接口的任务，所以只能使用 try、catch 来捕获CheckedException，通过实现 UncaughtExceptionHandle 接口处理 UncheckedException，即和普通线程的处理方式完全一致；<code>submit()</code> 方法不管接受的是什么任务，都要通过返回值 <code>Future</code> 的 <code>get()</code> 方法来处理异常，否则都会吞掉异常。<code>submit()</code> 中的 <code>call()</code> 方法可以抛出异常，所以不管是 CheckedException 还是 UncheckedException，直接抛出即可。总结：<strong><code>submit()</code> 方法处理异常更方便</strong>。</li>
</ol>
<hr>
<h3 id="9-ThreadPoolExecutor-类分析"><a href="#9-ThreadPoolExecutor-类分析" class="headerlink" title="9.  ThreadPoolExecutor 类分析"></a>9.  ThreadPoolExecutor 类分析</h3><ol>
<li><p>重要参数（7大参数）分析</p>
<ol>
<li><strong>corePoolSize</strong>：核心线程数。定义了<strong>最小可以同时运行的线程数量</strong>。<ol>
<li>CPU 密集型：可以设置为 CPU 核数 + 1；</li>
<li>IO 密集型：可以设置为 CPU 核数 * 2；</li>
</ol>
</li>
<li><strong>maximumPoolSize</strong>：最大线程数。当队列中存放的任务达到队列容量时，当前可以运行的线程数变成最大线程数。</li>
<li><strong>workQueue</strong>：等待队列，一般使用 BlockingQueue，如 ArrayBlockingQueue，LinkedBlockingQueue。当前运行的线程数到达<strong>核心线程数</strong>时，新来的任务就会被存放在队列中。 </li>
<li><strong>keepAliveTime</strong>：当线程池中的线程数大于 <strong>corePoolSize</strong> 时，又没有新任务提交，<strong>核心线程外的线程</strong>会等待 keepAliveTime 后被回收销毁。</li>
<li><strong>unit</strong>：keepAliveTime 参数的时间单位。</li>
<li><strong>threadFactory</strong>：创建新线程时使用。</li>
<li><strong>handler</strong>：<strong>饱和策略</strong>。</li>
</ol>
</li>
<li><p>饱和策略</p>
<p><strong>定义</strong>：如果<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满</strong>了时，<code>ThreadPoolTaskExecutor</code> 定义一些策略: </p>
<ul>
<li><p><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code> 来拒绝新任务的处理。</p>
</li>
<li><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程（<strong>我理解为当前线程</strong>）运行任务，也就是直接在调用 <code>execute</code> 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</p>
</li>
<li><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</p>
</li>
<li><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。 </p>
</li>
<li><p><strong>总结</strong>：当不指定饱和策略时，默认使用 <strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。 </p>
</li>
</ul>
</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 用给定的初始参数创建一个新的ThreadPoolExecutor。
 */</span>
<span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          TimeUnit unit<span class="token punctuation">,</span>
                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>
                          ThreadFactory threadFactory<span class="token punctuation">,</span>
                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="10-线程池Demo：Runnable-TreadPoolExecutor"><a href="#10-线程池Demo：Runnable-TreadPoolExecutor" class="headerlink" title="10. 线程池Demo：Runnable + TreadPoolExecutor"></a>10. 线程池Demo：Runnable + TreadPoolExecutor</h3><ul>
<li>首先创建 Runnable 接口的实现类：</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。
 * @author shuang.kou
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String command<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//这里写一个带参构造我没有看出作用，为此还重写了toString方法</span>
    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Start. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" End. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CORE_POOL_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long KEEP_ALIVE_TIME <span class="token operator">=</span> 1L<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">//使用阿里巴巴推荐的创建线程池的方式</span>
        <span class="token comment" spellcheck="true">//通过ThreadPoolExecutor构造函数自定义参数创建</span>
        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
                CORE_POOL_SIZE<span class="token punctuation">,</span>
                MAX_POOL_SIZE<span class="token punctuation">,</span>
                KEEP_ALIVE_TIME<span class="token punctuation">,</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//共创建了十个MyRunnable线程任务</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>
            Runnable worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//执行Runnable</span>
            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//终止线程池</span>
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//自旋，等待线程池终止</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finished all threads"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>输出为：</li>
</ul>
<pre class=" language-java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span></code></pre>
<hr>
<h3 id="11-线程池原理-执行策略"><a href="#11-线程池原理-执行策略" class="headerlink" title="11. 线程池原理 / 执行策略"></a>11. 线程池原理 / 执行策略</h3><p><img src="02-%E5%B9%B6%E5%8F%91.assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>
<hr>
<h2 id="4-Atomic原子类-和-AQS"><a href="#4-Atomic原子类-和-AQS" class="headerlink" title="4. Atomic原子类 和 AQS"></a>4. Atomic原子类 和 AQS</h2><h3 id="1-Atomic原子类和其4种类型"><a href="#1-Atomic原子类和其4种类型" class="headerlink" title="1. Atomic原子类和其4种类型"></a>1. Atomic原子类和其4种类型</h3><ul>
<li>原子类就是具有原子性/原子操作特征的类。</li>
<li>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下 。</li>
</ul>
<ol>
<li><strong>原子更新基本类型</strong>：使用原子的方式更新基本类型<ul>
<li>AtomicInteger：整形原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
</li>
<li><strong>原子更新数组类型</strong>：使用原子的方式更新数组里的某个元素<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
</li>
<li><strong>原子更新引用类型</strong>：<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新引用类型里的字段原子类</li>
<li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li><strong>原子更新字段（修改对象的属性）</strong>：<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-AtomicInteger-的使用"><a href="#2-AtomicInteger-的使用" class="headerlink" title="2. AtomicInteger 的使用"></a>2. AtomicInteger 的使用</h3><ul>
<li>AtomicInteger 类的常用方法：</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并设置新的值</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并自增</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并自减</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并加上预期的值</span>
<span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></code></pre>
<ul>
<li>AtomicInteger 类的使用示例：使用 AtomicInteger 之后，<strong>不用对 <code>increment()</code> 方法加锁也可以保证线程安全</strong>。 </li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AtomicIntegerTest</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//创建一个AtomicInteger对象，通过对象调用方法</span>
        <span class="token keyword">private</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="3-AtomicInteger-类的原理"><a href="#3-AtomicInteger-类的原理" class="headerlink" title="3. AtomicInteger 类的原理"></a>3. AtomicInteger 类的原理</h3><ul>
<li>AtomicInteger 类的部分源码：</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>
                <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span></code></pre>
<hr>
<h3 id="4-CAS"><a href="#4-CAS" class="headerlink" title="4. CAS"></a>4. CAS</h3><hr>
<h3 id="5-AQS-Abstract-Queued-Synchronizer"><a href="#5-AQS-Abstract-Queued-Synchronizer" class="headerlink" title="5. AQS(Abstract Queued Synchronizer)"></a>5. AQS(Abstract Queued Synchronizer)</h3><p>AQS核心思想是，如果被请求的共享资源<strong>空闲</strong>，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为<strong>锁定状态</strong>。如果被请求的共享资源被<strong>占用</strong>，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将<strong>暂时获取不到锁的线程加入到队列中</strong>。</p>
<ul>
<li>CLH(Craig,Landin,and Hagersten)队列是一个<strong>虚拟</strong>的双向队列（<strong>虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系</strong>）。AQS 是将每条请求共享资源的线程封装成一个CLH 锁队列的一个结点（Node）来实现锁的分配。 </li>
</ul>
<p>AQS使用一个 <strong>int volatile 成员变量 state</strong> 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS使用 CAS 对该同步状态进行原子操作实现对其值的修改。状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//共享变量，使用volatile修饰保证线程可见性</span>

<span class="token comment" spellcheck="true">//返回同步状态的当前值</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> state<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">// 设置同步状态的值</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        state <span class="token operator">=</span> newState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h3 id="6-AQS-对资源的共享方式"><a href="#6-AQS-对资源的共享方式" class="headerlink" title="6. AQS 对资源的共享方式"></a>6. AQS 对资源的共享方式</h3><p>AQS定义<strong>两种资源共享方式</strong>：</p>
<ol>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。这其中又可以分为<strong>公平锁</strong>和<strong>非公平锁</strong>。<ul>
<li><strong>公平锁</strong>：按照线程在队列中顺序，先到者先拿到锁。</li>
<li><strong>非公平锁</strong>：所有线程同时抢锁，与顺序无关。</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可以同时执行，如 Semaphore/CountDownLatch。</li>
</ol>
<hr>
<h3 id="7-AQS-组件"><a href="#7-AQS-组件" class="headerlink" title="7. AQS 组件"></a>7. AQS 组件</h3><ul>
<li><strong>Semaphore</strong>（信号量）：允许多个线程同时访问。synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch</strong>（倒计时器）：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以用 await 方法让某一个线程等待直到倒计时结束，再开始执行，倒计时方法为 countDown。</li>
<li><strong>CyclicBarrier</strong>（循环栅栏）：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，调用 await 方法让一组线程阻塞，直到线程数量达到设定的值时，屏障才会开门，所有被屏障拦截的线程才会继续工作。并且这个屏障是可以循环使用的。</li>
</ul>
<hr>
<p>AQS原理和相关源码分析的文章：</p>
<p><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">巨瑞康</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://x1a0kang.github.io/2020/08/25/bing-fa/">https://x1a0kang.github.io/2020/08/25/bing-fa/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">巨瑞康</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/08/25/spring/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="Spring">
                        
                        <span class="card-title">Spring</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Spring1. IoC 控制反转1. 什么是 IoCIoC（Inversion of control ）控制反转/反转控制。它是一种思想而不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。 

传统的开发方式 ：往往
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    Java学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95/">
                        <span class="chip bg-color">面试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/08/25/rong-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="容器">
                        
                        <span class="card-title">容器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            容器1. 容器总结1. 继承关系
Collection 接口

List 接口

ArrayList：Object数组。线程不安全。
Vector：Object数组。线程安全。
LinkedList：双向链表（JDK 1.6 前为循环链表，
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-08-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    Java学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95/">
                        <span class="chip bg-color">面试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">巨瑞康</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">94.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/x1a0kang" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:18810298505@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=976372548" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 976372548" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
